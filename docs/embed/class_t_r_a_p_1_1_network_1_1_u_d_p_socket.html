<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.17"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>TRAP: TRAP::Network::UDPSocket Class Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand" href="annotated.html">TRAP 0.6.53</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>TRAP</b></li><li class="navelem"><b>Network</b></li><li class="navelem"><a class="el" href="class_t_r_a_p_1_1_network_1_1_u_d_p_socket.html">UDPSocket</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_t_r_a_p_1_1_network_1_1_u_d_p_socket-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TRAP::Network::UDPSocket Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for TRAP::Network::UDPSocket:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_t_r_a_p_1_1_network_1_1_u_d_p_socket.png" usemap="#TRAP::Network::UDPSocket_map" alt=""/>
  <map id="TRAP::Network::UDPSocket_map" name="TRAP::Network::UDPSocket_map">
<area href="class_t_r_a_p_1_1_network_1_1_socket.html" alt="TRAP::Network::Socket" shape="rect" coords="0,0,165,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a51c6ed86366c894aee89fb5f0bb05b7d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>MaxDatagramSize</b> = 65507
 }</td></tr>
<tr class="memdesc:a51c6ed86366c894aee89fb5f0bb05b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants  <a href="class_t_r_a_p_1_1_network_1_1_u_d_p_socket.html#a51c6ed86366c894aee89fb5f0bb05b7d">More...</a><br /></td></tr>
<tr class="separator:a51c6ed86366c894aee89fb5f0bb05b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_class_t_r_a_p_1_1_network_1_1_socket"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_t_r_a_p_1_1_network_1_1_socket')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_t_r_a_p_1_1_network_1_1_socket.html">TRAP::Network::Socket</a></td></tr>
<tr class="memitem:a5b9431e417a9ed2b13b121462e9f0f77 inherit pub_types_class_t_r_a_p_1_1_network_1_1_socket"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_network_1_1_socket.html#a5b9431e417a9ed2b13b121462e9f0f77">Status</a> { <br />
&#160;&#160;<b>Done</b>, 
<b>NotReady</b>, 
<b>Partial</b>, 
<b>Disconnected</b>, 
<br />
&#160;&#160;<b>Error</b>
<br />
 }</td></tr>
<tr class="memdesc:a5b9431e417a9ed2b13b121462e9f0f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status codes that may be returned by socket functions  <a href="class_t_r_a_p_1_1_network_1_1_socket.html#a5b9431e417a9ed2b13b121462e9f0f77">More...</a><br /></td></tr>
<tr class="separator:a5b9431e417a9ed2b13b121462e9f0f77 inherit pub_types_class_t_r_a_p_1_1_network_1_1_socket"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc19d03ea8285282eae32e9e68ea6b1 inherit pub_types_class_t_r_a_p_1_1_network_1_1_socket"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>AnyPort</b> = 0
 }</td></tr>
<tr class="memdesc:aabc19d03ea8285282eae32e9e68ea6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some special values used by sockets  <a href="class_t_r_a_p_1_1_network_1_1_socket.html#aabc19d03ea8285282eae32e9e68ea6b1">More...</a><br /></td></tr>
<tr class="separator:aabc19d03ea8285282eae32e9e68ea6b1 inherit pub_types_class_t_r_a_p_1_1_network_1_1_socket"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa768f5fd18875a767316facca33d6754"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_network_1_1_u_d_p_socket.html#aa768f5fd18875a767316facca33d6754">UDPSocket</a> ()</td></tr>
<tr class="memdesc:aa768f5fd18875a767316facca33d6754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor  <a href="class_t_r_a_p_1_1_network_1_1_u_d_p_socket.html#aa768f5fd18875a767316facca33d6754">More...</a><br /></td></tr>
<tr class="separator:aa768f5fd18875a767316facca33d6754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac687602fb2be85eaa23fc24a393180a2"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_network_1_1_u_d_p_socket.html#ac687602fb2be85eaa23fc24a393180a2">GetLocalPort</a> () const</td></tr>
<tr class="memdesc:ac687602fb2be85eaa23fc24a393180a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the port to which the socket is bound locally.<br  />
 <br  />
 If the socket is not bound to a port, this function returns 0.  <a href="class_t_r_a_p_1_1_network_1_1_u_d_p_socket.html#ac687602fb2be85eaa23fc24a393180a2">More...</a><br /></td></tr>
<tr class="separator:ac687602fb2be85eaa23fc24a393180a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7118ffc311b6ecfda2d23f2d3c8aa469"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_r_a_p_1_1_network_1_1_socket.html#a5b9431e417a9ed2b13b121462e9f0f77">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_network_1_1_u_d_p_socket.html#a7118ffc311b6ecfda2d23f2d3c8aa469">Bind</a> (uint16_t port, const <a class="el" href="class_t_r_a_p_1_1_network_1_1_i_pv4_address.html">IPv4Address</a> &amp;address=IPv4Address::Any)</td></tr>
<tr class="memdesc:a7118ffc311b6ecfda2d23f2d3c8aa469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the socket to a specific port.<br  />
 <br  />
 Binding the socket to a port is necessary for being able to receive data on that port.<br  />
 When providing TRAP::Network::Socket::AnyPort as part, the listener will request an available port from the system.<br  />
 The chosen port can be retrieved by calling <a class="el" href="class_t_r_a_p_1_1_network_1_1_u_d_p_socket.html#ac687602fb2be85eaa23fc24a393180a2" title="Get the port to which the socket is bound locally.    If the socket is not bound to a port,...">GetLocalPort()</a>.<br  />
 <br  />
 Since the socket cn only be bound to a single port at any given moment, if it is already bound when this function is called, it will be unbound from the previous port before being bound to the new one.  <a href="class_t_r_a_p_1_1_network_1_1_u_d_p_socket.html#a7118ffc311b6ecfda2d23f2d3c8aa469">More...</a><br /></td></tr>
<tr class="separator:a7118ffc311b6ecfda2d23f2d3c8aa469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615d252c85457a5fb99fdf76ef6c0eeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_network_1_1_u_d_p_socket.html#a615d252c85457a5fb99fdf76ef6c0eeb">Unbind</a> ()</td></tr>
<tr class="memdesc:a615d252c85457a5fb99fdf76ef6c0eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unbind the socket from the local port to which it is bound.<br  />
 <br  />
 The port that the socket was previously bound to is immediately made available to the operating system after this function is called.<br  />
 This means that a subsequent call to <a class="el" href="class_t_r_a_p_1_1_network_1_1_u_d_p_socket.html#a7118ffc311b6ecfda2d23f2d3c8aa469" title="Bind the socket to a specific port.    Binding the socket to a port is necessary for being able to re...">Bind()</a> will be able to re-bind the port if no other process has done so in the mean time.<br  />
 If the socket is not bound to a port, this function has no effect.  <a href="class_t_r_a_p_1_1_network_1_1_u_d_p_socket.html#a615d252c85457a5fb99fdf76ef6c0eeb">More...</a><br /></td></tr>
<tr class="separator:a615d252c85457a5fb99fdf76ef6c0eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ffd5c41805727027ddf602c0e3f1a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_r_a_p_1_1_network_1_1_socket.html#a5b9431e417a9ed2b13b121462e9f0f77">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_network_1_1_u_d_p_socket.html#ae6ffd5c41805727027ddf602c0e3f1a7">Send</a> (const void *data, std::size_t size, const <a class="el" href="class_t_r_a_p_1_1_network_1_1_i_pv4_address.html">IPv4Address</a> &amp;remoteAddress, uint16_t remotePort)</td></tr>
<tr class="memdesc:ae6ffd5c41805727027ddf602c0e3f1a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send raw data to a remote peer.<br  />
 <br  />
 Make sure that size is not greater than UDPSocket::MaxDatagramSize, otherwise this function will fail and no data will be sent.  <a href="class_t_r_a_p_1_1_network_1_1_u_d_p_socket.html#ae6ffd5c41805727027ddf602c0e3f1a7">More...</a><br /></td></tr>
<tr class="separator:ae6ffd5c41805727027ddf602c0e3f1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb373a7f0017fe6eefb2ce7c7e9dad5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_r_a_p_1_1_network_1_1_socket.html#a5b9431e417a9ed2b13b121462e9f0f77">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_network_1_1_u_d_p_socket.html#a8cb373a7f0017fe6eefb2ce7c7e9dad5">Receive</a> (void *data, std::size_t size, std::size_t &amp;received, <a class="el" href="class_t_r_a_p_1_1_network_1_1_i_pv4_address.html">IPv4Address</a> &amp;remoteAddress, uint16_t &amp;remotePort) const</td></tr>
<tr class="memdesc:a8cb373a7f0017fe6eefb2ce7c7e9dad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive raw data from a remote peer.<br  />
 <br  />
 In blocking mode, this function will wait until some bytes are actually received.<br  />
 Be careful to use a buffer which is large enough for the data that you intend to receive, if it is too small then an error will be returned and *all* the data will be list.  <a href="class_t_r_a_p_1_1_network_1_1_u_d_p_socket.html#a8cb373a7f0017fe6eefb2ce7c7e9dad5">More...</a><br /></td></tr>
<tr class="separator:a8cb373a7f0017fe6eefb2ce7c7e9dad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7423ec7418e2b1e91b377923aedab70a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_r_a_p_1_1_network_1_1_socket.html#a5b9431e417a9ed2b13b121462e9f0f77">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_network_1_1_u_d_p_socket.html#a7423ec7418e2b1e91b377923aedab70a">Send</a> (<a class="el" href="class_t_r_a_p_1_1_network_1_1_packet.html">Packet</a> &amp;packet, const <a class="el" href="class_t_r_a_p_1_1_network_1_1_i_pv4_address.html">IPv4Address</a> &amp;remoteAddress, uint16_t remotePort)</td></tr>
<tr class="memdesc:a7423ec7418e2b1e91b377923aedab70a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a formatted packet of data to a remote peer.<br  />
 <br  />
 Make sure that the packet size is not greater than UDPSocket::MaxDatagramSize, otherwise this function will fail and no data will be sent.  <a href="class_t_r_a_p_1_1_network_1_1_u_d_p_socket.html#a7423ec7418e2b1e91b377923aedab70a">More...</a><br /></td></tr>
<tr class="separator:a7423ec7418e2b1e91b377923aedab70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b542fe5e77b3709b2d81b20838c962e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_r_a_p_1_1_network_1_1_socket.html#a5b9431e417a9ed2b13b121462e9f0f77">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_network_1_1_u_d_p_socket.html#a1b542fe5e77b3709b2d81b20838c962e">Receive</a> (<a class="el" href="class_t_r_a_p_1_1_network_1_1_packet.html">Packet</a> &amp;packet, <a class="el" href="class_t_r_a_p_1_1_network_1_1_i_pv4_address.html">IPv4Address</a> &amp;remoteAddress, uint16_t &amp;remotePort)</td></tr>
<tr class="memdesc:a1b542fe5e77b3709b2d81b20838c962e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a formatted packet of data from a remote peer.<br  />
 <br  />
 In blocking mode, this function will wait until the whole packet has been received.  <a href="class_t_r_a_p_1_1_network_1_1_u_d_p_socket.html#a1b542fe5e77b3709b2d81b20838c962e">More...</a><br /></td></tr>
<tr class="separator:a1b542fe5e77b3709b2d81b20838c962e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_t_r_a_p_1_1_network_1_1_socket"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_t_r_a_p_1_1_network_1_1_socket')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_t_r_a_p_1_1_network_1_1_socket.html">TRAP::Network::Socket</a></td></tr>
<tr class="memitem:af8dffa45f208e99cbb6169bc7144e830 inherit pub_methods_class_t_r_a_p_1_1_network_1_1_socket"><td class="memItemLeft" align="right" valign="top"><a id="af8dffa45f208e99cbb6169bc7144e830"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Socket</b> (const <a class="el" href="class_t_r_a_p_1_1_network_1_1_socket.html">Socket</a> &amp;)=delete</td></tr>
<tr class="separator:af8dffa45f208e99cbb6169bc7144e830 inherit pub_methods_class_t_r_a_p_1_1_network_1_1_socket"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fcf22142fee2f1c88d80ddc445eb4f6 inherit pub_methods_class_t_r_a_p_1_1_network_1_1_socket"><td class="memItemLeft" align="right" valign="top"><a id="a7fcf22142fee2f1c88d80ddc445eb4f6"></a>
<a class="el" href="class_t_r_a_p_1_1_network_1_1_socket.html">Socket</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_t_r_a_p_1_1_network_1_1_socket.html">Socket</a> &amp;)=delete</td></tr>
<tr class="separator:a7fcf22142fee2f1c88d80ddc445eb4f6 inherit pub_methods_class_t_r_a_p_1_1_network_1_1_socket"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef440a21a8b7d07705a14b20a54ffff inherit pub_methods_class_t_r_a_p_1_1_network_1_1_socket"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_network_1_1_socket.html#a0ef440a21a8b7d07705a14b20a54ffff">~Socket</a> ()</td></tr>
<tr class="memdesc:a0ef440a21a8b7d07705a14b20a54ffff inherit pub_methods_class_t_r_a_p_1_1_network_1_1_socket"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor  <a href="class_t_r_a_p_1_1_network_1_1_socket.html#a0ef440a21a8b7d07705a14b20a54ffff">More...</a><br /></td></tr>
<tr class="separator:a0ef440a21a8b7d07705a14b20a54ffff inherit pub_methods_class_t_r_a_p_1_1_network_1_1_socket"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74bc5397a1e40a6db8bf7763cb7ef0b1 inherit pub_methods_class_t_r_a_p_1_1_network_1_1_socket"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_network_1_1_socket.html#a74bc5397a1e40a6db8bf7763cb7ef0b1">SetBlocking</a> (bool blocking)</td></tr>
<tr class="memdesc:a74bc5397a1e40a6db8bf7763cb7ef0b1 inherit pub_methods_class_t_r_a_p_1_1_network_1_1_socket"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the blocking state of the socket.<br  />
 <br  />
 In blocking mode, calls will not return until they have completed their task.<br  />
 For example, a call to receive in blocking mode won't return until some data was actually received.<br  />
 In non-blocking mode, calls will always return immediately, using the return code to signal whether there was data available or not.<br  />
 By default, all sockets are blocking.  <a href="class_t_r_a_p_1_1_network_1_1_socket.html#a74bc5397a1e40a6db8bf7763cb7ef0b1">More...</a><br /></td></tr>
<tr class="separator:a74bc5397a1e40a6db8bf7763cb7ef0b1 inherit pub_methods_class_t_r_a_p_1_1_network_1_1_socket"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab97946284a9e629ed8c476635fba2e5 inherit pub_methods_class_t_r_a_p_1_1_network_1_1_socket"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_network_1_1_socket.html#aab97946284a9e629ed8c476635fba2e5">IsBlocking</a> () const</td></tr>
<tr class="memdesc:aab97946284a9e629ed8c476635fba2e5 inherit pub_methods_class_t_r_a_p_1_1_network_1_1_socket"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell whether the socket is in blocking or non-blocking mode  <a href="class_t_r_a_p_1_1_network_1_1_socket.html#aab97946284a9e629ed8c476635fba2e5">More...</a><br /></td></tr>
<tr class="separator:aab97946284a9e629ed8c476635fba2e5 inherit pub_methods_class_t_r_a_p_1_1_network_1_1_socket"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_class_t_r_a_p_1_1_network_1_1_socket"><td colspan="2" onclick="javascript:toggleInherit('pro_types_class_t_r_a_p_1_1_network_1_1_socket')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="class_t_r_a_p_1_1_network_1_1_socket.html">TRAP::Network::Socket</a></td></tr>
<tr class="memitem:a0bf42978715a480dfdec1f8256aa378f inherit pro_types_class_t_r_a_p_1_1_network_1_1_socket"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_network_1_1_socket.html#a0bf42978715a480dfdec1f8256aa378f">Type</a> { <b>TCP</b>, 
<b>UDP</b>
 }</td></tr>
<tr class="memdesc:a0bf42978715a480dfdec1f8256aa378f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of protocols that the socket can use  <a href="class_t_r_a_p_1_1_network_1_1_socket.html#a0bf42978715a480dfdec1f8256aa378f">More...</a><br /></td></tr>
<tr class="separator:a0bf42978715a480dfdec1f8256aa378f inherit pro_types_class_t_r_a_p_1_1_network_1_1_socket"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_t_r_a_p_1_1_network_1_1_socket"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_t_r_a_p_1_1_network_1_1_socket')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_t_r_a_p_1_1_network_1_1_socket.html">TRAP::Network::Socket</a></td></tr>
<tr class="memitem:aad897f0fd82d697e8ce98d2c7ec8d8c1 inherit pro_methods_class_t_r_a_p_1_1_network_1_1_socket"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_network_1_1_socket.html#aad897f0fd82d697e8ce98d2c7ec8d8c1">Socket</a> (<a class="el" href="class_t_r_a_p_1_1_network_1_1_socket.html#a0bf42978715a480dfdec1f8256aa378f">Type</a> type)</td></tr>
<tr class="memdesc:aad897f0fd82d697e8ce98d2c7ec8d8c1 inherit pro_methods_class_t_r_a_p_1_1_network_1_1_socket"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.<br  />
 <br  />
 This constructor can only be accessed by derived classes.  <a href="class_t_r_a_p_1_1_network_1_1_socket.html#aad897f0fd82d697e8ce98d2c7ec8d8c1">More...</a><br /></td></tr>
<tr class="separator:aad897f0fd82d697e8ce98d2c7ec8d8c1 inherit pro_methods_class_t_r_a_p_1_1_network_1_1_socket"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75838752d51548627be87bba2b58b8d inherit pro_methods_class_t_r_a_p_1_1_network_1_1_socket"><td class="memItemLeft" align="right" valign="top">SocketHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_network_1_1_socket.html#ad75838752d51548627be87bba2b58b8d">GetHandle</a> () const</td></tr>
<tr class="memdesc:ad75838752d51548627be87bba2b58b8d inherit pro_methods_class_t_r_a_p_1_1_network_1_1_socket"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the internal handle of the socket.<br  />
 <br  />
 The returned handle may be invalid if the socket was not created yet (or already destroyed).<br  />
 This function can only be accessed by derived classes.  <a href="class_t_r_a_p_1_1_network_1_1_socket.html#ad75838752d51548627be87bba2b58b8d">More...</a><br /></td></tr>
<tr class="separator:ad75838752d51548627be87bba2b58b8d inherit pro_methods_class_t_r_a_p_1_1_network_1_1_socket"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d2cb0119a0f531a5c357d3c03ca9db inherit pro_methods_class_t_r_a_p_1_1_network_1_1_socket"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_network_1_1_socket.html#a22d2cb0119a0f531a5c357d3c03ca9db">CreateIPv4</a> ()</td></tr>
<tr class="memdesc:a22d2cb0119a0f531a5c357d3c03ca9db inherit pro_methods_class_t_r_a_p_1_1_network_1_1_socket"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the internal representation of the socket.<br  />
 <br  />
 This function can only be accessed by derived classes.  <a href="class_t_r_a_p_1_1_network_1_1_socket.html#a22d2cb0119a0f531a5c357d3c03ca9db">More...</a><br /></td></tr>
<tr class="separator:a22d2cb0119a0f531a5c357d3c03ca9db inherit pro_methods_class_t_r_a_p_1_1_network_1_1_socket"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2fcad39f71492d85057c448f282aa5 inherit pro_methods_class_t_r_a_p_1_1_network_1_1_socket"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_network_1_1_socket.html#a5a2fcad39f71492d85057c448f282aa5">CreateIPv6</a> ()</td></tr>
<tr class="memdesc:a5a2fcad39f71492d85057c448f282aa5 inherit pro_methods_class_t_r_a_p_1_1_network_1_1_socket"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the internal representation of the socket.<br  />
 <br  />
 This function can only be accessed by derived classes.  <a href="class_t_r_a_p_1_1_network_1_1_socket.html#a5a2fcad39f71492d85057c448f282aa5">More...</a><br /></td></tr>
<tr class="separator:a5a2fcad39f71492d85057c448f282aa5 inherit pro_methods_class_t_r_a_p_1_1_network_1_1_socket"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf81905bb86c14d7f7dc236ccccc06d0 inherit pro_methods_class_t_r_a_p_1_1_network_1_1_socket"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_network_1_1_socket.html#abf81905bb86c14d7f7dc236ccccc06d0">Create</a> (SocketHandle handle)</td></tr>
<tr class="memdesc:abf81905bb86c14d7f7dc236ccccc06d0 inherit pro_methods_class_t_r_a_p_1_1_network_1_1_socket"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the internal representation of the socket from a socket handle.<br  />
 <br  />
 This function can only be accessed by derived classes.  <a href="class_t_r_a_p_1_1_network_1_1_socket.html#abf81905bb86c14d7f7dc236ccccc06d0">More...</a><br /></td></tr>
<tr class="separator:abf81905bb86c14d7f7dc236ccccc06d0 inherit pro_methods_class_t_r_a_p_1_1_network_1_1_socket"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc4685298f38dc4a6007c7349795877 inherit pro_methods_class_t_r_a_p_1_1_network_1_1_socket"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_network_1_1_socket.html#a0fc4685298f38dc4a6007c7349795877">Close</a> ()</td></tr>
<tr class="memdesc:a0fc4685298f38dc4a6007c7349795877 inherit pro_methods_class_t_r_a_p_1_1_network_1_1_socket"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the socket gracefully.<br  />
 <br  />
 This function can only be accessed by derived classes.  <a href="class_t_r_a_p_1_1_network_1_1_socket.html#a0fc4685298f38dc4a6007c7349795877">More...</a><br /></td></tr>
<tr class="separator:a0fc4685298f38dc4a6007c7349795877 inherit pro_methods_class_t_r_a_p_1_1_network_1_1_socket"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a51c6ed86366c894aee89fb5f0bb05b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c6ed86366c894aee89fb5f0bb05b7d">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constants </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa768f5fd18875a767316facca33d6754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa768f5fd18875a767316facca33d6754">&#9670;&nbsp;</a></span>UDPSocket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TRAP::Network::UDPSocket::UDPSocket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7118ffc311b6ecfda2d23f2d3c8aa469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7118ffc311b6ecfda2d23f2d3c8aa469">&#9670;&nbsp;</a></span>Bind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_r_a_p_1_1_network_1_1_socket.html#a5b9431e417a9ed2b13b121462e9f0f77">Status</a> TRAP::Network::UDPSocket::Bind </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_r_a_p_1_1_network_1_1_i_pv4_address.html">IPv4Address</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em> = <code>IPv4Address::Any</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind the socket to a specific port.<br  />
 <br  />
 Binding the socket to a port is necessary for being able to receive data on that port.<br  />
 When providing TRAP::Network::Socket::AnyPort as part, the listener will request an available port from the system.<br  />
 The chosen port can be retrieved by calling <a class="el" href="class_t_r_a_p_1_1_network_1_1_u_d_p_socket.html#ac687602fb2be85eaa23fc24a393180a2" title="Get the port to which the socket is bound locally.    If the socket is not bound to a port,...">GetLocalPort()</a>.<br  />
 <br  />
 Since the socket cn only be bound to a single port at any given moment, if it is already bound when this function is called, it will be unbound from the previous port before being bound to the new one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>Port to bind the socket to</td></tr>
    <tr><td class="paramname">address</td><td>Address of the interface to bind to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>

</div>
</div>
<a id="ac687602fb2be85eaa23fc24a393180a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac687602fb2be85eaa23fc24a393180a2">&#9670;&nbsp;</a></span>GetLocalPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t TRAP::Network::UDPSocket::GetLocalPort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the port to which the socket is bound locally.<br  />
 <br  />
 If the socket is not bound to a port, this function returns 0. </p>
<dl class="section return"><dt>Returns</dt><dd>Port to which the socket is bound</dd></dl>

</div>
</div>
<a id="a1b542fe5e77b3709b2d81b20838c962e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b542fe5e77b3709b2d81b20838c962e">&#9670;&nbsp;</a></span>Receive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_r_a_p_1_1_network_1_1_socket.html#a5b9431e417a9ed2b13b121462e9f0f77">Status</a> TRAP::Network::UDPSocket::Receive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_r_a_p_1_1_network_1_1_packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_a_p_1_1_network_1_1_i_pv4_address.html">IPv4Address</a> &amp;&#160;</td>
          <td class="paramname"><em>remoteAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t &amp;&#160;</td>
          <td class="paramname"><em>remotePort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive a formatted packet of data from a remote peer.<br  />
 <br  />
 In blocking mode, this function will wait until the whole packet has been received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td><a class="el" href="class_t_r_a_p_1_1_network_1_1_packet.html" title="Utility class to build blocks of data to transfer over the network">Packet</a> to fill with the received data</td></tr>
    <tr><td class="paramname">remoteAddress</td><td>Address of the peer that sent the data</td></tr>
    <tr><td class="paramname">remotePort</td><td>Port of the peer that sent the data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>

</div>
</div>
<a id="a8cb373a7f0017fe6eefb2ce7c7e9dad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb373a7f0017fe6eefb2ce7c7e9dad5">&#9670;&nbsp;</a></span>Receive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_r_a_p_1_1_network_1_1_socket.html#a5b9431e417a9ed2b13b121462e9f0f77">Status</a> TRAP::Network::UDPSocket::Receive </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>received</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_a_p_1_1_network_1_1_i_pv4_address.html">IPv4Address</a> &amp;&#160;</td>
          <td class="paramname"><em>remoteAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t &amp;&#160;</td>
          <td class="paramname"><em>remotePort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive raw data from a remote peer.<br  />
 <br  />
 In blocking mode, this function will wait until some bytes are actually received.<br  />
 Be careful to use a buffer which is large enough for the data that you intend to receive, if it is too small then an error will be returned and *all* the data will be list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to the array to fill with the received bytes</td></tr>
    <tr><td class="paramname">size</td><td>Maximum number of bytes that can be received</td></tr>
    <tr><td class="paramname">received</td><td>This variable is filled with the actual number of bytes received</td></tr>
    <tr><td class="paramname">remoteAddress</td><td>Address of the peer that sent the data</td></tr>
    <tr><td class="paramname">remotePort</td><td>Port of the peer that sent the data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>

</div>
</div>
<a id="ae6ffd5c41805727027ddf602c0e3f1a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ffd5c41805727027ddf602c0e3f1a7">&#9670;&nbsp;</a></span>Send() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_r_a_p_1_1_network_1_1_socket.html#a5b9431e417a9ed2b13b121462e9f0f77">Status</a> TRAP::Network::UDPSocket::Send </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_r_a_p_1_1_network_1_1_i_pv4_address.html">IPv4Address</a> &amp;&#160;</td>
          <td class="paramname"><em>remoteAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>remotePort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send raw data to a remote peer.<br  />
 <br  />
 Make sure that size is not greater than UDPSocket::MaxDatagramSize, otherwise this function will fail and no data will be sent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to the sequence of bytes to send</td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to send</td></tr>
    <tr><td class="paramname">remoteAddress</td><td>Address of the receiver</td></tr>
    <tr><td class="paramname">remotePort</td><td>Port of the receiver to send the data to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>

</div>
</div>
<a id="a7423ec7418e2b1e91b377923aedab70a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7423ec7418e2b1e91b377923aedab70a">&#9670;&nbsp;</a></span>Send() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_r_a_p_1_1_network_1_1_socket.html#a5b9431e417a9ed2b13b121462e9f0f77">Status</a> TRAP::Network::UDPSocket::Send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_r_a_p_1_1_network_1_1_packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_r_a_p_1_1_network_1_1_i_pv4_address.html">IPv4Address</a> &amp;&#160;</td>
          <td class="paramname"><em>remoteAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>remotePort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a formatted packet of data to a remote peer.<br  />
 <br  />
 Make sure that the packet size is not greater than UDPSocket::MaxDatagramSize, otherwise this function will fail and no data will be sent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td><a class="el" href="class_t_r_a_p_1_1_network_1_1_packet.html" title="Utility class to build blocks of data to transfer over the network">Packet</a> to send</td></tr>
    <tr><td class="paramname">remoteAddress</td><td>Address of the received</td></tr>
    <tr><td class="paramname">remotePort</td><td>Port of the receiver to send the data to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code</dd></dl>

</div>
</div>
<a id="a615d252c85457a5fb99fdf76ef6c0eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615d252c85457a5fb99fdf76ef6c0eeb">&#9670;&nbsp;</a></span>Unbind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TRAP::Network::UDPSocket::Unbind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unbind the socket from the local port to which it is bound.<br  />
 <br  />
 The port that the socket was previously bound to is immediately made available to the operating system after this function is called.<br  />
 This means that a subsequent call to <a class="el" href="class_t_r_a_p_1_1_network_1_1_u_d_p_socket.html#a7118ffc311b6ecfda2d23f2d3c8aa469" title="Bind the socket to a specific port.    Binding the socket to a port is necessary for being able to re...">Bind()</a> will be able to re-bind the port if no other process has done so in the mean time.<br  />
 If the socket is not bound to a port, this function has no effect. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>TRAP/src/Network/Sockets/<a class="el" href="_u_d_p_socket_8h_source.html">UDPSocket.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<div class="footer">
  <div class="footer-copyright">
    &copy; Copyright 2020 Jan "GamesTrap" Sch√ºrkamp All Rights Reserved
  </div>
</div>
</body>
</html>
