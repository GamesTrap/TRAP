<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.9.1"/>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.js"></script>
        <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.css">
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
        <title>TRAP: TRAP::INTERNAL::WindowingAPI Class Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <script type="text/javascript" src="doxy-boot.js"></script>
        <!-- Latest compiled and minified CSS -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
        <!-- Latest compiled and minified JavaScript -->
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
        <!-- Custom input to switch branches -->
        <script>
            function switchBranchAction() {
                var branch = document.getElementById("branch_input").value;
                var form = this;
                window.location.href = window.location.hostname + '/en/' + branch;
            }
        </script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a href="annotated.html" class="navbar-brand">TRAP 0.7.38</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>TRAP</b></li><li class="navelem"><b>INTERNAL</b></li><li class="navelem"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TRAP::INTERNAL::WindowingAPI Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_cursor.html">InternalCursor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cursor structure.  <a href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_cursor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_monitor.html">InternalMonitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_t_r_a_p_1_1_monitor.html" title="Class representing a physical monitor.">Monitor</a> structure.  <a href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_monitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_video_mode.html">InternalVideoMode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This describes a single video mode.  <a href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_video_mode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_t_r_a_p_1_1_window.html" title="Class representing a desktop system based window.">Window</a> structure.  <a href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad6083eae3d18232f141e6cc364bac582"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ad6083eae3d18232f141e6cc364bac582">Error</a> { <br />
&#160;&#160;<b>No_Error</b>
, <b>Not_Initialized</b>
, <b>Invalid_Enum</b>
, <b>Invalid_Value</b>
, <br />
&#160;&#160;<b>Out_Of_Memory</b>
, <b>API_Unavailable</b>
, <b>Platform_Error</b>
, <b>Format_Unavailable</b>
, <br />
&#160;&#160;<b>Cursor_Unavailable</b>
, <b>Feature_Unavailable</b>
, <b>Feature_Unimplemented</b>
, <b>Platform_Unavailable</b>
<br />
 }</td></tr>
<tr class="memdesc:ad6083eae3d18232f141e6cc364bac582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ad6083eae3d18232f141e6cc364bac582">More...</a><br /></td></tr>
<tr class="separator:ad6083eae3d18232f141e6cc364bac582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9954c68c97c88cc331aaf4f0c411880f"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a9954c68c97c88cc331aaf4f0c411880f">Hint</a> { <br />
&#160;&#160;<b>Resizable</b>
, <b>Maximized</b>
, <b>Minimized</b>
, <b>Visible</b>
, <br />
&#160;&#160;<b>Focused</b>
, <b>FocusOnShow</b>
, <b>Hovered</b>
, <b>Decorated</b>
, <br />
&#160;&#160;<b>Floating</b>
, <b>MousePassthrough</b>
<br />
 }</td></tr>
<tr class="memdesc:a9954c68c97c88cc331aaf4f0c411880f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hints for window creation and runtime changes.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a9954c68c97c88cc331aaf4f0c411880f">More...</a><br /></td></tr>
<tr class="separator:a9954c68c97c88cc331aaf4f0c411880f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89bc89b63f0797c9d4622f4475883079"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a89bc89b63f0797c9d4622f4475883079">CursorMode</a> { <b>Normal</b>
, <b>Hidden</b>
, <b>Disabled</b>
, <b>Captured</b>
 }</td></tr>
<tr class="memdesc:a89bc89b63f0797c9d4622f4475883079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cursor modes that can be used.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a89bc89b63f0797c9d4622f4475883079">More...</a><br /></td></tr>
<tr class="separator:a89bc89b63f0797c9d4622f4475883079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f01f9f3026dcde129e7ce7d141c8bb"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#af3f01f9f3026dcde129e7ce7d141c8bb">CursorType</a> { <br />
&#160;&#160;<b>Arrow</b> = 0
, <b>Input</b> = 1
, <b>Crosshair</b> = 2
, <b>PointingHand</b> = 3
, <br />
&#160;&#160;<b>ResizeHorizontal</b> = 4
, <b>ResizeVertical</b> = 5
, <b>ResizeDiagonalTopLeftBottomRight</b> = 6
, <b>ResizeDiagonalTopRightBottomLeft</b> = 7
, <br />
&#160;&#160;<b>ResizeAll</b> = 8
, <b>NotAllowed</b> = 9
<br />
 }</td></tr>
<tr class="memdesc:af3f01f9f3026dcde129e7ce7d141c8bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cursor types that can be used.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#af3f01f9f3026dcde129e7ce7d141c8bb">More...</a><br /></td></tr>
<tr class="separator:af3f01f9f3026dcde129e7ce7d141c8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b606d91d8dbf66f02e935d2ce38eb3a"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a9b606d91d8dbf66f02e935d2ce38eb3a">ProgressState</a> { <br />
&#160;&#160;<b>NoProgress</b> = 0x00
, <b>Indeterminate</b> = 0x01
, <b>Normal</b> = 0x02
, <b>Error</b> = 0x04
, <br />
&#160;&#160;<b>Paused</b> = 0x08
<br />
 }</td></tr>
<tr class="memdesc:a9b606d91d8dbf66f02e935d2ce38eb3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">State of progress for a window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a9b606d91d8dbf66f02e935d2ce38eb3a">More...</a><br /></td></tr>
<tr class="separator:a9b606d91d8dbf66f02e935d2ce38eb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3e0a36774707778dc300a55f725d8f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a0e3e0a36774707778dc300a55f725d8f">WindowPositionFunc</a> = void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, int32_t xPos, int32_t yPos)</td></tr>
<tr class="memdesc:a0e3e0a36774707778dc300a55f725d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function pointer type for window position callbacks.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a0e3e0a36774707778dc300a55f725d8f">More...</a><br /></td></tr>
<tr class="separator:a0e3e0a36774707778dc300a55f725d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322ac85a2956a17244a7e0ea923bbad4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a322ac85a2956a17244a7e0ea923bbad4">WindowSizeFunc</a> = void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, int32_t width, int32_t height)</td></tr>
<tr class="memdesc:a322ac85a2956a17244a7e0ea923bbad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function pointer type for window size callbacks.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a322ac85a2956a17244a7e0ea923bbad4">More...</a><br /></td></tr>
<tr class="separator:a322ac85a2956a17244a7e0ea923bbad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4ad5b36e4a07e27a8a35f4b4d50e73"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a2f4ad5b36e4a07e27a8a35f4b4d50e73">WindowMinimizeFunc</a> = void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, bool restored)</td></tr>
<tr class="memdesc:a2f4ad5b36e4a07e27a8a35f4b4d50e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function pointer type for window minimize/iconfiy callbacks.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a2f4ad5b36e4a07e27a8a35f4b4d50e73">More...</a><br /></td></tr>
<tr class="separator:a2f4ad5b36e4a07e27a8a35f4b4d50e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533d75518c031574c4c4f7b7633bb18b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a533d75518c031574c4c4f7b7633bb18b">WindowMaximizeFunc</a> = void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, bool restored)</td></tr>
<tr class="memdesc:a533d75518c031574c4c4f7b7633bb18b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function pointer type for window maximize callbacks.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a533d75518c031574c4c4f7b7633bb18b">More...</a><br /></td></tr>
<tr class="separator:a533d75518c031574c4c4f7b7633bb18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ec03c4a779e92189a77d56edec88d9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ab7ec03c4a779e92189a77d56edec88d9">WindowCloseFunc</a> = void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window)</td></tr>
<tr class="memdesc:ab7ec03c4a779e92189a77d56edec88d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function pointer type for window close callbacks.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ab7ec03c4a779e92189a77d56edec88d9">More...</a><br /></td></tr>
<tr class="separator:ab7ec03c4a779e92189a77d56edec88d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3baebd09cdd0cf9241cef034268aa6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a9b3baebd09cdd0cf9241cef034268aa6">WindowFocusFunc</a> = void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, bool focused)</td></tr>
<tr class="memdesc:a9b3baebd09cdd0cf9241cef034268aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function pointer type for window focus callbacks.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a9b3baebd09cdd0cf9241cef034268aa6">More...</a><br /></td></tr>
<tr class="separator:a9b3baebd09cdd0cf9241cef034268aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f82bdf5c722c1697a40a01f0a71a363"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a1f82bdf5c722c1697a40a01f0a71a363">FrameBufferSizeFunc</a> = void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, int32_t width, int32_t height)</td></tr>
<tr class="memdesc:a1f82bdf5c722c1697a40a01f0a71a363"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function pointer type for framebuffer size callbacks.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a1f82bdf5c722c1697a40a01f0a71a363">More...</a><br /></td></tr>
<tr class="separator:a1f82bdf5c722c1697a40a01f0a71a363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2391c5c92468889bd96c727c7d128b7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ab2391c5c92468889bd96c727c7d128b7">WindowContentScaleFunc</a> = void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, float xScale, float yScale)</td></tr>
<tr class="memdesc:ab2391c5c92468889bd96c727c7d128b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function pointer type for window content scale callbacks.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ab2391c5c92468889bd96c727c7d128b7">More...</a><br /></td></tr>
<tr class="separator:ab2391c5c92468889bd96c727c7d128b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69561f5a3240dde706ce9896aaba946e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a69561f5a3240dde706ce9896aaba946e">MouseButtonFunc</a> = void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, <a class="el" href="class_t_r_a_p_1_1_input.html#aa03b41ad11d04dd89343ead74658b2c4">Input::MouseButton</a> mouseButton, bool pressed)</td></tr>
<tr class="memdesc:a69561f5a3240dde706ce9896aaba946e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function pointer type for mouse button callbacks.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a69561f5a3240dde706ce9896aaba946e">More...</a><br /></td></tr>
<tr class="separator:a69561f5a3240dde706ce9896aaba946e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd43357d32c8b5ec04ab8be2117d2d7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a7cd43357d32c8b5ec04ab8be2117d2d7">CursorPositionFunc</a> = void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, double xPos, double yPos)</td></tr>
<tr class="memdesc:a7cd43357d32c8b5ec04ab8be2117d2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function pointer type for cursor position callbacks.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a7cd43357d32c8b5ec04ab8be2117d2d7">More...</a><br /></td></tr>
<tr class="separator:a7cd43357d32c8b5ec04ab8be2117d2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744db66c26554a60557af235db7eb2fd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a744db66c26554a60557af235db7eb2fd">CursorEnterFunc</a> = void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, bool entered)</td></tr>
<tr class="memdesc:a744db66c26554a60557af235db7eb2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function pointer type for cursor enter callbacks.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a744db66c26554a60557af235db7eb2fd">More...</a><br /></td></tr>
<tr class="separator:a744db66c26554a60557af235db7eb2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5e6705d6868a3a5722ef8c77c71855"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#adb5e6705d6868a3a5722ef8c77c71855">ScrollFunc</a> = void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, double xOffset, double yOffset)</td></tr>
<tr class="memdesc:adb5e6705d6868a3a5722ef8c77c71855"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function pointer type for scroll callbacks.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#adb5e6705d6868a3a5722ef8c77c71855">More...</a><br /></td></tr>
<tr class="separator:adb5e6705d6868a3a5722ef8c77c71855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54944b816809b9367ef0023540d70bed"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a54944b816809b9367ef0023540d70bed">KeyFunc</a> = void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, <a class="el" href="class_t_r_a_p_1_1_input.html#ad374615c3007cee473d1e616af34a66c">Input::Key</a> key, bool pressed)</td></tr>
<tr class="memdesc:a54944b816809b9367ef0023540d70bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function pointer type for keyboard key callbacks.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a54944b816809b9367ef0023540d70bed">More...</a><br /></td></tr>
<tr class="separator:a54944b816809b9367ef0023540d70bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00eec701497894f9d1918de2598a3078"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a00eec701497894f9d1918de2598a3078">CharFunc</a> = void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, uint32_t codePoint)</td></tr>
<tr class="memdesc:a00eec701497894f9d1918de2598a3078"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function pointer type for Unicode character callbacks.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a00eec701497894f9d1918de2598a3078">More...</a><br /></td></tr>
<tr class="separator:a00eec701497894f9d1918de2598a3078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7d4ffac5bb5175661b6811fafc2130"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#aaf7d4ffac5bb5175661b6811fafc2130">DropFunc</a> = void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, std::vector&lt; std::string &gt; paths)</td></tr>
<tr class="memdesc:aaf7d4ffac5bb5175661b6811fafc2130"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function pointer type for path drop callbacks.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#aaf7d4ffac5bb5175661b6811fafc2130">More...</a><br /></td></tr>
<tr class="separator:aaf7d4ffac5bb5175661b6811fafc2130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1489018def8622680eb4cbbe7216ad18"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a1489018def8622680eb4cbbe7216ad18">MonitorFunc</a> = void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_monitor.html">InternalMonitor</a> *monitor, bool connected)</td></tr>
<tr class="memdesc:a1489018def8622680eb4cbbe7216ad18"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function pointer type for monitor configuration callbacks.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a1489018def8622680eb4cbbe7216ad18">More...</a><br /></td></tr>
<tr class="separator:a1489018def8622680eb4cbbe7216ad18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9b5016f364f033f1d4a7d0ee4e5d915f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a9b5016f364f033f1d4a7d0ee4e5d915f">WindowingAPI</a> ()=delete</td></tr>
<tr class="memdesc:a9b5016f364f033f1d4a7d0ee4e5d915f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a9b5016f364f033f1d4a7d0ee4e5d915f">More...</a><br /></td></tr>
<tr class="separator:a9b5016f364f033f1d4a7d0ee4e5d915f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f50658ffe0c63795413dffd6929de5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a88f50658ffe0c63795413dffd6929de5">~WindowingAPI</a> ()=default</td></tr>
<tr class="memdesc:a88f50658ffe0c63795413dffd6929de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a88f50658ffe0c63795413dffd6929de5">More...</a><br /></td></tr>
<tr class="separator:a88f50658ffe0c63795413dffd6929de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704507a61a446e4541f9e2abaedae836"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a704507a61a446e4541f9e2abaedae836">WindowingAPI</a> (const <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> &amp;)=delete</td></tr>
<tr class="memdesc:a704507a61a446e4541f9e2abaedae836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a704507a61a446e4541f9e2abaedae836">More...</a><br /></td></tr>
<tr class="separator:a704507a61a446e4541f9e2abaedae836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75bf6b4cd71671bb71fb155fbaeb182f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a75bf6b4cd71671bb71fb155fbaeb182f">operator=</a> (const <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> &amp;)=delete</td></tr>
<tr class="memdesc:a75bf6b4cd71671bb71fb155fbaeb182f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a75bf6b4cd71671bb71fb155fbaeb182f">More...</a><br /></td></tr>
<tr class="separator:a75bf6b4cd71671bb71fb155fbaeb182f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4bd6283544bd7e50a65c18305f0817"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a2e4bd6283544bd7e50a65c18305f0817">WindowingAPI</a> (<a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a2e4bd6283544bd7e50a65c18305f0817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a2e4bd6283544bd7e50a65c18305f0817">More...</a><br /></td></tr>
<tr class="separator:a2e4bd6283544bd7e50a65c18305f0817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73051244ab215644a463c14b1ae767d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a73051244ab215644a463c14b1ae767d9">operator=</a> (<a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a73051244ab215644a463c14b1ae767d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a73051244ab215644a463c14b1ae767d9">More...</a><br /></td></tr>
<tr class="separator:a73051244ab215644a463c14b1ae767d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abfe0c61f9e9210e6b2f3532ba9f59eda"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#abfe0c61f9e9210e6b2f3532ba9f59eda">Init</a> ()</td></tr>
<tr class="memdesc:abfe0c61f9e9210e6b2f3532ba9f59eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the windowing API. Before most <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> functions can be used, the <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> must be initialized, and before the engine terminates the <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> should be terminated in order to free any resources allocated during or after initialization.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#abfe0c61f9e9210e6b2f3532ba9f59eda">More...</a><br /></td></tr>
<tr class="separator:abfe0c61f9e9210e6b2f3532ba9f59eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02cae073fb368da7ad98217d56f61dd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ae02cae073fb368da7ad98217d56f61dd">Shutdown</a> ()</td></tr>
<tr class="memdesc:ae02cae073fb368da7ad98217d56f61dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function destroys all remaining windows and cursor, and frees any other allocated resources. Once this function is called, you must again call <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#abfe0c61f9e9210e6b2f3532ba9f59eda" title="Initializes the windowing API. Before most WindowingAPI functions can be used, the WindowingAPI must ...">WindowingAPI::Init</a> successfully before you will be able to use most <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> functions.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ae02cae073fb368da7ad98217d56f61dd">More...</a><br /></td></tr>
<tr class="separator:ae02cae073fb368da7ad98217d56f61dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e328cb210eb5f718ee2c00de6cfb3d9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a9e328cb210eb5f718ee2c00de6cfb3d9">DestroyWindow</a> (Scope&lt; <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> &gt; window)</td></tr>
<tr class="memdesc:a9e328cb210eb5f718ee2c00de6cfb3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function destroys the specified window. On calling this function, no further callbacks will be called for that window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a9e328cb210eb5f718ee2c00de6cfb3d9">More...</a><br /></td></tr>
<tr class="separator:a9e328cb210eb5f718ee2c00de6cfb3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07bcde6cdb37ecc49d697114fbdd2f1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ad07bcde6cdb37ecc49d697114fbdd2f1">DefaultWindowHints</a> ()</td></tr>
<tr class="memdesc:ad07bcde6cdb37ecc49d697114fbdd2f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets all window hints to their default values.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ad07bcde6cdb37ecc49d697114fbdd2f1">More...</a><br /></td></tr>
<tr class="separator:ad07bcde6cdb37ecc49d697114fbdd2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70fe8b8aff78b19f5a9513f34ef40d3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ac70fe8b8aff78b19f5a9513f34ef40d3">WindowHint</a> (<a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a9954c68c97c88cc331aaf4f0c411880f">Hint</a> hint, bool value)</td></tr>
<tr class="memdesc:ac70fe8b8aff78b19f5a9513f34ef40d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets hints for the next call to <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a2bc5abcc39d624e70235389d10e4ff08" title="This function creates a window. Most of the options controlling how the window should be created are ...">WindowingAPI::CreateWindow</a>. The hints, once set, retain their values until changed by a call to this function or <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ad07bcde6cdb37ecc49d697114fbdd2f1" title="Resets all window hints to their default values.">WindowingAPI::DefaultWindowHints</a>, or until the engine is terminated.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ac70fe8b8aff78b19f5a9513f34ef40d3">More...</a><br /></td></tr>
<tr class="separator:ac70fe8b8aff78b19f5a9513f34ef40d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695a286683584adf1d73ce56b946925d"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a695a286683584adf1d73ce56b946925d">GetMonitorName</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_monitor.html">InternalMonitor</a> *monitor)</td></tr>
<tr class="memdesc:a695a286683584adf1d73ce56b946925d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a human-readable name, encoded as UTF-8, of the specified monitor. The name typically reflects the make and model of the monitor and is not guaranteed to be unique among the connected monitors.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a695a286683584adf1d73ce56b946925d">More...</a><br /></td></tr>
<tr class="separator:a695a286683584adf1d73ce56b946925d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef2c9b10e956a64acd41ba30dfb122d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_monitor.html">InternalMonitor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a4ef2c9b10e956a64acd41ba30dfb122d">GetPrimaryMonitor</a> ()</td></tr>
<tr class="memdesc:a4ef2c9b10e956a64acd41ba30dfb122d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the primary monitor. This is usually the monitor where elements like the task bar or global menu bar are located.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a4ef2c9b10e956a64acd41ba30dfb122d">More...</a><br /></td></tr>
<tr class="separator:a4ef2c9b10e956a64acd41ba30dfb122d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd88bc671ed915ca43aac498683a87ae"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_monitor.html">InternalMonitor</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#afd88bc671ed915ca43aac498683a87ae">GetMonitors</a> ()</td></tr>
<tr class="memdesc:afd88bc671ed915ca43aac498683a87ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a vector of handles for all currently connceted monitors. The primary monitor is always first in the returned vector. If no monitors were found, this function returns an empty vector.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#afd88bc671ed915ca43aac498683a87ae">More...</a><br /></td></tr>
<tr class="separator:afd88bc671ed915ca43aac498683a87ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28b811b515a7a818313e010be7233e4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_video_mode.html">InternalVideoMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ad28b811b515a7a818313e010be7233e4">GetVideoMode</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_monitor.html">InternalMonitor</a> *monitor)</td></tr>
<tr class="memdesc:ad28b811b515a7a818313e010be7233e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current video mode of the specified monitor. If you have created a full screen window for that monitor, the return value will depend on whether that window is minimized/iconified.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ad28b811b515a7a818313e010be7233e4">More...</a><br /></td></tr>
<tr class="separator:ad28b811b515a7a818313e010be7233e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19711995c71805e3b88e7dedc8ea8922"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_video_mode.html">InternalVideoMode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a19711995c71805e3b88e7dedc8ea8922">GetVideoModes</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_monitor.html">InternalMonitor</a> *monitor)</td></tr>
<tr class="memdesc:a19711995c71805e3b88e7dedc8ea8922"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a vector of all video modes supported by the specified monitor. The returned vector is sorted in ascending order, first by color bit depth (the sum of all channel depths) and then by resolution area (the product of width and height).  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a19711995c71805e3b88e7dedc8ea8922">More...</a><br /></td></tr>
<tr class="separator:a19711995c71805e3b88e7dedc8ea8922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc5abcc39d624e70235389d10e4ff08"><td class="memItemLeft" align="right" valign="top">static Scope&lt; <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a2bc5abcc39d624e70235389d10e4ff08">CreateWindow</a> (uint32_t width, uint32_t height, const std::string &amp;title, <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_monitor.html">InternalMonitor</a> *monitor)</td></tr>
<tr class="memdesc:a2bc5abcc39d624e70235389d10e4ff08"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates a window. Most of the options controlling how the window should be created are specified with window hints.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a2bc5abcc39d624e70235389d10e4ff08">More...</a><br /></td></tr>
<tr class="separator:a2bc5abcc39d624e70235389d10e4ff08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4a1994d5b7c8702c8cd0875da86507"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a1f4a1994d5b7c8702c8cd0875da86507">SetWindowShouldClose</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, bool value)</td></tr>
<tr class="memdesc:a1f4a1994d5b7c8702c8cd0875da86507"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the value of the close flag of the specified window. This can be used to override the user's attempt to close the window, or to signal that it should be closed.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a1f4a1994d5b7c8702c8cd0875da86507">More...</a><br /></td></tr>
<tr class="separator:a1f4a1994d5b7c8702c8cd0875da86507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b562b134bc6b2e68e645b05e555ecd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a51b562b134bc6b2e68e645b05e555ecd">SetWindowTitle</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, std::string &amp;title)</td></tr>
<tr class="memdesc:a51b562b134bc6b2e68e645b05e555ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the window title, encoded as UTF-8, of the specified window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a51b562b134bc6b2e68e645b05e555ecd">More...</a><br /></td></tr>
<tr class="separator:a51b562b134bc6b2e68e645b05e555ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204be9d8d4cfea4aac5f715a14745b7f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a204be9d8d4cfea4aac5f715a14745b7f">GetMonitorContentScale</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_monitor.html">InternalMonitor</a> *monitor, float &amp;xScale, float &amp;yScale)</td></tr>
<tr class="memdesc:a204be9d8d4cfea4aac5f715a14745b7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function retrieves the content scale for the specified monitor. The content scale is the ratio between the current DPI and the platform's default DPI. This is especially important for text and any UI elements. If the pixel dimensions of your UI scaled by this look appropriate on your machine then it should appear at a reasonable size on other machines regardless of their DPI and scaling settings. This relies on the system DPI and scaling settings being somewhat correct.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a204be9d8d4cfea4aac5f715a14745b7f">More...</a><br /></td></tr>
<tr class="separator:a204be9d8d4cfea4aac5f715a14745b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b878058bd5492342e80c56258bef933"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a4b878058bd5492342e80c56258bef933">DestroyCursor</a> (Scope&lt; <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_cursor.html">InternalCursor</a> &gt; cursor)</td></tr>
<tr class="memdesc:a4b878058bd5492342e80c56258bef933"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function destroys a cursor previously created with CreateCursor. Any remaining cursors will be destroyed by <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ae02cae073fb368da7ad98217d56f61dd" title="This function destroys all remaining windows and cursor, and frees any other allocated resources....">WindowingAPI::Shutdown</a>.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a4b878058bd5492342e80c56258bef933">More...</a><br /></td></tr>
<tr class="separator:a4b878058bd5492342e80c56258bef933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082fdcf4188babcf598277dec238b98d"><td class="memItemLeft" align="right" valign="top">static Scope&lt; <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_cursor.html">InternalCursor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a082fdcf4188babcf598277dec238b98d">CreateCursor</a> (const <a class="el" href="class_t_r_a_p_1_1_image.html">Image</a> *const image, int32_t xHotspot, int32_t yHotspot)</td></tr>
<tr class="memdesc:a082fdcf4188babcf598277dec238b98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new custom cursor image that can be set for a window with SetCursor. The cursor can be destroyed with DestroyCursor. Any remaining cursors are destroyed by <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ae02cae073fb368da7ad98217d56f61dd" title="This function destroys all remaining windows and cursor, and frees any other allocated resources....">WindowingAPI::Shutdown</a>.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a082fdcf4188babcf598277dec238b98d">More...</a><br /></td></tr>
<tr class="separator:a082fdcf4188babcf598277dec238b98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e6ceb28edaafff926431867d5afda7"><td class="memItemLeft" align="right" valign="top">static Scope&lt; <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_cursor.html">InternalCursor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ad4e6ceb28edaafff926431867d5afda7">CreateStandardCursor</a> (const <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#af3f01f9f3026dcde129e7ce7d141c8bb">CursorType</a> &amp;type)</td></tr>
<tr class="memdesc:ad4e6ceb28edaafff926431867d5afda7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a cursor with a standard shape.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ad4e6ceb28edaafff926431867d5afda7">More...</a><br /></td></tr>
<tr class="separator:ad4e6ceb28edaafff926431867d5afda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e4e63eea748e5d0393d5f5b1b2661a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a67e4e63eea748e5d0393d5f5b1b2661a">SetCursor</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_cursor.html">InternalCursor</a> *cursor)</td></tr>
<tr class="memdesc:a67e4e63eea748e5d0393d5f5b1b2661a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the cursor image to be used when the cursor is over the content are of the specified window. The set cursor will only be visible when the CursorMode of the window is CursorMode::Normal.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a67e4e63eea748e5d0393d5f5b1b2661a">More...</a><br /></td></tr>
<tr class="separator:a67e4e63eea748e5d0393d5f5b1b2661a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1293d678be77c6cc842d72c099b10ac"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#aa1293d678be77c6cc842d72c099b10ac">SetWindowIcon</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, const <a class="el" href="class_t_r_a_p_1_1_image.html">Image</a> *const image)</td></tr>
<tr class="memdesc:aa1293d678be77c6cc842d72c099b10ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the icon of the specified window. If no image is specified, the window reverts to its default icon.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#aa1293d678be77c6cc842d72c099b10ac">More...</a><br /></td></tr>
<tr class="separator:aa1293d678be77c6cc842d72c099b10ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a477697a35069a59c31d19976921da0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a2a477697a35069a59c31d19976921da0">SetWindowPos</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, int32_t xPos, int32_t yPos)</td></tr>
<tr class="memdesc:a2a477697a35069a59c31d19976921da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the position, in screen coordinates, of the upper-left corner of the content area of the specifed windowed mode window. If the window is a full screen window, this function does nothing.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a2a477697a35069a59c31d19976921da0">More...</a><br /></td></tr>
<tr class="separator:a2a477697a35069a59c31d19976921da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0b01312944f515eab8a986d0904932"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#aac0b01312944f515eab8a986d0904932">GetWindowPos</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, int32_t &amp;xPos, int32_t &amp;yPos)</td></tr>
<tr class="memdesc:aac0b01312944f515eab8a986d0904932"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function retrieves the position, in screen coordinates, of the upper-left corner of the content area of the specified window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#aac0b01312944f515eab8a986d0904932">More...</a><br /></td></tr>
<tr class="separator:aac0b01312944f515eab8a986d0904932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3195c57fc4340a1319d0e3b0bd90e88c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a3195c57fc4340a1319d0e3b0bd90e88c">SetWindowSize</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, int32_t width, int32_t height)</td></tr>
<tr class="memdesc:a3195c57fc4340a1319d0e3b0bd90e88c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the size, in screen coordinates, of the content area of the specified window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a3195c57fc4340a1319d0e3b0bd90e88c">More...</a><br /></td></tr>
<tr class="separator:a3195c57fc4340a1319d0e3b0bd90e88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3dca63a6c4bd8c95e9471ecada392f0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#af3dca63a6c4bd8c95e9471ecada392f0">GetWindowSize</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, int32_t &amp;width, int32_t &amp;height)</td></tr>
<tr class="memdesc:af3dca63a6c4bd8c95e9471ecada392f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function retrieves the size, in screen coordinates, of the content area of the specified window. If you wish to retrieve the size of the framebuffer of the window in pixels, see <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a0311b5410343d39892b4cb707bc83494" title="This function retrieves the size, in pixels, of the framebuffer of the specified window....">WindowingAPI::GetFrameBufferSize</a>.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#af3dca63a6c4bd8c95e9471ecada392f0">More...</a><br /></td></tr>
<tr class="separator:af3dca63a6c4bd8c95e9471ecada392f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0311b5410343d39892b4cb707bc83494"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a0311b5410343d39892b4cb707bc83494">GetFrameBufferSize</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, int32_t &amp;width, int32_t &amp;height)</td></tr>
<tr class="memdesc:a0311b5410343d39892b4cb707bc83494"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function retrieves the size, in pixels, of the framebuffer of the specified window. If you wish to retrieve the size of the window in screen coordinates, see <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#af3dca63a6c4bd8c95e9471ecada392f0" title="This function retrieves the size, in screen coordinates, of the content area of the specified window....">WindowingAPI::GetWindowSize</a>.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a0311b5410343d39892b4cb707bc83494">More...</a><br /></td></tr>
<tr class="separator:a0311b5410343d39892b4cb707bc83494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2011a2e5904d06e83dbf685eb58310d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#af2011a2e5904d06e83dbf685eb58310d">SetWindowOpacity</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, float opacity)</td></tr>
<tr class="memdesc:af2011a2e5904d06e83dbf685eb58310d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the opacity of the window, including any decorations.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#af2011a2e5904d06e83dbf685eb58310d">More...</a><br /></td></tr>
<tr class="separator:af2011a2e5904d06e83dbf685eb58310d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17db9fbbc6f6651653179a089c97a1cf"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a17db9fbbc6f6651653179a089c97a1cf">GetWindowOpacity</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window)</td></tr>
<tr class="memdesc:a17db9fbbc6f6651653179a089c97a1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the opacity of the window, including any decorations.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a17db9fbbc6f6651653179a089c97a1cf">More...</a><br /></td></tr>
<tr class="separator:a17db9fbbc6f6651653179a089c97a1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8d34810903b689a1a19cdb7d26baa2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a6e8d34810903b689a1a19cdb7d26baa2">GetWindowContentScale</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, float &amp;xScale, float &amp;yScale)</td></tr>
<tr class="memdesc:a6e8d34810903b689a1a19cdb7d26baa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function retrieves the content scale for the specified window. The content scale is the reatio between the current DPI and the platform's default DPI. This is especially important for text and any UI elements. If the pixel dimensions of your UI scaled by this look appropriate on your machine then it should appear at a reasonable size on other machines regardless of their DPI and scaling settings. This relies on the system DPI and scaling settings being somewhat correct.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a6e8d34810903b689a1a19cdb7d26baa2">More...</a><br /></td></tr>
<tr class="separator:a6e8d34810903b689a1a19cdb7d26baa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef2e9bd606f13138ed28fd47de7a808"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a4ef2e9bd606f13138ed28fd47de7a808">SetWindowHint</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a9954c68c97c88cc331aaf4f0c411880f">Hint</a> hint, bool value)</td></tr>
<tr class="memdesc:a4ef2e9bd606f13138ed28fd47de7a808"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the value of a hint of the specified window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a4ef2e9bd606f13138ed28fd47de7a808">More...</a><br /></td></tr>
<tr class="separator:a4ef2e9bd606f13138ed28fd47de7a808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afe253638a8ba50307659637b98db24"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a7afe253638a8ba50307659637b98db24">GetWindowHint</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a9954c68c97c88cc331aaf4f0c411880f">Hint</a> hint)</td></tr>
<tr class="memdesc:a7afe253638a8ba50307659637b98db24"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the value of a hint of the specified window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a7afe253638a8ba50307659637b98db24">More...</a><br /></td></tr>
<tr class="separator:a7afe253638a8ba50307659637b98db24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f96e4cca3c0803d973323244c40947e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a0f96e4cca3c0803d973323244c40947e">SetWindowMonitor</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_monitor.html">InternalMonitor</a> *monitor, int32_t xPos, int32_t yPos, int32_t width, int32_t height, int32_t refreshRate)</td></tr>
<tr class="memdesc:a0f96e4cca3c0803d973323244c40947e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the monitor that the window uses for full screen mode or, if the monitor is nullptr, makes it windowed mode.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a0f96e4cca3c0803d973323244c40947e">More...</a><br /></td></tr>
<tr class="separator:a0f96e4cca3c0803d973323244c40947e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e22e8d9f9e75eeb7292e115a2a5434"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ae1e22e8d9f9e75eeb7292e115a2a5434">SetWindowMonitorBorderless</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_monitor.html">InternalMonitor</a> *monitor)</td></tr>
<tr class="memdesc:ae1e22e8d9f9e75eeb7292e115a2a5434"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the monitor that the window uses for borderless full screen mode.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ae1e22e8d9f9e75eeb7292e115a2a5434">More...</a><br /></td></tr>
<tr class="separator:ae1e22e8d9f9e75eeb7292e115a2a5434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe28ac371b241d255fac992d8f616f1b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#abe28ac371b241d255fac992d8f616f1b">SetWindowUserPointer</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, void *pointer)</td></tr>
<tr class="memdesc:abe28ac371b241d255fac992d8f616f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the user-define dpointer of the specified window. The current value is retained until the window is destroyed. The initial value is nullptr.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#abe28ac371b241d255fac992d8f616f1b">More...</a><br /></td></tr>
<tr class="separator:abe28ac371b241d255fac992d8f616f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afff9964b95834076934a1bf77d902a"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a2afff9964b95834076934a1bf77d902a">GetWindowUserPointer</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window)</td></tr>
<tr class="memdesc:a2afff9964b95834076934a1bf77d902a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current value of the user-defined pointer of the specified window. The initial value is nullptr.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a2afff9964b95834076934a1bf77d902a">More...</a><br /></td></tr>
<tr class="separator:a2afff9964b95834076934a1bf77d902a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c053e137362b8df0987153ce071bebc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a5c053e137362b8df0987153ce071bebc">SetMonitorCallback</a> (<a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a1489018def8622680eb4cbbe7216ad18">MonitorFunc</a> callback)</td></tr>
<tr class="memdesc:a5c053e137362b8df0987153ce071bebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the monitor configuration callback, or removes the currently set callback. This is called when a monitor is connected to or disconnected from the system.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a5c053e137362b8df0987153ce071bebc">More...</a><br /></td></tr>
<tr class="separator:a5c053e137362b8df0987153ce071bebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ccced281894c7ba9d6cf9f195caf89"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a74ccced281894c7ba9d6cf9f195caf89">SetWindowPosCallback</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a0e3e0a36774707778dc300a55f725d8f">WindowPositionFunc</a> callback)</td></tr>
<tr class="memdesc:a74ccced281894c7ba9d6cf9f195caf89"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the position callback of the specified window, which is called when the window is moved. The callback is provided with the position, in screen coordinates, of the upper-left corner of the content area of the window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a74ccced281894c7ba9d6cf9f195caf89">More...</a><br /></td></tr>
<tr class="separator:a74ccced281894c7ba9d6cf9f195caf89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792e42065f58e7ae9dd094f5a12cdb01"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a792e42065f58e7ae9dd094f5a12cdb01">SetWindowSizeCallback</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a322ac85a2956a17244a7e0ea923bbad4">WindowSizeFunc</a> callback)</td></tr>
<tr class="memdesc:a792e42065f58e7ae9dd094f5a12cdb01"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the size callback of the specified window, which is called when the window is resized. The callback is provided with the size, in screen coordinates, of the content area of the window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a792e42065f58e7ae9dd094f5a12cdb01">More...</a><br /></td></tr>
<tr class="separator:a792e42065f58e7ae9dd094f5a12cdb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9d27e023bf4713eead53b6677d8f04"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#aab9d27e023bf4713eead53b6677d8f04">SetWindowMinimizeCallback</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a2f4ad5b36e4a07e27a8a35f4b4d50e73">WindowMinimizeFunc</a> callback)</td></tr>
<tr class="memdesc:aab9d27e023bf4713eead53b6677d8f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the minimization/iconification callback of the specified window, which is called when the window is minimized/iconified or restored.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#aab9d27e023bf4713eead53b6677d8f04">More...</a><br /></td></tr>
<tr class="separator:aab9d27e023bf4713eead53b6677d8f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9755f61931f8d385836cf1012f086a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a1f9755f61931f8d385836cf1012f086a">SetWindowMaximizeCallback</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a533d75518c031574c4c4f7b7633bb18b">WindowMaximizeFunc</a> callback)</td></tr>
<tr class="memdesc:a1f9755f61931f8d385836cf1012f086a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the maximization callback of the specified window, which is called when the window is maximized or restored.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a1f9755f61931f8d385836cf1012f086a">More...</a><br /></td></tr>
<tr class="separator:a1f9755f61931f8d385836cf1012f086a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e006177ee64553fbbedf4eed692a48"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ac9e006177ee64553fbbedf4eed692a48">SetWindowCloseCallback</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ab7ec03c4a779e92189a77d56edec88d9">WindowCloseFunc</a> callback)</td></tr>
<tr class="memdesc:ac9e006177ee64553fbbedf4eed692a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the close callback of the specified window, which is called when the user attempts to close the window, for example by clicking the close widget in the title bar.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ac9e006177ee64553fbbedf4eed692a48">More...</a><br /></td></tr>
<tr class="separator:ac9e006177ee64553fbbedf4eed692a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90fb030142710dcb2742be1224827ef2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a90fb030142710dcb2742be1224827ef2">SetWindowFocusCallback</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a9b3baebd09cdd0cf9241cef034268aa6">WindowFocusFunc</a> callback)</td></tr>
<tr class="memdesc:a90fb030142710dcb2742be1224827ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the focus callback of the specified window, which is called when the window gains or loses input focus.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a90fb030142710dcb2742be1224827ef2">More...</a><br /></td></tr>
<tr class="separator:a90fb030142710dcb2742be1224827ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf36bb5e5531cfd900484392258e8563"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#abf36bb5e5531cfd900484392258e8563">SetFrameBufferSizeCallback</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a1f82bdf5c722c1697a40a01f0a71a363">FrameBufferSizeFunc</a> callback)</td></tr>
<tr class="memdesc:abf36bb5e5531cfd900484392258e8563"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the framebuffer resize callback of the specified window, which is called when the framebuffer of the specified window is resized.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#abf36bb5e5531cfd900484392258e8563">More...</a><br /></td></tr>
<tr class="separator:abf36bb5e5531cfd900484392258e8563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1403aa4df32303f1ddb61111a7817d18"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a1403aa4df32303f1ddb61111a7817d18">SetContentScaleCallback</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ab2391c5c92468889bd96c727c7d128b7">WindowContentScaleFunc</a> callback)</td></tr>
<tr class="memdesc:a1403aa4df32303f1ddb61111a7817d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the window content scale callback of the specified window, which is called when the content scale of the specified window changes.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a1403aa4df32303f1ddb61111a7817d18">More...</a><br /></td></tr>
<tr class="separator:a1403aa4df32303f1ddb61111a7817d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0292dceae4d119e23a5d7f57197fde"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#abd0292dceae4d119e23a5d7f57197fde">SetKeyCallback</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a54944b816809b9367ef0023540d70bed">KeyFunc</a> callback)</td></tr>
<tr class="memdesc:abd0292dceae4d119e23a5d7f57197fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the key callback of the specified window, which is called when a key is pressed, repeated or released.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#abd0292dceae4d119e23a5d7f57197fde">More...</a><br /></td></tr>
<tr class="separator:abd0292dceae4d119e23a5d7f57197fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae96d357e177939264f934ca1a661f30"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#aae96d357e177939264f934ca1a661f30">SetCharCallback</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a00eec701497894f9d1918de2598a3078">CharFunc</a> callback)</td></tr>
<tr class="memdesc:aae96d357e177939264f934ca1a661f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the character callback of the specified window, which is called when a Unicode character is input.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#aae96d357e177939264f934ca1a661f30">More...</a><br /></td></tr>
<tr class="separator:aae96d357e177939264f934ca1a661f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00981268810f1483f5f0a19e41b05fb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#af00981268810f1483f5f0a19e41b05fb">SetMouseButtonCallback</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a69561f5a3240dde706ce9896aaba946e">MouseButtonFunc</a> callback)</td></tr>
<tr class="memdesc:af00981268810f1483f5f0a19e41b05fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the mouse button callback of the specified window, which is called when amouse button is pressed or released.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#af00981268810f1483f5f0a19e41b05fb">More...</a><br /></td></tr>
<tr class="separator:af00981268810f1483f5f0a19e41b05fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1529285c62e8c39d4320ca56568bd72b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a1529285c62e8c39d4320ca56568bd72b">SetCursorPosCallback</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a7cd43357d32c8b5ec04ab8be2117d2d7">CursorPositionFunc</a> callback)</td></tr>
<tr class="memdesc:a1529285c62e8c39d4320ca56568bd72b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the cursor position callback of the specified window, which is called when the cursor is moved. The callback is provided with the position, in screen coordinates, relative to the upper-left corner of the content area of the window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a1529285c62e8c39d4320ca56568bd72b">More...</a><br /></td></tr>
<tr class="separator:a1529285c62e8c39d4320ca56568bd72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d51a891f8c73751b6c250da483acaf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a85d51a891f8c73751b6c250da483acaf">SetCursorEnterCallback</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a744db66c26554a60557af235db7eb2fd">CursorEnterFunc</a> callback)</td></tr>
<tr class="memdesc:a85d51a891f8c73751b6c250da483acaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the cursor boundary crossing callback of the specified window, which is called when the cursor enters or leaves the content area of the window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a85d51a891f8c73751b6c250da483acaf">More...</a><br /></td></tr>
<tr class="separator:a85d51a891f8c73751b6c250da483acaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66502ad6f23906b74e2ca3f32951055"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ab66502ad6f23906b74e2ca3f32951055">SetScrollCallback</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#adb5e6705d6868a3a5722ef8c77c71855">ScrollFunc</a> callback)</td></tr>
<tr class="memdesc:ab66502ad6f23906b74e2ca3f32951055"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the scroll callback of the specified window, which is called when a scrolling device is used, such as a mouse wheel or scrolling area of a touchpad.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ab66502ad6f23906b74e2ca3f32951055">More...</a><br /></td></tr>
<tr class="separator:ab66502ad6f23906b74e2ca3f32951055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c885437b0a8d37dd421e20eb49bf8b5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a9c885437b0a8d37dd421e20eb49bf8b5">SetDropCallback</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#aaf7d4ffac5bb5175661b6811fafc2130">DropFunc</a> callback)</td></tr>
<tr class="memdesc:a9c885437b0a8d37dd421e20eb49bf8b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the path drop callback of the specified window, which is called when one or more dragged paths are dropped on the window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a9c885437b0a8d37dd421e20eb49bf8b5">More...</a><br /></td></tr>
<tr class="separator:a9c885437b0a8d37dd421e20eb49bf8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98265bfcd9919ce2d4f1a523c4d5e4a4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a1489018def8622680eb4cbbe7216ad18">MonitorFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a98265bfcd9919ce2d4f1a523c4d5e4a4">GetMonitorCallback</a> ()</td></tr>
<tr class="memdesc:a98265bfcd9919ce2d4f1a523c4d5e4a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the monitor configuration callback.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a98265bfcd9919ce2d4f1a523c4d5e4a4">More...</a><br /></td></tr>
<tr class="separator:a98265bfcd9919ce2d4f1a523c4d5e4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d31a6230ad3fe7fe0a309fe43af8c9e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a0e3e0a36774707778dc300a55f725d8f">WindowPositionFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a1d31a6230ad3fe7fe0a309fe43af8c9e">GetWindowPosCallback</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window)</td></tr>
<tr class="memdesc:a1d31a6230ad3fe7fe0a309fe43af8c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the position callback for the specified window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a1d31a6230ad3fe7fe0a309fe43af8c9e">More...</a><br /></td></tr>
<tr class="separator:a1d31a6230ad3fe7fe0a309fe43af8c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e722f7ae64cf157f4abf110ba16ae0c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a322ac85a2956a17244a7e0ea923bbad4">WindowSizeFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a4e722f7ae64cf157f4abf110ba16ae0c">GetWindowSizeCallback</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window)</td></tr>
<tr class="memdesc:a4e722f7ae64cf157f4abf110ba16ae0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size callback for the specified window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a4e722f7ae64cf157f4abf110ba16ae0c">More...</a><br /></td></tr>
<tr class="separator:a4e722f7ae64cf157f4abf110ba16ae0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ab94d0facb586c7df61dab5305bc92"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ab7ec03c4a779e92189a77d56edec88d9">WindowCloseFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a55ab94d0facb586c7df61dab5305bc92">GetWindowCloseCallback</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window)</td></tr>
<tr class="memdesc:a55ab94d0facb586c7df61dab5305bc92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the close callback for the specified window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a55ab94d0facb586c7df61dab5305bc92">More...</a><br /></td></tr>
<tr class="separator:a55ab94d0facb586c7df61dab5305bc92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e399f87c5ecc0f9f5b34fef8906447"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a9b3baebd09cdd0cf9241cef034268aa6">WindowFocusFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a05e399f87c5ecc0f9f5b34fef8906447">GetWindowFocusCallback</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window)</td></tr>
<tr class="memdesc:a05e399f87c5ecc0f9f5b34fef8906447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the focus callback for the specified window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a05e399f87c5ecc0f9f5b34fef8906447">More...</a><br /></td></tr>
<tr class="separator:a05e399f87c5ecc0f9f5b34fef8906447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae566f8807b5ff468e445e418dd79912f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a1f82bdf5c722c1697a40a01f0a71a363">FrameBufferSizeFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ae566f8807b5ff468e445e418dd79912f">GetFrameBufferSizeCallback</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window)</td></tr>
<tr class="memdesc:ae566f8807b5ff468e445e418dd79912f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the framebuffer resize callback for the specified window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ae566f8807b5ff468e445e418dd79912f">More...</a><br /></td></tr>
<tr class="separator:ae566f8807b5ff468e445e418dd79912f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab923572ac20b872287015dd3605fd998"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ab2391c5c92468889bd96c727c7d128b7">WindowContentScaleFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ab923572ac20b872287015dd3605fd998">GetWindowContentScaleCallback</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window)</td></tr>
<tr class="memdesc:ab923572ac20b872287015dd3605fd998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the window content scale callback for the specified window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ab923572ac20b872287015dd3605fd998">More...</a><br /></td></tr>
<tr class="separator:ab923572ac20b872287015dd3605fd998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1af542837bef9bc18f3beeaed10815"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a54944b816809b9367ef0023540d70bed">KeyFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a2a1af542837bef9bc18f3beeaed10815">GetKeyCallback</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window)</td></tr>
<tr class="memdesc:a2a1af542837bef9bc18f3beeaed10815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the key callback for the specified window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a2a1af542837bef9bc18f3beeaed10815">More...</a><br /></td></tr>
<tr class="separator:a2a1af542837bef9bc18f3beeaed10815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717541326849d35a09230b5f43c39237"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a00eec701497894f9d1918de2598a3078">CharFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a717541326849d35a09230b5f43c39237">GetCharCallback</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window)</td></tr>
<tr class="memdesc:a717541326849d35a09230b5f43c39237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Unicode character callback for the specified window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a717541326849d35a09230b5f43c39237">More...</a><br /></td></tr>
<tr class="separator:a717541326849d35a09230b5f43c39237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac524a16c78e366512959fb9e7fc288b7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a69561f5a3240dde706ce9896aaba946e">MouseButtonFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ac524a16c78e366512959fb9e7fc288b7">GetMouseButtonCallback</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window)</td></tr>
<tr class="memdesc:ac524a16c78e366512959fb9e7fc288b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the mouse button callback for the specified window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ac524a16c78e366512959fb9e7fc288b7">More...</a><br /></td></tr>
<tr class="separator:ac524a16c78e366512959fb9e7fc288b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae75cd868b0f0ae370fc4771c29bc0a0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a7cd43357d32c8b5ec04ab8be2117d2d7">CursorPositionFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#aae75cd868b0f0ae370fc4771c29bc0a0">GetCursorPosCallback</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window)</td></tr>
<tr class="memdesc:aae75cd868b0f0ae370fc4771c29bc0a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the cursor position callback for the specified window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#aae75cd868b0f0ae370fc4771c29bc0a0">More...</a><br /></td></tr>
<tr class="separator:aae75cd868b0f0ae370fc4771c29bc0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5675ccee3f25378c4c1fb036f3f7fa04"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a744db66c26554a60557af235db7eb2fd">CursorEnterFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a5675ccee3f25378c4c1fb036f3f7fa04">GetCursorEnterCallback</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window)</td></tr>
<tr class="memdesc:a5675ccee3f25378c4c1fb036f3f7fa04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the cursor enter callback for the specified window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a5675ccee3f25378c4c1fb036f3f7fa04">More...</a><br /></td></tr>
<tr class="separator:a5675ccee3f25378c4c1fb036f3f7fa04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cfb301e3440ead4726d398d555c0f96"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#adb5e6705d6868a3a5722ef8c77c71855">ScrollFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a5cfb301e3440ead4726d398d555c0f96">GetScrollCallback</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window)</td></tr>
<tr class="memdesc:a5cfb301e3440ead4726d398d555c0f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the scroll callback for the specified window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a5cfb301e3440ead4726d398d555c0f96">More...</a><br /></td></tr>
<tr class="separator:a5cfb301e3440ead4726d398d555c0f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0789aa2ad19268c439fa76801228cfe"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#aaf7d4ffac5bb5175661b6811fafc2130">DropFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ae0789aa2ad19268c439fa76801228cfe">GetDropCallback</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window)</td></tr>
<tr class="memdesc:ae0789aa2ad19268c439fa76801228cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the path drop callback for the specified window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ae0789aa2ad19268c439fa76801228cfe">More...</a><br /></td></tr>
<tr class="separator:ae0789aa2ad19268c439fa76801228cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaadc3ee48e4e45a1fd83551533545fe9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#aaadc3ee48e4e45a1fd83551533545fe9">PollEvents</a> ()</td></tr>
<tr class="memdesc:aaadc3ee48e4e45a1fd83551533545fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function processes only those events that are already in the event queue and then returns immediately. Processing events will cause the window and input callbacks associated with those events to be called.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#aaadc3ee48e4e45a1fd83551533545fe9">More...</a><br /></td></tr>
<tr class="separator:aaadc3ee48e4e45a1fd83551533545fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ae5efb628a500a262d9c4c2518a52f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a66ae5efb628a500a262d9c4c2518a52f">SetCursorMode</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a89bc89b63f0797c9d4622f4475883079">CursorMode</a> mode)</td></tr>
<tr class="memdesc:a66ae5efb628a500a262d9c4c2518a52f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets a cursor mode for the specified window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a66ae5efb628a500a262d9c4c2518a52f">More...</a><br /></td></tr>
<tr class="separator:a66ae5efb628a500a262d9c4c2518a52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfd8b46be1ac58a40743ee73b8f7360"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a89bc89b63f0797c9d4622f4475883079">CursorMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a0dfd8b46be1ac58a40743ee73b8f7360">GetCursorMode</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window)</td></tr>
<tr class="memdesc:a0dfd8b46be1ac58a40743ee73b8f7360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the cursor mode from the specified window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a0dfd8b46be1ac58a40743ee73b8f7360">More...</a><br /></td></tr>
<tr class="separator:a0dfd8b46be1ac58a40743ee73b8f7360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21dd68a6d59e81760076dab3213c35c6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a21dd68a6d59e81760076dab3213c35c6">RawMouseMotionSupported</a> ()</td></tr>
<tr class="memdesc:a21dd68a6d59e81760076dab3213c35c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns whether raw mouse motion is supported on the current system. This status does not change after the <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> has been initialized so you only need to check this once. If you attemp to enable raw motion on a system that does not support it, Error::Platform_Error will be emitted.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a21dd68a6d59e81760076dab3213c35c6">More...</a><br /></td></tr>
<tr class="separator:a21dd68a6d59e81760076dab3213c35c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa040d5362b45826d7810d1509016e902"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#aa040d5362b45826d7810d1509016e902">SetRawMouseMotionMode</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, bool enabled)</td></tr>
<tr class="memdesc:aa040d5362b45826d7810d1509016e902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the raw mouse motion mode for the specified window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#aa040d5362b45826d7810d1509016e902">More...</a><br /></td></tr>
<tr class="separator:aa040d5362b45826d7810d1509016e902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdeb0f0f0b6c87ff1356a1dc354b2cf"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a6bdeb0f0f0b6c87ff1356a1dc354b2cf">GetRawMouseMotionMode</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window)</td></tr>
<tr class="memdesc:a6bdeb0f0f0b6c87ff1356a1dc354b2cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the raw mouse motion mode for the specified window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a6bdeb0f0f0b6c87ff1356a1dc354b2cf">More...</a><br /></td></tr>
<tr class="separator:a6bdeb0f0f0b6c87ff1356a1dc354b2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f896f0a198d2727541c365c82d9727e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a4f896f0a198d2727541c365c82d9727e">SetProgress</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a9b606d91d8dbf66f02e935d2ce38eb3a">ProgressState</a> state, uint32_t progress)</td></tr>
<tr class="memdesc:a4f896f0a198d2727541c365c82d9727e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the progress value and state on the taskbar for the specified window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a4f896f0a198d2727541c365c82d9727e">More...</a><br /></td></tr>
<tr class="separator:a4f896f0a198d2727541c365c82d9727e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e80d336ab15245ef0dcfd74715debbc"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a7e80d336ab15245ef0dcfd74715debbc">GetKeyName</a> (<a class="el" href="class_t_r_a_p_1_1_input.html#ad374615c3007cee473d1e616af34a66c">Input::Key</a> key, int32_t scanCode)</td></tr>
<tr class="memdesc:a7e80d336ab15245ef0dcfd74715debbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the name of the specified printable key, encoded as UTF-8. This is typically the character that key would produce without any modifier keys, intended for displaying key bindings to the user. For dead keys, it is typically the diacritic it would add to a character.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a7e80d336ab15245ef0dcfd74715debbc">More...</a><br /></td></tr>
<tr class="separator:a7e80d336ab15245ef0dcfd74715debbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3addef42b7cce04b5251a705dc5bdf16"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a3addef42b7cce04b5251a705dc5bdf16">GetKey</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, <a class="el" href="class_t_r_a_p_1_1_input.html#ad374615c3007cee473d1e616af34a66c">Input::Key</a> key)</td></tr>
<tr class="memdesc:a3addef42b7cce04b5251a705dc5bdf16"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the last state reported for the specified key to the specified window. The returned state is pressed (true) or released (false).  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a3addef42b7cce04b5251a705dc5bdf16">More...</a><br /></td></tr>
<tr class="separator:a3addef42b7cce04b5251a705dc5bdf16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8646f034224a2a58a5121be4abb77b2a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a8646f034224a2a58a5121be4abb77b2a">GetMouseButton</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, <a class="el" href="class_t_r_a_p_1_1_input.html#aa03b41ad11d04dd89343ead74658b2c4">Input::MouseButton</a> button)</td></tr>
<tr class="memdesc:a8646f034224a2a58a5121be4abb77b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the last state reported for the specified mouse button to the specified window. The returned state is pressed (true) or released (false).  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a8646f034224a2a58a5121be4abb77b2a">More...</a><br /></td></tr>
<tr class="separator:a8646f034224a2a58a5121be4abb77b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4edbf7a05873e0f0138d812c5348d123"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a4edbf7a05873e0f0138d812c5348d123">SetCursorPos</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, double xPos, double yPos)</td></tr>
<tr class="memdesc:a4edbf7a05873e0f0138d812c5348d123"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the position, in screen coordinates, of the cursor relative to the upper-left corner of the content area of the specified window. The window must have input focus. If the window does not have input focus when this function is called, it fails silently.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a4edbf7a05873e0f0138d812c5348d123">More...</a><br /></td></tr>
<tr class="separator:a4edbf7a05873e0f0138d812c5348d123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883e554b529ac2be71c731a0e1dc8ac6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a883e554b529ac2be71c731a0e1dc8ac6">GetCursorPos</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, double &amp;xPos, double &amp;yPos)</td></tr>
<tr class="memdesc:a883e554b529ac2be71c731a0e1dc8ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the position of the cursor, in screen coordinates, relative to the upper-left corner of the content area of the specified window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a883e554b529ac2be71c731a0e1dc8ac6">More...</a><br /></td></tr>
<tr class="separator:a883e554b529ac2be71c731a0e1dc8ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b881a8d544e08e2e6f23a6204dd5c5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a66b881a8d544e08e2e6f23a6204dd5c5">GetMonitorPos</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_monitor.html">InternalMonitor</a> *monitor, int32_t &amp;xPos, int32_t &amp;yPos)</td></tr>
<tr class="memdesc:a66b881a8d544e08e2e6f23a6204dd5c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the monitor's viewport on the virtual screen. This function returns the position, in screen coordinates, of the upper-left corner of the specified monitor.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a66b881a8d544e08e2e6f23a6204dd5c5">More...</a><br /></td></tr>
<tr class="separator:a66b881a8d544e08e2e6f23a6204dd5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc683c5e5c0849f9a86e2c5e9fd33066"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#afc683c5e5c0849f9a86e2c5e9fd33066">GetMonitorWorkArea</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_monitor.html">InternalMonitor</a> *monitor, int32_t &amp;xPos, int32_t &amp;yPos, int32_t &amp;width, int32_t &amp;height)</td></tr>
<tr class="memdesc:afc683c5e5c0849f9a86e2c5e9fd33066"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the position, in screen coordinates, of the upper-left corner of the work area of the specified monitor along with the work area size in screen coordinates. The work area is defined as the area of the monitor not occluded by the operating system task bar where present. If no task bar exists then the work area is the monitor resolution in screen coordinates.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#afc683c5e5c0849f9a86e2c5e9fd33066">More...</a><br /></td></tr>
<tr class="separator:afc683c5e5c0849f9a86e2c5e9fd33066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620187132ad11295feed29d8aa2d617e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a620187132ad11295feed29d8aa2d617e">ShowWindow</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window)</td></tr>
<tr class="memdesc:a620187132ad11295feed29d8aa2d617e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function makes the specified window visible if it was previously hidden. If the window is already visible or is in full screen mode, this function does nothing.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a620187132ad11295feed29d8aa2d617e">More...</a><br /></td></tr>
<tr class="separator:a620187132ad11295feed29d8aa2d617e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75787e2921cbec187646978eaa433aa0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a75787e2921cbec187646978eaa433aa0">FocusWindow</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window)</td></tr>
<tr class="memdesc:a75787e2921cbec187646978eaa433aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function brings the specified window to front and sets input focus. The window should already be visible and not minimized/iconified.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a75787e2921cbec187646978eaa433aa0">More...</a><br /></td></tr>
<tr class="separator:a75787e2921cbec187646978eaa433aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe5a7e41eeeaa55d224a136e8f23b5b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a5fe5a7e41eeeaa55d224a136e8f23b5b">MaximizeWindow</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window)</td></tr>
<tr class="memdesc:a5fe5a7e41eeeaa55d224a136e8f23b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function maximizes the specified window if it was previously not maximized. If the window is already maximized, this function does nothing.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a5fe5a7e41eeeaa55d224a136e8f23b5b">More...</a><br /></td></tr>
<tr class="separator:a5fe5a7e41eeeaa55d224a136e8f23b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477bfb62df7c0e56a2003579aa2b2148"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a477bfb62df7c0e56a2003579aa2b2148">MinimizeWindow</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window)</td></tr>
<tr class="memdesc:a477bfb62df7c0e56a2003579aa2b2148"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function minimizes (iconifies) the specified window if it was previously restored. If the window is already minimized (iconified), this function does nothing.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a477bfb62df7c0e56a2003579aa2b2148">More...</a><br /></td></tr>
<tr class="separator:a477bfb62df7c0e56a2003579aa2b2148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78d96deda94785874f5e6a5652e333c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ab78d96deda94785874f5e6a5652e333c">RequestWindowAttention</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window)</td></tr>
<tr class="memdesc:ab78d96deda94785874f5e6a5652e333c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function requests user attention to the specified window. On platforms where this is not supported, attention is requested to the application as a whole.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ab78d96deda94785874f5e6a5652e333c">More...</a><br /></td></tr>
<tr class="separator:ab78d96deda94785874f5e6a5652e333c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd237cfbb2c0fb060ef706c3d090ebc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a5cd237cfbb2c0fb060ef706c3d090ebc">HideWindow</a> (const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window)</td></tr>
<tr class="memdesc:a5cd237cfbb2c0fb060ef706c3d090ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function hides the specified window if it was previously visible. If the window is already hidden or is in full screen mode, this function does nothing.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a5cd237cfbb2c0fb060ef706c3d090ebc">More...</a><br /></td></tr>
<tr class="separator:a5cd237cfbb2c0fb060ef706c3d090ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff6f065d301032c88cd72c3575f1c61"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#acff6f065d301032c88cd72c3575f1c61">RestoreWindow</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window)</td></tr>
<tr class="memdesc:acff6f065d301032c88cd72c3575f1c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores the specified window. This function restores the specified window if it was previously minimized (iconified) or maximized. If the window is already restored, this function does nothing.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#acff6f065d301032c88cd72c3575f1c61">More...</a><br /></td></tr>
<tr class="separator:acff6f065d301032c88cd72c3575f1c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26609f5ffd299da72d0855cd1c7ea2e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#af26609f5ffd299da72d0855cd1c7ea2e">SetWindowSizeLimits</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, int32_t minWidth, int32_t minHeight, int32_t maxWidth, int32_t maxHeight)</td></tr>
<tr class="memdesc:af26609f5ffd299da72d0855cd1c7ea2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size limits of the specified window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#af26609f5ffd299da72d0855cd1c7ea2e">More...</a><br /></td></tr>
<tr class="separator:af26609f5ffd299da72d0855cd1c7ea2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655aceac8d334839924e95d77dfc7652"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a655aceac8d334839924e95d77dfc7652">SetClipboardString</a> (const std::string &amp;string)</td></tr>
<tr class="memdesc:a655aceac8d334839924e95d77dfc7652"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the system clipboard to the specified, UTF-8 encoded string.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a655aceac8d334839924e95d77dfc7652">More...</a><br /></td></tr>
<tr class="separator:a655aceac8d334839924e95d77dfc7652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62669f2a8075dcd5c165c11fd28c6653"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a62669f2a8075dcd5c165c11fd28c6653">GetClipboardString</a> ()</td></tr>
<tr class="memdesc:a62669f2a8075dcd5c165c11fd28c6653"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the contents of the system clipboard, if it contains or is convertible to a UTF-8 encoded string. If the clipboard is empty or if its content cannot be converted, an empty string is returned and a Error::Format_Unavailable error is generated.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a62669f2a8075dcd5c165c11fd28c6653">More...</a><br /></td></tr>
<tr class="separator:a62669f2a8075dcd5c165c11fd28c6653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a62ae75f1affade038ed963c4920282"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a4a62ae75f1affade038ed963c4920282">VulkanSupported</a> ()</td></tr>
<tr class="memdesc:a4a62ae75f1affade038ed963c4920282"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns whether the Vulkan loader and any minimally function ICD have been found.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a4a62ae75f1affade038ed963c4920282">More...</a><br /></td></tr>
<tr class="separator:a4a62ae75f1affade038ed963c4920282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5bb8bb58769001b7a68b2905b4b2ec"><td class="memItemLeft" align="right" valign="top">static std::array&lt; std::string, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a6c5bb8bb58769001b7a68b2905b4b2ec">GetRequiredInstanceExtensions</a> ()</td></tr>
<tr class="memdesc:a6c5bb8bb58769001b7a68b2905b4b2ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns an array of names of Vulkan instance extensions required by the <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> for creating Vulkan surface for <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> windows. If successful, the list will always contain VK_KHR_surface, so if you don't require any additional extensions you can pass this list directly to the VkInstanceCreateInfo struct.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a6c5bb8bb58769001b7a68b2905b4b2ec">More...</a><br /></td></tr>
<tr class="separator:a6c5bb8bb58769001b7a68b2905b4b2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e5e049ccd06c2cac987979050d56a5"><td class="memItemLeft" align="right" valign="top">static VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a08e5e049ccd06c2cac987979050d56a5">CreateWindowSurface</a> (VkInstance instance, const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, const VkAllocationCallbacks *allocator, VkSurfaceKHR &amp;surface)</td></tr>
<tr class="memdesc:a08e5e049ccd06c2cac987979050d56a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Vulkan surface for the specified window. This function create a Vulkan surface for the specified window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a08e5e049ccd06c2cac987979050d56a5">More...</a><br /></td></tr>
<tr class="separator:a08e5e049ccd06c2cac987979050d56a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d1e8dc77c47700b2fc329956a52d66"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a96d1e8dc77c47700b2fc329956a52d66">HideWindowFromTaskbar</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window)</td></tr>
<tr class="memdesc:a96d1e8dc77c47700b2fc329956a52d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hides the specified window from the taskbar.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a96d1e8dc77c47700b2fc329956a52d66">More...</a><br /></td></tr>
<tr class="separator:a96d1e8dc77c47700b2fc329956a52d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fa5c6d2c1ed51704c47293bb61f410"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a83fa5c6d2c1ed51704c47293bb61f410">SetDragAndDrop</a> (<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *window, bool value)</td></tr>
<tr class="memdesc:a83fa5c6d2c1ed51704c47293bb61f410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/Disable drag and drop feature for the specified window.  <a href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a83fa5c6d2c1ed51704c47293bb61f410">More...</a><br /></td></tr>
<tr class="separator:a83fa5c6d2c1ed51704c47293bb61f410"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="_windowing_a_p_i_8h_source.html#l00037">37</a> of file <a class="el" href="_windowing_a_p_i_8h_source.html">WindowingAPI.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a00eec701497894f9d1918de2598a3078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00eec701497894f9d1918de2598a3078">&#9670;&nbsp;</a></span>CharFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a00eec701497894f9d1918de2598a3078">TRAP::INTERNAL::WindowingAPI::CharFunc</a> =  void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a>* window, uint32_t codePoint)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function pointer type for Unicode character callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>The window that received the event.</td></tr>
    <tr><td class="paramname">codePoint</td><td>The Unicode code point of the character.</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_windowing_a_p_i_8h_source.html#l00194">194</a> of file <a class="el" href="_windowing_a_p_i_8h_source.html">WindowingAPI.h</a>.</p>

</div>
</div>
<a id="a744db66c26554a60557af235db7eb2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744db66c26554a60557af235db7eb2fd">&#9670;&nbsp;</a></span>CursorEnterFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a744db66c26554a60557af235db7eb2fd">TRAP::INTERNAL::WindowingAPI::CursorEnterFunc</a> =  void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a>* window, bool entered)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function pointer type for cursor enter callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>The window that received the event.</td></tr>
    <tr><td class="paramname">entered</td><td>True if the cursor entered the window's content area, false if it left it.</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_windowing_a_p_i_8h_source.html#l00174">174</a> of file <a class="el" href="_windowing_a_p_i_8h_source.html">WindowingAPI.h</a>.</p>

</div>
</div>
<a id="a7cd43357d32c8b5ec04ab8be2117d2d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd43357d32c8b5ec04ab8be2117d2d7">&#9670;&nbsp;</a></span>CursorPositionFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a7cd43357d32c8b5ec04ab8be2117d2d7">TRAP::INTERNAL::WindowingAPI::CursorPositionFunc</a> =  void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a>* window, double xPos, double yPos)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function pointer type for cursor position callbacks. </p>
<p>&lt;param name="window&gt;The window that received the event.&lt;/param&gt;
&lt;param name="xPos"&gt;The new cursor x-coordinate, relative to the left edge of the content area.&lt;/param&gt;
&lt;param name="yPos"&gt;The new cursor y-coordinate, relative to the top edge of the content area.</p>

<p class="definition">Definition at line <a class="el" href="_windowing_a_p_i_8h_source.html#l00168">168</a> of file <a class="el" href="_windowing_a_p_i_8h_source.html">WindowingAPI.h</a>.</p>

</div>
</div>
<a id="aaf7d4ffac5bb5175661b6811fafc2130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7d4ffac5bb5175661b6811fafc2130">&#9670;&nbsp;</a></span>DropFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#aaf7d4ffac5bb5175661b6811fafc2130">TRAP::INTERNAL::WindowingAPI::DropFunc</a> =  void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a>* window, std::vector&lt;std::string&gt; paths)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function pointer type for path drop callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>The window that received the event.</td></tr>
    <tr><td class="paramname">paths</td><td>The UTF-8 encoded file and/or directory path names.</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_windowing_a_p_i_8h_source.html#l00200">200</a> of file <a class="el" href="_windowing_a_p_i_8h_source.html">WindowingAPI.h</a>.</p>

</div>
</div>
<a id="a1f82bdf5c722c1697a40a01f0a71a363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f82bdf5c722c1697a40a01f0a71a363">&#9670;&nbsp;</a></span>FrameBufferSizeFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a1f82bdf5c722c1697a40a01f0a71a363">TRAP::INTERNAL::WindowingAPI::FrameBufferSizeFunc</a> =  void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a>* window, int32_t width, int32_t height)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function pointer type for framebuffer size callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>The window whose framebuffer was resized.</td></tr>
    <tr><td class="paramname">width</td><td>The new width, in pixels, of the framebuffer.</td></tr>
    <tr><td class="paramname">height</td><td>The new height, in pixels, of the framebuffer.</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_windowing_a_p_i_8h_source.html#l00147">147</a> of file <a class="el" href="_windowing_a_p_i_8h_source.html">WindowingAPI.h</a>.</p>

</div>
</div>
<a id="a54944b816809b9367ef0023540d70bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54944b816809b9367ef0023540d70bed">&#9670;&nbsp;</a></span>KeyFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a54944b816809b9367ef0023540d70bed">TRAP::INTERNAL::WindowingAPI::KeyFunc</a> =  void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a>* window, <a class="el" href="class_t_r_a_p_1_1_input.html#ad374615c3007cee473d1e616af34a66c">Input::Key</a> key, bool pressed)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function pointer type for keyboard key callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>The window that received the event.</td></tr>
    <tr><td class="paramname">key</td><td>The key that was pressed or released.</td></tr>
    <tr><td class="paramname">pressed</td><td>True if key is pressed, false if it is released.</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_windowing_a_p_i_8h_source.html#l00188">188</a> of file <a class="el" href="_windowing_a_p_i_8h_source.html">WindowingAPI.h</a>.</p>

</div>
</div>
<a id="a1489018def8622680eb4cbbe7216ad18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1489018def8622680eb4cbbe7216ad18">&#9670;&nbsp;</a></span>MonitorFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a1489018def8622680eb4cbbe7216ad18">TRAP::INTERNAL::WindowingAPI::MonitorFunc</a> =  void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_monitor.html">InternalMonitor</a>* monitor, bool connected)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function pointer type for monitor configuration callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">monitor</td><td>The monitor that was connected or disconnected.</td></tr>
    <tr><td class="paramname">connceted</td><td>True if monitor got connceted or false if it got disconnceted.</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_windowing_a_p_i_8h_source.html#l00206">206</a> of file <a class="el" href="_windowing_a_p_i_8h_source.html">WindowingAPI.h</a>.</p>

</div>
</div>
<a id="a69561f5a3240dde706ce9896aaba946e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69561f5a3240dde706ce9896aaba946e">&#9670;&nbsp;</a></span>MouseButtonFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a69561f5a3240dde706ce9896aaba946e">TRAP::INTERNAL::WindowingAPI::MouseButtonFunc</a> =  void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a>* window, <a class="el" href="class_t_r_a_p_1_1_input.html#aa03b41ad11d04dd89343ead74658b2c4">Input::MouseButton</a> mouseButton, bool pressed)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function pointer type for mouse button callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>The window that received the event.</td></tr>
    <tr><td class="paramname">mouseButton</td><td>The mouse button that was pressed or released.</td></tr>
    <tr><td class="paramname">pressed</td><td>True if mouse button is pressed, false otherwise.</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_windowing_a_p_i_8h_source.html#l00161">161</a> of file <a class="el" href="_windowing_a_p_i_8h_source.html">WindowingAPI.h</a>.</p>

</div>
</div>
<a id="adb5e6705d6868a3a5722ef8c77c71855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb5e6705d6868a3a5722ef8c77c71855">&#9670;&nbsp;</a></span>ScrollFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#adb5e6705d6868a3a5722ef8c77c71855">TRAP::INTERNAL::WindowingAPI::ScrollFunc</a> =  void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a>* window, double xOffset, double yOffset)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function pointer type for scroll callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>The window that received the event.</td></tr>
    <tr><td class="paramname">xOffset</td><td>The scroll offset along the x-axis.</td></tr>
    <tr><td class="paramname">yOffset</td><td>The scroll offset along the y-axis.</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_windowing_a_p_i_8h_source.html#l00181">181</a> of file <a class="el" href="_windowing_a_p_i_8h_source.html">WindowingAPI.h</a>.</p>

</div>
</div>
<a id="ab7ec03c4a779e92189a77d56edec88d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ec03c4a779e92189a77d56edec88d9">&#9670;&nbsp;</a></span>WindowCloseFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ab7ec03c4a779e92189a77d56edec88d9">TRAP::INTERNAL::WindowingAPI::WindowCloseFunc</a> =  void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a>* window)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function pointer type for window close callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>The window that the user attempted to close.</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_windowing_a_p_i_8h_source.html#l00134">134</a> of file <a class="el" href="_windowing_a_p_i_8h_source.html">WindowingAPI.h</a>.</p>

</div>
</div>
<a id="ab2391c5c92468889bd96c727c7d128b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2391c5c92468889bd96c727c7d128b7">&#9670;&nbsp;</a></span>WindowContentScaleFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ab2391c5c92468889bd96c727c7d128b7">TRAP::INTERNAL::WindowingAPI::WindowContentScaleFunc</a> =  void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a>* window, float xScale, float yScale)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function pointer type for window content scale callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>The window whose content scale changed.</td></tr>
    <tr><td class="paramname">xScale</td><td>The new x-axis content scale of the window.</td></tr>
    <tr><td class="paramname">yScale</td><td>The new y-axis content scale of the window.</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_windowing_a_p_i_8h_source.html#l00154">154</a> of file <a class="el" href="_windowing_a_p_i_8h_source.html">WindowingAPI.h</a>.</p>

</div>
</div>
<a id="a9b3baebd09cdd0cf9241cef034268aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b3baebd09cdd0cf9241cef034268aa6">&#9670;&nbsp;</a></span>WindowFocusFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a9b3baebd09cdd0cf9241cef034268aa6">TRAP::INTERNAL::WindowingAPI::WindowFocusFunc</a> =  void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a>* window, bool focused)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function pointer type for window focus callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>The window that gained or lost input focus.</td></tr>
    <tr><td class="paramname">focused</td><td>True if the window was given input focus, or false if it lost it.</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_windowing_a_p_i_8h_source.html#l00140">140</a> of file <a class="el" href="_windowing_a_p_i_8h_source.html">WindowingAPI.h</a>.</p>

</div>
</div>
<a id="a533d75518c031574c4c4f7b7633bb18b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a533d75518c031574c4c4f7b7633bb18b">&#9670;&nbsp;</a></span>WindowMaximizeFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a533d75518c031574c4c4f7b7633bb18b">TRAP::INTERNAL::WindowingAPI::WindowMaximizeFunc</a> =  void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a>* window, bool restored)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function pointer type for window maximize callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>The window that was maximized or restored.</td></tr>
    <tr><td class="paramname">restored</td><td>True if the window was maximized, or false if it was restored.</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_windowing_a_p_i_8h_source.html#l00129">129</a> of file <a class="el" href="_windowing_a_p_i_8h_source.html">WindowingAPI.h</a>.</p>

</div>
</div>
<a id="a2f4ad5b36e4a07e27a8a35f4b4d50e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f4ad5b36e4a07e27a8a35f4b4d50e73">&#9670;&nbsp;</a></span>WindowMinimizeFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a2f4ad5b36e4a07e27a8a35f4b4d50e73">TRAP::INTERNAL::WindowingAPI::WindowMinimizeFunc</a> =  void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a>* window, bool restored)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function pointer type for window minimize/iconfiy callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>The window that was minimized/iconified or restored.</td></tr>
    <tr><td class="paramname">restored</td><td>True if the window was minimized/iconified, or false if it was restored. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_windowing_a_p_i_8h_source.html#l00123">123</a> of file <a class="el" href="_windowing_a_p_i_8h_source.html">WindowingAPI.h</a>.</p>

</div>
</div>
<a id="a0e3e0a36774707778dc300a55f725d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3e0a36774707778dc300a55f725d8f">&#9670;&nbsp;</a></span>WindowPositionFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a0e3e0a36774707778dc300a55f725d8f">TRAP::INTERNAL::WindowingAPI::WindowPositionFunc</a> =  void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a>* window, int32_t xPos, int32_t yPos)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function pointer type for window position callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>The window that was moved.</td></tr>
    <tr><td class="paramname">xPos</td><td>The new x-coordinate, in screen coordinates, of the upper-left corner of the content area. </td></tr>
    <tr><td class="paramname">yPos</td><td>The new y-coordinate, in screen coordinates, of the upper-left corner of the content area. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_windowing_a_p_i_8h_source.html#l00108">108</a> of file <a class="el" href="_windowing_a_p_i_8h_source.html">WindowingAPI.h</a>.</p>

</div>
</div>
<a id="a322ac85a2956a17244a7e0ea923bbad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a322ac85a2956a17244a7e0ea923bbad4">&#9670;&nbsp;</a></span>WindowSizeFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a322ac85a2956a17244a7e0ea923bbad4">TRAP::INTERNAL::WindowingAPI::WindowSizeFunc</a> =  void(*)(const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a>* window, int32_t width, int32_t height)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function pointer type for window size callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>The window that was resized.</td></tr>
    <tr><td class="paramname">width</td><td>The new width, in screen coordinates.</td></tr>
    <tr><td class="paramname">height</td><td>The new height, in screen coordinates.</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_windowing_a_p_i_8h_source.html#l00115">115</a> of file <a class="el" href="_windowing_a_p_i_8h_source.html">WindowingAPI.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a89bc89b63f0797c9d4622f4475883079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89bc89b63f0797c9d4622f4475883079">&#9670;&nbsp;</a></span>CursorMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a89bc89b63f0797c9d4622f4475883079">TRAP::INTERNAL::WindowingAPI::CursorMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cursor modes that can be used. </p>

<p class="definition">Definition at line <a class="el" href="_windowing_a_p_i_8h_source.html#l00463">463</a> of file <a class="el" href="_windowing_a_p_i_8h_source.html">WindowingAPI.h</a>.</p>

</div>
</div>
<a id="af3f01f9f3026dcde129e7ce7d141c8bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f01f9f3026dcde129e7ce7d141c8bb">&#9670;&nbsp;</a></span>CursorType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#af3f01f9f3026dcde129e7ce7d141c8bb">TRAP::INTERNAL::WindowingAPI::CursorType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cursor types that can be used. </p>

<p class="definition">Definition at line <a class="el" href="_windowing_a_p_i_8h_source.html#l00475">475</a> of file <a class="el" href="_windowing_a_p_i_8h_source.html">WindowingAPI.h</a>.</p>

</div>
</div>
<a id="ad6083eae3d18232f141e6cc364bac582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6083eae3d18232f141e6cc364bac582">&#9670;&nbsp;</a></span>Error</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ad6083eae3d18232f141e6cc364bac582">TRAP::INTERNAL::WindowingAPI::Error</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Error codes. </p>

<p class="definition">Definition at line <a class="el" href="_windowing_a_p_i_8h_source.html#l00427">427</a> of file <a class="el" href="_windowing_a_p_i_8h_source.html">WindowingAPI.h</a>.</p>

</div>
</div>
<a id="a9954c68c97c88cc331aaf4f0c411880f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9954c68c97c88cc331aaf4f0c411880f">&#9670;&nbsp;</a></span>Hint</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a9954c68c97c88cc331aaf4f0c411880f">TRAP::INTERNAL::WindowingAPI::Hint</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hints for window creation and runtime changes. </p>

<p class="definition">Definition at line <a class="el" href="_windowing_a_p_i_8h_source.html#l00446">446</a> of file <a class="el" href="_windowing_a_p_i_8h_source.html">WindowingAPI.h</a>.</p>

</div>
</div>
<a id="a9b606d91d8dbf66f02e935d2ce38eb3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b606d91d8dbf66f02e935d2ce38eb3a">&#9670;&nbsp;</a></span>ProgressState</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a9b606d91d8dbf66f02e935d2ce38eb3a">TRAP::INTERNAL::WindowingAPI::ProgressState</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>State of progress for a window. </p>

<p class="definition">Definition at line <a class="el" href="_windowing_a_p_i_8h_source.html#l00492">492</a> of file <a class="el" href="_windowing_a_p_i_8h_source.html">WindowingAPI.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9b5016f364f033f1d4a7d0ee4e5d915f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b5016f364f033f1d4a7d0ee4e5d915f">&#9670;&nbsp;</a></span>WindowingAPI() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TRAP::INTERNAL::WindowingAPI::WindowingAPI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<a id="a88f50658ffe0c63795413dffd6929de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f50658ffe0c63795413dffd6929de5">&#9670;&nbsp;</a></span>~WindowingAPI()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TRAP::INTERNAL::WindowingAPI::~WindowingAPI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<a id="a704507a61a446e4541f9e2abaedae836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704507a61a446e4541f9e2abaedae836">&#9670;&nbsp;</a></span>WindowingAPI() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TRAP::INTERNAL::WindowingAPI::WindowingAPI </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>

</div>
</div>
<a id="a2e4bd6283544bd7e50a65c18305f0817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4bd6283544bd7e50a65c18305f0817">&#9670;&nbsp;</a></span>WindowingAPI() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TRAP::INTERNAL::WindowingAPI::WindowingAPI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a082fdcf4188babcf598277dec238b98d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a082fdcf4188babcf598277dec238b98d">&#9670;&nbsp;</a></span>CreateCursor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Scope&lt;<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_cursor.html">InternalCursor</a>&gt; TRAP::INTERNAL::WindowingAPI::CreateCursor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_r_a_p_1_1_image.html">Image</a> *const&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>xHotspot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>yHotspot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new custom cursor image that can be set for a window with SetCursor. The cursor can be destroyed with DestroyCursor. Any remaining cursors are destroyed by <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ae02cae073fb368da7ad98217d56f61dd" title="This function destroys all remaining windows and cursor, and frees any other allocated resources....">WindowingAPI::Shutdown</a>. </p>
<p>The cursor hotspot is specified in pixels, relative to the upper-left corner of the cursor image. Like all other coordinate system in the <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a>, the X-axis points to the right and the Y-axis points down.</p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Thread safety: This function must only be caled from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Non HDR RGB 24BPP or RGBA 32 BPP image.</td></tr>
    <tr><td class="paramname">xHotspot</td><td>Center x coordinate of the image.</td></tr>
    <tr><td class="paramname">yHotspot</td><td>Center y coordinate of the image.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success new internal cursor, nullptr otherwise.</dd></dl>

</div>
</div>
<a id="ad4e6ceb28edaafff926431867d5afda7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e6ceb28edaafff926431867d5afda7">&#9670;&nbsp;</a></span>CreateStandardCursor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Scope&lt;<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_cursor.html">InternalCursor</a>&gt; TRAP::INTERNAL::WindowingAPI::CreateStandardCursor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#af3f01f9f3026dcde129e7ce7d141c8bb">CursorType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a cursor with a standard shape. </p>
<p>Errors: Possible errors include Error::Not_Initialized, Error::Invalid_Enum and Error::Platform_Error. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Cursor type to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success new internal cursor, nullptr otherwise.</dd></dl>

</div>
</div>
<a id="a2bc5abcc39d624e70235389d10e4ff08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bc5abcc39d624e70235389d10e4ff08">&#9670;&nbsp;</a></span>CreateWindow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Scope&lt;<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a>&gt; TRAP::INTERNAL::WindowingAPI::CreateWindow </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_monitor.html">InternalMonitor</a> *&#160;</td>
          <td class="paramname"><em>monitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function creates a window. Most of the options controlling how the window should be created are specified with window hints. </p>
<p>The created window may differ from what you requested, as not all parameters and hints are hard constraints. This includes the size of the window, especially for full screen windows. To query the actual attributes of the create window, see <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a7afe253638a8ba50307659637b98db24" title="This function returns the value of a hint of the specified window.">WindowingAPI::GetWindowHint</a>, <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#af3dca63a6c4bd8c95e9471ecada392f0" title="This function retrieves the size, in screen coordinates, of the content area of the specified window....">WindowingAPI::GetWindowSize</a> and WindowingAPI::GetFramebufferSize.</p>
<p>To create a full screen window, you need to specify the monitor the window will cover. If no monitor is specified, the window will be windowed mode. Unless you have a way for the user to choose a specific monitor, it is recommended that you pick the primary monitor.</p>
<p>For full screen windows, the specified size becomes the resolution of the window's desired video mode. As long as a full screen window is not minimized/iconified, the supported video mode most closely matching the desired video mode is set for the specified monitor.</p>
<p>Once you have create the window, you can switch it between windowed, borderless full screen (windowed) and full screen mode with <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a0f96e4cca3c0803d973323244c40947e" title="This function sets the monitor that the window uses for full screen mode or, if the monitor is nullpt...">WindowingAPI::SetWindowMonitor</a> and <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ae1e22e8d9f9e75eeb7292e115a2a5434" title="This function sets the monitor that the window uses for borderless full screen mode.">WindowingAPI::SetWindowMonitorBorderless</a>.</p>
<p>By default, newly created windows use the placement recommended by the window system. To create the window at a specific position, make it initially invisible using the Hint::Visibile window hint, set its position and then show it.</p>
<p>As long as at least one full screen window is not minimized/iconified, the screensaver is prohibited from starting.</p>
<p><a class="el" href="class_t_r_a_p_1_1_window.html" title="Class representing a desktop system based window.">Window</a> systems put limits on window sizes. Very large or very small window dimensions may be overriden by the window system on creation. Check the actual size after creation.</p>
<p>Errors: Possible errors include Error::Not_Initialized, Error::Invalid_Enum, Error::Invalid_Value, Error::Format_Unavailable and Error::Platform_Error. Remarks: Windows: If the executable has an icon resource named 'TRAP_ICON', it will be set as the initial icon for the window. If no such icon is present, the IDI_APPLICATION icon will be used instead. To set a different icon, see <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#aa1293d678be77c6cc842d72c099b10ac" title="This function sets the icon of the specified window. If no image is specified, the window reverts to ...">WindowingAPI::SetWindowIcon</a>. X11: Some window managers will not respect the placement of initially hidden windows. Due to the asynchronous nature of X11, it may take a moment for a window to reach its requested state. This means you may not be able to query the final size, position or other attributes directly after window creation. The class part of the WM_CLASS window property will by default be set to the window title passed to this function. The instance part will use the contents of the RESOURCE_NAME environment variable, if present and not empty, or fall back to the window title. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>Desired width for the new window. Must be greater than zero.</td></tr>
    <tr><td class="paramname">height</td><td>Desired height for the new window. Must be greater than zero.</td></tr>
    <tr><td class="paramname">title</td><td>UTF-8 encoded title for the new window.</td></tr>
    <tr><td class="paramname">monitor</td><td>Optional monitor to use for the new window.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success a new internal window, or nullptr if an error occurred.</dd></dl>

</div>
</div>
<a id="a08e5e049ccd06c2cac987979050d56a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08e5e049ccd06c2cac987979050d56a5">&#9670;&nbsp;</a></span>CreateWindowSurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static VkResult TRAP::INTERNAL::WindowingAPI::CreateWindowSurface </td>
          <td>(</td>
          <td class="paramtype">VkInstance&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkAllocationCallbacks *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSurfaceKHR &amp;&#160;</td>
          <td class="paramname"><em>surface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a Vulkan surface for the specified window. This function create a Vulkan surface for the specified window. </p>
<p>If the Vulkan loader or at least one minimally functiona ICD were not found, this function return VK_ERROR_INITIALIZATION_FAILED and generates a Error::API_Unavilable error. Call <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a4a62ae75f1affade038ed963c4920282" title="This function returns whether the Vulkan loader and any minimally function ICD have been found.">WindowingAPI::VulkanSupported</a> to check whether Vulkan is at least minimally available.</p>
<p>If the required window surface creation instance extensions are not available or if the specified instance was not created with these extensions enabled, this function returns VK_ERROR_EXTENSION_NOT_PRESENT and generates a Error::API_Unavailable error. Call <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a6c5bb8bb58769001b7a68b2905b4b2ec" title="This function returns an array of names of Vulkan instance extensions required by the WindowingAPI fo...">WindowingAPI::GetRequiredInstanceExtensions</a> to check what instance extensions are required.</p>
<p>The window surface must be destroyed before the specified Vulkan instance. It is the responsibility of the caller to destroy the window surface. The <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> does not destroy it for you. Call vkDestroySurfaceKHR to destroy the surface.</p>
<p>Errors: Possible errors include Error::Not_Initialized, Error::API_Unavailable, Error::Platform_Error and Error::Invalid_Value. Remarks: If an error occurs before the creation call is made, the <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> returns the Vulkan error code most appropriate for the error. Appropriate use of <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a4a62ae75f1affade038ed963c4920282" title="This function returns whether the Vulkan loader and any minimally function ICD have been found.">WindowingAPI::VulkanSupported</a> and <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a6c5bb8bb58769001b7a68b2905b4b2ec" title="This function returns an array of names of Vulkan instance extensions required by the WindowingAPI fo...">WindowingAPI::GetRequiredInstanceExtensions</a> should eliminate almost all occurrences of these errors. Thread safety: This function may be called from any thread. For synchronization details of Vulkan objects, see the Vulkan specification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Vulkan instance.</td></tr>
    <tr><td class="paramname">window</td><td>Internal window for which to create the surface for.</td></tr>
    <tr><td class="paramname">allocator</td><td>Optional allocator.</td></tr>
    <tr><td class="paramname">surface</td><td>Output variable for the new Vulkan surface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS if successful, or a Vulkan error code if an error occurred.</dd></dl>

</div>
</div>
<a id="ad07bcde6cdb37ecc49d697114fbdd2f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad07bcde6cdb37ecc49d697114fbdd2f1">&#9670;&nbsp;</a></span>DefaultWindowHints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::DefaultWindowHints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets all window hints to their default values. </p>
<p>Errors: Possible errors include Error::Not_Initialized. Thread safety: This function must only be called from the main thread.</p>

</div>
</div>
<a id="a4b878058bd5492342e80c56258bef933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b878058bd5492342e80c56258bef933">&#9670;&nbsp;</a></span>DestroyCursor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::DestroyCursor </td>
          <td>(</td>
          <td class="paramtype">Scope&lt; <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_cursor.html">InternalCursor</a> &gt;&#160;</td>
          <td class="paramname"><em>cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function destroys a cursor previously created with CreateCursor. Any remaining cursors will be destroyed by <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ae02cae073fb368da7ad98217d56f61dd" title="This function destroys all remaining windows and cursor, and frees any other allocated resources....">WindowingAPI::Shutdown</a>. </p>
<p>If the specified cursor is current for any window, that window will be reverted to the default cursor. This does not affect the cursor mode.</p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Reentrancy: This function must not be called from a callback. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Internal cursor to be destroyed.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e328cb210eb5f718ee2c00de6cfb3d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e328cb210eb5f718ee2c00de6cfb3d9">&#9670;&nbsp;</a></span>DestroyWindow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::DestroyWindow </td>
          <td>(</td>
          <td class="paramtype">Scope&lt; <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> &gt;&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function destroys the specified window. On calling this function, no further callbacks will be called for that window. </p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Reentrancy: This function must not be called from a callback. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to destroy.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75787e2921cbec187646978eaa433aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75787e2921cbec187646978eaa433aa0">&#9670;&nbsp;</a></span>FocusWindow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::FocusWindow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function brings the specified window to front and sets input focus. The window should already be visible and not minimized/iconified. </p>
<p>By default, both windowed and full screen mode windows are focused when initially created. Set the Hint::Focused hint to disable this behaviour.</p>
<p>Also by default windowed mode windows are focused when shown with <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a620187132ad11295feed29d8aa2d617e" title="This function makes the specified window visible if it was previously hidden. If the window is alread...">WindowingAPI::ShowWindow</a>. Set the Hint::FocusOnShow hint to disable this behaviour.</p>
<p>DO NOT USE THIS FUNCTION to steal focus from other applications unless you are certain that is what the user wants. Focus stealing can be extremely disruptive.</p>
<p>For a less disruptive way of gettings the user's attention, see <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ab78d96deda94785874f5e6a5652e333c" title="This function requests user attention to the specified window. On platforms where this is not support...">WindowingAPI::RequestWindowAttention</a>.</p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to focus.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a717541326849d35a09230b5f43c39237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a717541326849d35a09230b5f43c39237">&#9670;&nbsp;</a></span>GetCharCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a00eec701497894f9d1918de2598a3078">CharFunc</a> TRAP::INTERNAL::WindowingAPI::GetCharCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the Unicode character callback for the specified window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window from which to query the callback from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Function that gets called when a char event occurs.</dd></dl>

</div>
</div>
<a id="a62669f2a8075dcd5c165c11fd28c6653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62669f2a8075dcd5c165c11fd28c6653">&#9670;&nbsp;</a></span>GetClipboardString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string TRAP::INTERNAL::WindowingAPI::GetClipboardString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns the contents of the system clipboard, if it contains or is convertible to a UTF-8 encoded string. If the clipboard is empty or if its content cannot be converted, an empty string is returned and a Error::Format_Unavailable error is generated. </p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Thread safety: This function must only be called from the main thread.</p>
<dl class="section return"><dt>Returns</dt><dd>UTF-8 encoded string containing clipboard contents, or empty string if an error occurred. </dd></dl>

</div>
</div>
<a id="a5675ccee3f25378c4c1fb036f3f7fa04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5675ccee3f25378c4c1fb036f3f7fa04">&#9670;&nbsp;</a></span>GetCursorEnterCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a744db66c26554a60557af235db7eb2fd">CursorEnterFunc</a> TRAP::INTERNAL::WindowingAPI::GetCursorEnterCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the cursor enter callback for the specified window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window from which to query the callback from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Function that gets called when a cursor enter event occurs.</dd></dl>

</div>
</div>
<a id="a0dfd8b46be1ac58a40743ee73b8f7360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dfd8b46be1ac58a40743ee73b8f7360">&#9670;&nbsp;</a></span>GetCursorMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a89bc89b63f0797c9d4622f4475883079">CursorMode</a> TRAP::INTERNAL::WindowingAPI::GetCursorMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the cursor mode from the specified window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to query the cursor mode from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cursor mode used by the internal window.</dd></dl>

</div>
</div>
<a id="a883e554b529ac2be71c731a0e1dc8ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883e554b529ac2be71c731a0e1dc8ac6">&#9670;&nbsp;</a></span>GetCursorPos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::GetCursorPos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>xPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>yPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns the position of the cursor, in screen coordinates, relative to the upper-left corner of the content area of the specified window. </p>
<p>If the cursor is disabled (with CursorMode::Disabled) then the cursor position is unbounded and limited only by the minimum and maximum values of a double.</p>
<p>The coordinate can be converted to their integer equivalents with the TRAP::Math::Floor function. Casting directly to an integer type works for positive coordinates, but fails for negative ones.</p>
<p>If an error occurs, xPos and yPos will be set to zero.</p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window from which to get the current cursor position.</td></tr>
    <tr><td class="paramname">xPos</td><td>Output variable for the current x position, relative to the left edge of the content area, of the cursor. </td></tr>
    <tr><td class="paramname">yPos</td><td>Output variable for the current y position, relative to the top edge of the content area, of the cursor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae75cd868b0f0ae370fc4771c29bc0a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae75cd868b0f0ae370fc4771c29bc0a0">&#9670;&nbsp;</a></span>GetCursorPosCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a7cd43357d32c8b5ec04ab8be2117d2d7">CursorPositionFunc</a> TRAP::INTERNAL::WindowingAPI::GetCursorPosCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the cursor position callback for the specified window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window from which to query the callback from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Function that gets called when a cursor position event occurs.</dd></dl>

</div>
</div>
<a id="ae0789aa2ad19268c439fa76801228cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0789aa2ad19268c439fa76801228cfe">&#9670;&nbsp;</a></span>GetDropCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#aaf7d4ffac5bb5175661b6811fafc2130">DropFunc</a> TRAP::INTERNAL::WindowingAPI::GetDropCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the path drop callback for the specified window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window from which to query the callback from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Function that gets called when a drop event occurs.</dd></dl>

</div>
</div>
<a id="a0311b5410343d39892b4cb707bc83494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0311b5410343d39892b4cb707bc83494">&#9670;&nbsp;</a></span>GetFrameBufferSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::GetFrameBufferSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function retrieves the size, in pixels, of the framebuffer of the specified window. If you wish to retrieve the size of the window in screen coordinates, see <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#af3dca63a6c4bd8c95e9471ecada392f0" title="This function retrieves the size, in screen coordinates, of the content area of the specified window....">WindowingAPI::GetWindowSize</a>. </p>
<p>If an error occcurs, width and height will be set to zero.</p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to get the framebuffer size from.</td></tr>
    <tr><td class="paramname">width</td><td>Output variable for the internal windows current framebuffer width.</td></tr>
    <tr><td class="paramname">height</td><td>Output variable for the internal windows current framebuffer height.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae566f8807b5ff468e445e418dd79912f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae566f8807b5ff468e445e418dd79912f">&#9670;&nbsp;</a></span>GetFrameBufferSizeCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a1f82bdf5c722c1697a40a01f0a71a363">FrameBufferSizeFunc</a> TRAP::INTERNAL::WindowingAPI::GetFrameBufferSizeCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the framebuffer resize callback for the specified window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window from which to query the callback from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Function that gets called when a framebuffer size event occurs.</dd></dl>

</div>
</div>
<a id="a3addef42b7cce04b5251a705dc5bdf16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3addef42b7cce04b5251a705dc5bdf16">&#9670;&nbsp;</a></span>GetKey()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool TRAP::INTERNAL::WindowingAPI::GetKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_a_p_1_1_input.html#ad374615c3007cee473d1e616af34a66c">Input::Key</a>&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns the last state reported for the specified key to the specified window. The returned state is pressed (true) or released (false). </p>
<p>The key functions deal with physical keys, with key token named after their use on the standard US keyboard layout. If you want to input text, use the Unicode character callback instead.</p>
<p>DO NOT USE THIS FUNCTION to implement text input.</p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Invalid_Enum. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to query.</td></tr>
    <tr><td class="paramname">key</td><td>Key to get last reported state from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Last reported state of the specified key.</dd></dl>

</div>
</div>
<a id="a2a1af542837bef9bc18f3beeaed10815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a1af542837bef9bc18f3beeaed10815">&#9670;&nbsp;</a></span>GetKeyCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a54944b816809b9367ef0023540d70bed">KeyFunc</a> TRAP::INTERNAL::WindowingAPI::GetKeyCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the key callback for the specified window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window from which to query the callback from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Function that gets called when a key event occurs.</dd></dl>

</div>
</div>
<a id="a7e80d336ab15245ef0dcfd74715debbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e80d336ab15245ef0dcfd74715debbc">&#9670;&nbsp;</a></span>GetKeyName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char* TRAP::INTERNAL::WindowingAPI::GetKeyName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_r_a_p_1_1_input.html#ad374615c3007cee473d1e616af34a66c">Input::Key</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>scanCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns the name of the specified printable key, encoded as UTF-8. This is typically the character that key would produce without any modifier keys, intended for displaying key bindings to the user. For dead keys, it is typically the diacritic it would add to a character. </p>
<p>DO NOT USE THIS FUNCTION for text input. You will break text input for many languages even if it happens to work for yours.</p>
<p>If the key is Input::Key::Unknown, the scancode is used to identify the key, otherwise the scancode is ignored. If you specify a non-printable key, or Input::Key::Unknown and a scancode that maps to a non-printable key, this function return nullptr but does not emit an error.</p>
<p>This behaviour allows you to always pass in the arguments in the key callback without modification.</p>
<p>The printable keys are: Input::Key::Apostrophe Input::Key::Comma Input::Key::Minus Input::Key::Period Input::Key::Slash Input::Key::Semicolon Input::Key::Equal Input::Key::Left_Bracket Input::Key::Right_Bracket Input::Key::Backslash Input::Key::World_1 Input::Key::World_2 Input::Key::Zero to Input::Key::Nine Input::Key::A to Input::Key::Z Input::Key::KP_0 to Input::Key::KP_9 Input::Key::KP_Decimal Input::Key::KP_Divide Input::Key::KP_Multiply Input::Key::KP_Subtract Input::Key::KP_Add Input::Key::KP_Equal</p>
<p>Names for printable keys depend on keyboard layout, while names for non-printable keys are the same across layouts but depend on the application language and should be localized along with other user interface text.</p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Remarks: The contents of the returned string may change when a keyboard layout change event is received. Pointer lifetime: The returned string is allocated and freed by the <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a>. You should not free it yourself. It is valid until the library is terminated. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to get layout-specific name from.</td></tr>
    <tr><td class="paramname">scanCode</td><td>Optional scan code to get layout-specific name from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UTF-8 encoded, layout-specific name of the given key or nullptr.</dd></dl>

</div>
</div>
<a id="a98265bfcd9919ce2d4f1a523c4d5e4a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98265bfcd9919ce2d4f1a523c4d5e4a4">&#9670;&nbsp;</a></span>GetMonitorCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a1489018def8622680eb4cbbe7216ad18">MonitorFunc</a> TRAP::INTERNAL::WindowingAPI::GetMonitorCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the monitor configuration callback. </p>
<dl class="section return"><dt>Returns</dt><dd>Function that gets called when a monitor event occurs.</dd></dl>

</div>
</div>
<a id="a204be9d8d4cfea4aac5f715a14745b7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204be9d8d4cfea4aac5f715a14745b7f">&#9670;&nbsp;</a></span>GetMonitorContentScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::GetMonitorContentScale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_monitor.html">InternalMonitor</a> *&#160;</td>
          <td class="paramname"><em>monitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>xScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>yScale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function retrieves the content scale for the specified monitor. The content scale is the ratio between the current DPI and the platform's default DPI. This is especially important for text and any UI elements. If the pixel dimensions of your UI scaled by this look appropriate on your machine then it should appear at a reasonable size on other machines regardless of their DPI and scaling settings. This relies on the system DPI and scaling settings being somewhat correct. </p>
<p>The content scale may depend on both the monitor resolution and pixel density and on user settings. It may be very different from the raw DPI calculated from the physical size and current resolution.</p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">monitor</td><td>Internal monitor.</td></tr>
    <tr><td class="paramname">xScale</td><td>Output variable for the X scale of the provided monitor.</td></tr>
    <tr><td class="paramname">yScale</td><td>Output variable for the Y scale of the provided monitor.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a695a286683584adf1d73ce56b946925d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695a286683584adf1d73ce56b946925d">&#9670;&nbsp;</a></span>GetMonitorName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string TRAP::INTERNAL::WindowingAPI::GetMonitorName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_monitor.html">InternalMonitor</a> *&#160;</td>
          <td class="paramname"><em>monitor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns a human-readable name, encoded as UTF-8, of the specified monitor. The name typically reflects the make and model of the monitor and is not guaranteed to be unique among the connected monitors. </p>
<p>Errors: Possible errors include Error::Not_Initialized. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">monitor</td><td><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_monitor.html" title="Monitor structure.">InternalMonitor</a> to query name from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Name of the provided monitor.</dd></dl>

</div>
</div>
<a id="a66b881a8d544e08e2e6f23a6204dd5c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b881a8d544e08e2e6f23a6204dd5c5">&#9670;&nbsp;</a></span>GetMonitorPos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::GetMonitorPos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_monitor.html">InternalMonitor</a> *&#160;</td>
          <td class="paramname"><em>monitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>xPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>yPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position of the monitor's viewport on the virtual screen. This function returns the position, in screen coordinates, of the upper-left corner of the specified monitor. </p>
<p>If an error occurs, xPos and yPos will be set to zero.</p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">monitor</td><td>Internal monitor to query.</td></tr>
    <tr><td class="paramname">xPos</td><td>Output variable for the x position of the monitor.</td></tr>
    <tr><td class="paramname">yPos</td><td>Output variable for the y position of the monitor.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd88bc671ed915ca43aac498683a87ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd88bc671ed915ca43aac498683a87ae">&#9670;&nbsp;</a></span>GetMonitors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_monitor.html">InternalMonitor</a>*&gt; TRAP::INTERNAL::WindowingAPI::GetMonitors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns a vector of handles for all currently connceted monitors. The primary monitor is always first in the returned vector. If no monitors were found, this function returns an empty vector. </p>
<p>Errors: Possible errors include Error::Not_Initialized. Thread safety: This function must only be called from the main thread.</p>
<dl class="section return"><dt>Returns</dt><dd>Vector of all connected monitor handles, or an empty vector if no monitors were found or if an error occurred. </dd></dl>

</div>
</div>
<a id="afc683c5e5c0849f9a86e2c5e9fd33066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc683c5e5c0849f9a86e2c5e9fd33066">&#9670;&nbsp;</a></span>GetMonitorWorkArea()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::GetMonitorWorkArea </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_monitor.html">InternalMonitor</a> *&#160;</td>
          <td class="paramname"><em>monitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>xPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>yPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns the position, in screen coordinates, of the upper-left corner of the work area of the specified monitor along with the work area size in screen coordinates. The work area is defined as the area of the monitor not occluded by the operating system task bar where present. If no task bar exists then the work area is the monitor resolution in screen coordinates. </p>
<p>If an error occurs, xPos, yPos, width and height will be set to zero.</p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">monitor</td><td>Internal monitor to query.</td></tr>
    <tr><td class="paramname">xPos</td><td>Output variable for the x position of the monitor.</td></tr>
    <tr><td class="paramname">yPos</td><td>Output variable for the y position of the monitor.</td></tr>
    <tr><td class="paramname">width</td><td>Output variable for the width of the monitor.</td></tr>
    <tr><td class="paramname">height</td><td>Output variable for the height of the monitor.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8646f034224a2a58a5121be4abb77b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8646f034224a2a58a5121be4abb77b2a">&#9670;&nbsp;</a></span>GetMouseButton()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool TRAP::INTERNAL::WindowingAPI::GetMouseButton </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_a_p_1_1_input.html#aa03b41ad11d04dd89343ead74658b2c4">Input::MouseButton</a>&#160;</td>
          <td class="paramname"><em>button</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns the last state reported for the specified mouse button to the specified window. The returned state is pressed (true) or released (false). </p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Invalid_Enum. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to query.</td></tr>
    <tr><td class="paramname">button</td><td>Mouse button to get last reported state from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Last reported state of the specified mouse button.</dd></dl>

</div>
</div>
<a id="ac524a16c78e366512959fb9e7fc288b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac524a16c78e366512959fb9e7fc288b7">&#9670;&nbsp;</a></span>GetMouseButtonCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a69561f5a3240dde706ce9896aaba946e">MouseButtonFunc</a> TRAP::INTERNAL::WindowingAPI::GetMouseButtonCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the mouse button callback for the specified window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window from which to query the callback from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Function that gets called when a mouse button event occurs.</dd></dl>

</div>
</div>
<a id="a4ef2c9b10e956a64acd41ba30dfb122d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef2c9b10e956a64acd41ba30dfb122d">&#9670;&nbsp;</a></span>GetPrimaryMonitor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_monitor.html">InternalMonitor</a>* TRAP::INTERNAL::WindowingAPI::GetPrimaryMonitor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns the primary monitor. This is usually the monitor where elements like the task bar or global menu bar are located. </p>
<p>Errors: Possible errors include Error::Not_Initialized. Thread safety: This function must only be called from the main thread. Remarks: The primary monitor is always first in the vector returned by <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#afd88bc671ed915ca43aac498683a87ae" title="This function returns a vector of handles for all currently connceted monitors. The primary monitor i...">WindowingAPI::GetMonitors</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Primary internal monitor, or nullptr if no monitors were found or if an error occurred. </dd></dl>

</div>
</div>
<a id="a6bdeb0f0f0b6c87ff1356a1dc354b2cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bdeb0f0f0b6c87ff1356a1dc354b2cf">&#9670;&nbsp;</a></span>GetRawMouseMotionMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool TRAP::INTERNAL::WindowingAPI::GetRawMouseMotionMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the raw mouse motion mode for the specified window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if raw mouse motion mode is enabled, false otherwise.</dd></dl>

</div>
</div>
<a id="a6c5bb8bb58769001b7a68b2905b4b2ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c5bb8bb58769001b7a68b2905b4b2ec">&#9670;&nbsp;</a></span>GetRequiredInstanceExtensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::array&lt;std::string, 2&gt; TRAP::INTERNAL::WindowingAPI::GetRequiredInstanceExtensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns an array of names of Vulkan instance extensions required by the <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> for creating Vulkan surface for <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> windows. If successful, the list will always contain VK_KHR_surface, so if you don't require any additional extensions you can pass this list directly to the VkInstanceCreateInfo struct. </p>
<p>If Vulkan is not available on the machine, this function return an array with empty strings and generates a Error::API_Unavailable error. Call <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a4a62ae75f1affade038ed963c4920282" title="This function returns whether the Vulkan loader and any minimally function ICD have been found.">WindowingAPI::VulkanSupported</a> to check whether Vulkan is at least minimally available.</p>
<p>If Vulkan is available but no set of extensions allowing window surface creation was found, this function returns an array with empty strings. You may still use Vulkan for off-screen rendering and compute work.</p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::API_Unavailable. Remarks: Additional extensions may be required by future versions of the <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a>. You should check if any extensions you wish to enable are already in the returned array, as it is an error to specify an extension more than once in the VkInstanceCreateInfo struct. Thread safety: This function may be called from any thread.</p>
<dl class="section return"><dt>Returns</dt><dd>Array containing the required instance extensions, or an array with empty string if an error occurred. </dd></dl>

</div>
</div>
<a id="a5cfb301e3440ead4726d398d555c0f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cfb301e3440ead4726d398d555c0f96">&#9670;&nbsp;</a></span>GetScrollCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#adb5e6705d6868a3a5722ef8c77c71855">ScrollFunc</a> TRAP::INTERNAL::WindowingAPI::GetScrollCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the scroll callback for the specified window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window from which to query the callback from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Function that gets called when a scroll event occurs.</dd></dl>

</div>
</div>
<a id="ad28b811b515a7a818313e010be7233e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28b811b515a7a818313e010be7233e4">&#9670;&nbsp;</a></span>GetVideoMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_video_mode.html">InternalVideoMode</a> TRAP::INTERNAL::WindowingAPI::GetVideoMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_monitor.html">InternalMonitor</a> *&#160;</td>
          <td class="paramname"><em>monitor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns the current video mode of the specified monitor. If you have created a full screen window for that monitor, the return value will depend on whether that window is minimized/iconified. </p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">monitor</td><td>Internal monitor to get internal video mode from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current video mode of the specified monitor, or an empty one if an error occurred. </dd></dl>

</div>
</div>
<a id="a19711995c71805e3b88e7dedc8ea8922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19711995c71805e3b88e7dedc8ea8922">&#9670;&nbsp;</a></span>GetVideoModes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;<a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_video_mode.html">InternalVideoMode</a>&gt; TRAP::INTERNAL::WindowingAPI::GetVideoModes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_monitor.html">InternalMonitor</a> *&#160;</td>
          <td class="paramname"><em>monitor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns a vector of all video modes supported by the specified monitor. The returned vector is sorted in ascending order, first by color bit depth (the sum of all channel depths) and then by resolution area (the product of width and height). </p>
<p>Errors: Possible errors include: Error::Not_Initialized and Error::Platform_Error. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">monitor</td><td>Internal monitor to get all internal video modes from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector with all available video modes of the specified monitor, or an empty vector if an error occurred. </dd></dl>

</div>
</div>
<a id="a55ab94d0facb586c7df61dab5305bc92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55ab94d0facb586c7df61dab5305bc92">&#9670;&nbsp;</a></span>GetWindowCloseCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ab7ec03c4a779e92189a77d56edec88d9">WindowCloseFunc</a> TRAP::INTERNAL::WindowingAPI::GetWindowCloseCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the close callback for the specified window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window from which to query the callback from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Function that gets called when a close event occurs.</dd></dl>

</div>
</div>
<a id="a6e8d34810903b689a1a19cdb7d26baa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e8d34810903b689a1a19cdb7d26baa2">&#9670;&nbsp;</a></span>GetWindowContentScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::GetWindowContentScale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>xScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>yScale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function retrieves the content scale for the specified window. The content scale is the reatio between the current DPI and the platform's default DPI. This is especially important for text and any UI elements. If the pixel dimensions of your UI scaled by this look appropriate on your machine then it should appear at a reasonable size on other machines regardless of their DPI and scaling settings. This relies on the system DPI and scaling settings being somewhat correct. </p>
<p>On systems where each monitor can have its own content scale, the window content scale will depend on which monitor the system considers the window to be on.</p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to get the content scale from.</td></tr>
    <tr><td class="paramname">xScale</td><td>Output variable for the internal windows content scale x.</td></tr>
    <tr><td class="paramname">yScale</td><td>Output variable for the internal windows content scale y.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab923572ac20b872287015dd3605fd998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab923572ac20b872287015dd3605fd998">&#9670;&nbsp;</a></span>GetWindowContentScaleCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ab2391c5c92468889bd96c727c7d128b7">WindowContentScaleFunc</a> TRAP::INTERNAL::WindowingAPI::GetWindowContentScaleCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the window content scale callback for the specified window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window from which to query the callback from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Function that gets called when a content scale event occurs.</dd></dl>

</div>
</div>
<a id="a05e399f87c5ecc0f9f5b34fef8906447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05e399f87c5ecc0f9f5b34fef8906447">&#9670;&nbsp;</a></span>GetWindowFocusCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a9b3baebd09cdd0cf9241cef034268aa6">WindowFocusFunc</a> TRAP::INTERNAL::WindowingAPI::GetWindowFocusCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the focus callback for the specified window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window from which to query the callback from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Function that gets called when a focus event occurs.</dd></dl>

</div>
</div>
<a id="a7afe253638a8ba50307659637b98db24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7afe253638a8ba50307659637b98db24">&#9670;&nbsp;</a></span>GetWindowHint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool TRAP::INTERNAL::WindowingAPI::GetWindowHint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a9954c68c97c88cc331aaf4f0c411880f">Hint</a>&#160;</td>
          <td class="paramname"><em>hint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns the value of a hint of the specified window. </p>
<p>Errors: Possible errors include Error::Not_Initialized, Error::Invalid_Enum and Error::Platform_Error. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to get the hint from.</td></tr>
    <tr><td class="paramname">hint</td><td>Hint to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if hint is enabled, false otherwise.</dd></dl>

</div>
</div>
<a id="a17db9fbbc6f6651653179a089c97a1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17db9fbbc6f6651653179a089c97a1cf">&#9670;&nbsp;</a></span>GetWindowOpacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float TRAP::INTERNAL::WindowingAPI::GetWindowOpacity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns the opacity of the window, including any decorations. </p>
<p>The opacity (or alpha) value is a positive finite number between zero and one, where zero is fully transparent and one is fully opaque. If the system does not support whole window transparency, this function always returns one.</p>
<p>The initial opacity value for newly created windows is 1.0f.</p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to get the opacity from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Opacity of the given internal window.</dd></dl>

</div>
</div>
<a id="aac0b01312944f515eab8a986d0904932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0b01312944f515eab8a986d0904932">&#9670;&nbsp;</a></span>GetWindowPos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::GetWindowPos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>xPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>yPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function retrieves the position, in screen coordinates, of the upper-left corner of the content area of the specified window. </p>
<p>If an error occurs, xPos and yPos will be set to zero.</p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to get the current position from.</td></tr>
    <tr><td class="paramname">xPos</td><td>Output variable for the current x position of the internal window.</td></tr>
    <tr><td class="paramname">yPos</td><td>Output variable for the current y position of the internal window.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d31a6230ad3fe7fe0a309fe43af8c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d31a6230ad3fe7fe0a309fe43af8c9e">&#9670;&nbsp;</a></span>GetWindowPosCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a0e3e0a36774707778dc300a55f725d8f">WindowPositionFunc</a> TRAP::INTERNAL::WindowingAPI::GetWindowPosCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the position callback for the specified window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window from which to query the callback from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Function that gets called when a position event occurs.</dd></dl>

</div>
</div>
<a id="af3dca63a6c4bd8c95e9471ecada392f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3dca63a6c4bd8c95e9471ecada392f0">&#9670;&nbsp;</a></span>GetWindowSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::GetWindowSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function retrieves the size, in screen coordinates, of the content area of the specified window. If you wish to retrieve the size of the framebuffer of the window in pixels, see <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a0311b5410343d39892b4cb707bc83494" title="This function retrieves the size, in pixels, of the framebuffer of the specified window....">WindowingAPI::GetFrameBufferSize</a>. </p>
<p>If an error occurs, width and height will be set to zero.</p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to get the size from.</td></tr>
    <tr><td class="paramname">width</td><td>Output variable for the internal windows current width.</td></tr>
    <tr><td class="paramname">height</td><td>Output variable for the internal windows current height.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e722f7ae64cf157f4abf110ba16ae0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e722f7ae64cf157f4abf110ba16ae0c">&#9670;&nbsp;</a></span>GetWindowSizeCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a322ac85a2956a17244a7e0ea923bbad4">WindowSizeFunc</a> TRAP::INTERNAL::WindowingAPI::GetWindowSizeCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size callback for the specified window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window from which to query the callback from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Function that gets called when a size event occurs.</dd></dl>

</div>
</div>
<a id="a2afff9964b95834076934a1bf77d902a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2afff9964b95834076934a1bf77d902a">&#9670;&nbsp;</a></span>GetWindowUserPointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* TRAP::INTERNAL::WindowingAPI::GetWindowUserPointer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns the current value of the user-defined pointer of the specified window. The initial value is nullptr. </p>
<p>Errors: Possible errors include Error::Not_Initialized. Thread safety: This function may be called from any thread. Access is not synchronized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to get the user pointer from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Data stored with the window.</dd></dl>

</div>
</div>
<a id="a5cd237cfbb2c0fb060ef706c3d090ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd237cfbb2c0fb060ef706c3d090ebc">&#9670;&nbsp;</a></span>HideWindow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::HideWindow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function hides the specified window if it was previously visible. If the window is already hidden or is in full screen mode, this function does nothing. </p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to hide.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96d1e8dc77c47700b2fc329956a52d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d1e8dc77c47700b2fc329956a52d66">&#9670;&nbsp;</a></span>HideWindowFromTaskbar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::HideWindowFromTaskbar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hides the specified window from the taskbar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to hide from the taskbar.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfe0c61f9e9210e6b2f3532ba9f59eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe0c61f9e9210e6b2f3532ba9f59eda">&#9670;&nbsp;</a></span>Init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool TRAP::INTERNAL::WindowingAPI::Init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the windowing API. Before most <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> functions can be used, the <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> must be initialized, and before the engine terminates the <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> should be terminated in order to free any resources allocated during or after initialization. </p>
<p>If this function fails, it calls <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ae02cae073fb368da7ad98217d56f61dd" title="This function destroys all remaining windows and cursor, and frees any other allocated resources....">WindowingAPI::Shutdown</a> before returning. If it succeeds, <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ae02cae073fb368da7ad98217d56f61dd" title="This function destroys all remaining windows and cursor, and frees any other allocated resources....">WindowingAPI::Shutdown</a> should be called before the engine exits.</p>
<p>Additional calls to this function after successful initialization but before terminiation will return true immediately.</p>
<p>Errors: Possible errors include Error::Platform_Unavailable and Error::Platform_Error. Remarks: X11: This function will set the LC_CTYPE category of the engine locale according to the current environment if that category is still "C". This is because the "C" locale breaks Unicode text input. Thread safety: This function must only be called from the main thread.</p>
<dl class="section return"><dt>Returns</dt><dd>True if windowing API was successfully initialized, false otherwise.</dd></dl>

</div>
</div>
<a id="a5fe5a7e41eeeaa55d224a136e8f23b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fe5a7e41eeeaa55d224a136e8f23b5b">&#9670;&nbsp;</a></span>MaximizeWindow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::MaximizeWindow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function maximizes the specified window if it was previously not maximized. If the window is already maximized, this function does nothing. </p>
<p>If the specified window is a full screen window, this function does nothing.</p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Thread safety: This function may only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to maximize.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a477bfb62df7c0e56a2003579aa2b2148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a477bfb62df7c0e56a2003579aa2b2148">&#9670;&nbsp;</a></span>MinimizeWindow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::MinimizeWindow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function minimizes (iconifies) the specified window if it was previously restored. If the window is already minimized (iconified), this function does nothing. </p>
<p>If the specified window is a full screen window, the original monitor resolution is restored util the window is restored.</p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to minimize/iconify.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75bf6b4cd71671bb71fb155fbaeb182f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75bf6b4cd71671bb71fb155fbaeb182f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a>&amp; TRAP::INTERNAL::WindowingAPI::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>

</div>
</div>
<a id="a73051244ab215644a463c14b1ae767d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73051244ab215644a463c14b1ae767d9">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a>&amp; TRAP::INTERNAL::WindowingAPI::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>

</div>
</div>
<a id="aaadc3ee48e4e45a1fd83551533545fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaadc3ee48e4e45a1fd83551533545fe9">&#9670;&nbsp;</a></span>PollEvents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::PollEvents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function processes only those events that are already in the event queue and then returns immediately. Processing events will cause the window and input callbacks associated with those events to be called. </p>
<p>On some platforms, a window move, resize or menu operation will cause event processing to block. This is due to how event processing is designed on those platforms.</p>
<p>Do not assume that callbacks you set will only be called in response to event processing functions like this one. While it is necessary to poll for events, window systems that require the <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> to register callbacks of its own can pass evnts to the <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> in response to many window system function calls. The <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> will pass those events on to the application callbacks before returning.</p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Reentrancy: This function must not be called from a callback. Thread safety: This function must only be called from the main thread.</p>

</div>
</div>
<a id="a21dd68a6d59e81760076dab3213c35c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21dd68a6d59e81760076dab3213c35c6">&#9670;&nbsp;</a></span>RawMouseMotionSupported()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool TRAP::INTERNAL::WindowingAPI::RawMouseMotionSupported </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns whether raw mouse motion is supported on the current system. This status does not change after the <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> has been initialized so you only need to check this once. If you attemp to enable raw motion on a system that does not support it, Error::Platform_Error will be emitted. </p>
<p>Raw mouse motion is closer to the actual motion of the mouse across a surface. It is not affected by the scaling and acceleration applied to the motion of the desktop cursor. That processing is suitable for a cursor while raw motion is better for controlling for example a 3D camera. Because of this, raw mouse motion is only provided when the cursor is disabled.</p>
<p>Errors: Possible errors include Error::Not_Initialized. Thread safety: This function must only be called from the main thread.</p>
<dl class="section return"><dt>Returns</dt><dd>True if raw mouse input is supported, false otherwise.</dd></dl>

</div>
</div>
<a id="ab78d96deda94785874f5e6a5652e333c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78d96deda94785874f5e6a5652e333c">&#9670;&nbsp;</a></span>RequestWindowAttention()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::RequestWindowAttention </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function requests user attention to the specified window. On platforms where this is not supported, attention is requested to the application as a whole. </p>
<p>Once the user has given attention, usually by focusing the window or application, the system will end the request automatically.</p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to request user attention for.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acff6f065d301032c88cd72c3575f1c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff6f065d301032c88cd72c3575f1c61">&#9670;&nbsp;</a></span>RestoreWindow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::RestoreWindow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restores the specified window. This function restores the specified window if it was previously minimized (iconified) or maximized. If the window is already restored, this function does nothing. </p>
<p>If the specified window is a full screen window, the resolution chosen for the window is restored on the selected monitor.</p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to be restored.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae96d357e177939264f934ca1a661f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae96d357e177939264f934ca1a661f30">&#9670;&nbsp;</a></span>SetCharCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetCharCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a00eec701497894f9d1918de2598a3078">CharFunc</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets the character callback of the specified window, which is called when a Unicode character is input. </p>
<p>The character callback is intended for Unicode text input. As it deals with characters, it is keyboard layout dependent. whereas the key callback is not. Characters do not map 1:1 to physical keys, as a key may produce zero, one or more character. If you want to know whether a specific physical key was pressed or released, see the key callback instead.</p>
<p>The character callback behaves as system text input normally does and will not be called if modifier keys are held down that would prevent normal text input on that platform, for example Alt key on Windows.</p>
<p>Erros: Possible errors include Error::Not_Initialized. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to set the callback for.</td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when a char event occurs, or nullptr to remove the currently set callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a655aceac8d334839924e95d77dfc7652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655aceac8d334839924e95d77dfc7652">&#9670;&nbsp;</a></span>SetClipboardString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetClipboardString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets the system clipboard to the specified, UTF-8 encoded string. </p>
<p>Errors: Possible errors include Error::Not_Initialized, Error::Format_Unavailable and Error::Platform_Error. Pointer lifetime: The specified string is copied before this function returns. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>UTF-8 encoded string to be set for the clipboard.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1403aa4df32303f1ddb61111a7817d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1403aa4df32303f1ddb61111a7817d18">&#9670;&nbsp;</a></span>SetContentScaleCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetContentScaleCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ab2391c5c92468889bd96c727c7d128b7">WindowContentScaleFunc</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets the window content scale callback of the specified window, which is called when the content scale of the specified window changes. </p>
<p>Errors: Possible errors include Error::Not_Initialized. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to set the callback for.</td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when a content scale event occurs, or nullptr to remove the currently set callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67e4e63eea748e5d0393d5f5b1b2661a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67e4e63eea748e5d0393d5f5b1b2661a">&#9670;&nbsp;</a></span>SetCursor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetCursor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_cursor.html">InternalCursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets the cursor image to be used when the cursor is over the content are of the specified window. The set cursor will only be visible when the CursorMode of the window is CursorMode::Normal. </p>
<p>On some platforms, the set cursor may not be visible unless the window also has input focus.</p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to set the cursor for.</td></tr>
    <tr><td class="paramname">cursor</td><td>Internal cursor to set, or nullptr to switch back to the default arrow cursor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85d51a891f8c73751b6c250da483acaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d51a891f8c73751b6c250da483acaf">&#9670;&nbsp;</a></span>SetCursorEnterCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetCursorEnterCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a744db66c26554a60557af235db7eb2fd">CursorEnterFunc</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets the cursor boundary crossing callback of the specified window, which is called when the cursor enters or leaves the content area of the window. </p>
<p>Errors: Possible errors include Error::Not_Initialized. Thread safety: This fucntion must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to set the callback for.</td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when a cursor enter event occurs, or nullptr to remove the currently set callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66ae5efb628a500a262d9c4c2518a52f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66ae5efb628a500a262d9c4c2518a52f">&#9670;&nbsp;</a></span>SetCursorMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetCursorMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a89bc89b63f0797c9d4622f4475883079">CursorMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets a cursor mode for the specified window. </p>
<p>The mode must be one of the following CursorModes:</p><ul>
<li>Normal makes the cursor visible and behaving normally.</li>
<li>Hidden makes the cursor invisible when it is over the content area of the window but does not restrict the cursor from leaving.</li>
<li>Disabled hides and grabs the cursor, providing virtual and unlimited cursor movement.</li>
</ul>
<p>Errors: Possible errors include Error::Not_Initialized, Error::Invalid_Enum and Error::Platform_Error. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to set the cursor mode for.</td></tr>
    <tr><td class="paramname">mode</td><td>Cursor mode to be set.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4edbf7a05873e0f0138d812c5348d123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4edbf7a05873e0f0138d812c5348d123">&#9670;&nbsp;</a></span>SetCursorPos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetCursorPos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets the position, in screen coordinates, of the cursor relative to the upper-left corner of the content area of the specified window. The window must have input focus. If the window does not have input focus when this function is called, it fails silently. </p>
<p>DO NOT USE THIS FUNCTION to implement things like camera controls. The <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> already provides the CursorMode::Disabled that hides the cursor, transparently re-centers it and provides unconstrained cursor motion. See SetCursorMode for more information.</p>
<p>If the cursor mode is CursorMode::Disabled then the cursor position is unconstrained and limited only by the minimum and maximum values of a double.</p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to set the cursor position for.</td></tr>
    <tr><td class="paramname">xPos</td><td>New x position, relative to the left edge of the content area, for the cursor.</td></tr>
    <tr><td class="paramname">yPos</td><td>New y position, relative to the top edge of the content area, for the cursor.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1529285c62e8c39d4320ca56568bd72b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1529285c62e8c39d4320ca56568bd72b">&#9670;&nbsp;</a></span>SetCursorPosCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetCursorPosCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a7cd43357d32c8b5ec04ab8be2117d2d7">CursorPositionFunc</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets the cursor position callback of the specified window, which is called when the cursor is moved. The callback is provided with the position, in screen coordinates, relative to the upper-left corner of the content area of the window. </p>
<p>Errors: Possible errors include Error::Not_Initialized. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to set the callback for.</td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when a cursor position event occurs, or nullptr to remove the currently set callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83fa5c6d2c1ed51704c47293bb61f410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83fa5c6d2c1ed51704c47293bb61f410">&#9670;&nbsp;</a></span>SetDragAndDrop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetDragAndDrop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable/Disable drag and drop feature for the specified window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window for which to set drag and drop.</td></tr>
    <tr><td class="paramname">value</td><td>Whether to enable or disable drag and drop.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c885437b0a8d37dd421e20eb49bf8b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c885437b0a8d37dd421e20eb49bf8b5">&#9670;&nbsp;</a></span>SetDropCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetDropCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#aaf7d4ffac5bb5175661b6811fafc2130">DropFunc</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets the path drop callback of the specified window, which is called when one or more dragged paths are dropped on the window. </p>
<p>Errors: Possible errors include Error::Not_Initialized. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to set the callback for.</td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when a drop even occurs, or nullptr to remove the currently set callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf36bb5e5531cfd900484392258e8563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf36bb5e5531cfd900484392258e8563">&#9670;&nbsp;</a></span>SetFrameBufferSizeCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetFrameBufferSizeCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a1f82bdf5c722c1697a40a01f0a71a363">FrameBufferSizeFunc</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets the framebuffer resize callback of the specified window, which is called when the framebuffer of the specified window is resized. </p>
<p>Errors: Possible errors include Error::Not_Initialized. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to set the callback for.</td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when a framebuffer size event occurs, or nullptr to remove the currently set callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd0292dceae4d119e23a5d7f57197fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd0292dceae4d119e23a5d7f57197fde">&#9670;&nbsp;</a></span>SetKeyCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetKeyCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a54944b816809b9367ef0023540d70bed">KeyFunc</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets the key callback of the specified window, which is called when a key is pressed, repeated or released. </p>
<p>The key functions deal with physical keys, with layout independent key tokens named after their values in the standard US keyboard layout. If oyu want to input text, use the character callback instead.</p>
<p>When a window loses input focus, it will generate synthetic key release events for all pressed keys. You can tell these events from user-generated events by the fact that the synthetic ones are generated after the focus loss event has been processed, i.e. after the window focus callback has been called.</p>
<p>Errors: Possible errors include Error::Not_Initialized. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to set the callback for.</td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when a key event occurs, or nullptr to remove the currently set callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c053e137362b8df0987153ce071bebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c053e137362b8df0987153ce071bebc">&#9670;&nbsp;</a></span>SetMonitorCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetMonitorCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a1489018def8622680eb4cbbe7216ad18">MonitorFunc</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets the monitor configuration callback, or removes the currently set callback. This is called when a monitor is connected to or disconnected from the system. </p>
<p>Errors: Possible errors include Error::Not_Initialized. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to call when a monitor event occurs, or nullptr to remove the currently set callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af00981268810f1483f5f0a19e41b05fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00981268810f1483f5f0a19e41b05fb">&#9670;&nbsp;</a></span>SetMouseButtonCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetMouseButtonCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a69561f5a3240dde706ce9896aaba946e">MouseButtonFunc</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets the mouse button callback of the specified window, which is called when amouse button is pressed or released. </p>
<p>When a window loses input focus, it will generate synthetic mouse button release events for all pressed mouse buttons. You cann tell these events from user-generated events by the fact that the synthetic ones are generated after the focus loss event has been processed, i.e. after the window focus callback has been called.</p>
<p>Errors: Possible errors include Error::Not_Initialized. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to set the callback for.</td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when a mouse button event occurs, or nullptr to remove the currently set callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f896f0a198d2727541c365c82d9727e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f896f0a198d2727541c365c82d9727e">&#9670;&nbsp;</a></span>SetProgress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetProgress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a9b606d91d8dbf66f02e935d2ce38eb3a">ProgressState</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the progress value and state on the taskbar for the specified window. </p>
<p>Errors: Possible errors include Error::Platform_Error and Error::Feature_Unavailable. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to set progress for.</td></tr>
    <tr><td class="paramname">state</td><td>State of progress.</td></tr>
    <tr><td class="paramname">progress</td><td>How much has been completed. Valid values: 0 - 100.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa040d5362b45826d7810d1509016e902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa040d5362b45826d7810d1509016e902">&#9670;&nbsp;</a></span>SetRawMouseMotionMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetRawMouseMotionMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the raw mouse motion mode for the specified window. </p>
<p>If raw (unscaled and unaccelerated) mouse motion is not supported, attempting to set this will emit Error::Feature_Unavailable.</p>
<p>Errors: Possible errors include Error::Not_Initialized, Error::Invalid_Enum, Error::Platform_Error and Error::Feature_Unavailable. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to set raw mouse input for.</td></tr>
    <tr><td class="paramname">enabled</td><td>Whether to enable or disable raw mouse input.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab66502ad6f23906b74e2ca3f32951055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab66502ad6f23906b74e2ca3f32951055">&#9670;&nbsp;</a></span>SetScrollCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetScrollCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#adb5e6705d6868a3a5722ef8c77c71855">ScrollFunc</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets the scroll callback of the specified window, which is called when a scrolling device is used, such as a mouse wheel or scrolling area of a touchpad. </p>
<p>The scroll callback receives all scrolling input, like that from a mouse wheel or a touchpad scrolling area.</p>
<p>Errors: Possible errors include Error::Not_Initialized. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to set the callback for.</td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when a scroll event occurs, or nullptr to remove the currently set callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9e006177ee64553fbbedf4eed692a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e006177ee64553fbbedf4eed692a48">&#9670;&nbsp;</a></span>SetWindowCloseCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetWindowCloseCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ab7ec03c4a779e92189a77d56edec88d9">WindowCloseFunc</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets the close callback of the specified window, which is called when the user attempts to close the window, for example by clicking the close widget in the title bar. </p>
<p>The close flags is set before this callback is called, but you can modify it at any time with <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a1f4a1994d5b7c8702c8cd0875da86507" title="This function sets the value of the close flag of the specified window. This can be used to override ...">WindowingAPI::SetWindowShouldClose</a>.</p>
<p>The close callback is not triggered by <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a9e328cb210eb5f718ee2c00de6cfb3d9" title="This function destroys the specified window. On calling this function, no further callbacks will be c...">WindowingAPI::DestroyWindow</a>.</p>
<p>Errors: Possible errors include Error::Not_Initialized. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to set the callback for.</td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when a close event occurs, or nullptr to remove the currently set callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90fb030142710dcb2742be1224827ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90fb030142710dcb2742be1224827ef2">&#9670;&nbsp;</a></span>SetWindowFocusCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetWindowFocusCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a9b3baebd09cdd0cf9241cef034268aa6">WindowFocusFunc</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets the focus callback of the specified window, which is called when the window gains or loses input focus. </p>
<p>After the focus callback is called for a window that lost input focus, synthetic key and mouse button release events will be generated for all such that had been pressed. For more information, see <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#abd0292dceae4d119e23a5d7f57197fde" title="This function sets the key callback of the specified window, which is called when a key is pressed,...">WindowingAPI::SetKeyCallback</a> and <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#af00981268810f1483f5f0a19e41b05fb" title="This function sets the mouse button callback of the specified window, which is called when amouse but...">WindowingAPI::SetMouseButtonCallback</a>.</p>
<p>Errors: Possible errors include Error::Not_Initialized. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to set the callback for.</td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when a focus event occurs, or nullptr to remove the currently set callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ef2e9bd606f13138ed28fd47de7a808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef2e9bd606f13138ed28fd47de7a808">&#9670;&nbsp;</a></span>SetWindowHint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetWindowHint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a9954c68c97c88cc331aaf4f0c411880f">Hint</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets the value of a hint of the specified window. </p>
<p>Some of these hints are ignored for full screen windows. The new value will take effect if the window is later made windowed.</p>
<p>Some of these hints are ignored for windowed mode windows. The new value will take effect if the window is later made full screen.</p>
<p>Errors: Possible errors include Error::Not_Initialized, Error::Invaild_Enum, Error::Invalid_Value and Error::Platform_Error. Remarks: Calling <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a7afe253638a8ba50307659637b98db24" title="This function returns the value of a hint of the specified window.">WindowingAPI::GetWindowHint</a> will always return the latest value, even if that value is ignored by the current mode of the window. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to set the hint for.</td></tr>
    <tr><td class="paramname">hint</td><td>Hint to be set.</td></tr>
    <tr><td class="paramname">value</td><td>Value for the hint.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1293d678be77c6cc842d72c099b10ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1293d678be77c6cc842d72c099b10ac">&#9670;&nbsp;</a></span>SetWindowIcon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetWindowIcon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_r_a_p_1_1_image.html">Image</a> *const&#160;</td>
          <td class="paramname"><em>image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets the icon of the specified window. If no image is specified, the window reverts to its default icon. </p>
<p>The image mustbe RGB 24BPP or RGBA 32BPP.</p>
<p>The desired image size varies depending on platform and system settings. Good sizes include 16x16, 32x32 and 48x48.</p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window whose icon to set.</td></tr>
    <tr><td class="paramname">image</td><td><a class="el" href="class_t_r_a_p_1_1_image.html" title="Abstract image base class.">Image</a> to be set as window icon or nullptr to revert back to the default icon. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f9755f61931f8d385836cf1012f086a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9755f61931f8d385836cf1012f086a">&#9670;&nbsp;</a></span>SetWindowMaximizeCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetWindowMaximizeCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a533d75518c031574c4c4f7b7633bb18b">WindowMaximizeFunc</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets the maximization callback of the specified window, which is called when the window is maximized or restored. </p>
<p>Errors: Possible errors include Error::Not_Initialized. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to set the callback for.</td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when a maximize event occurs, or nullptr to remove the currently set callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab9d27e023bf4713eead53b6677d8f04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9d27e023bf4713eead53b6677d8f04">&#9670;&nbsp;</a></span>SetWindowMinimizeCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetWindowMinimizeCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a2f4ad5b36e4a07e27a8a35f4b4d50e73">WindowMinimizeFunc</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets the minimization/iconification callback of the specified window, which is called when the window is minimized/iconified or restored. </p>
<p>Errors: Possible errors include Error::Not_Initialized. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to set the callback for.</td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when a minimize event occurs, or nullptr to remove the currently set callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f96e4cca3c0803d973323244c40947e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f96e4cca3c0803d973323244c40947e">&#9670;&nbsp;</a></span>SetWindowMonitor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetWindowMonitor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_monitor.html">InternalMonitor</a> *&#160;</td>
          <td class="paramname"><em>monitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>xPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>yPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>refreshRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets the monitor that the window uses for full screen mode or, if the monitor is nullptr, makes it windowed mode. </p>
<p>When setting a monitor, this function updates the width, height and refresh rate of the desired video mode and switches to the video mode closest to it. The window position is ignored when setting a monitor.</p>
<p>When the monitor is nullptr, the position, width and height are used to place the window content area. The refresh rate is ignored when no monitor is specified.</p>
<p>If you only wish to update the resolution of a full screen window or the size of a windowed mode window, see <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a3195c57fc4340a1319d0e3b0bd90e88c" title="This function sets the size, in screen coordinates, of the content area of the specified window.">WindowingAPI::SetWindowSize</a>.</p>
<p>When a window transitions from full screen to windowed mode, this function restores any previous window settings such as whether it is decorated, floating, resizable, has size limits, etc.</p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to set the monitor for.</td></tr>
    <tr><td class="paramname">monitor</td><td>Internal monitor to use or nullptr.</td></tr>
    <tr><td class="paramname">xPos</td><td>New x position for the window.</td></tr>
    <tr><td class="paramname">yPos</td><td>New y position for the window.</td></tr>
    <tr><td class="paramname">width</td><td>New width for the window.</td></tr>
    <tr><td class="paramname">height</td><td>New height for the window.</td></tr>
    <tr><td class="paramname">refreshRate</td><td>New refresh rate for the window.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1e22e8d9f9e75eeb7292e115a2a5434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e22e8d9f9e75eeb7292e115a2a5434">&#9670;&nbsp;</a></span>SetWindowMonitorBorderless()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetWindowMonitorBorderless </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_monitor.html">InternalMonitor</a> *&#160;</td>
          <td class="paramname"><em>monitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets the monitor that the window uses for borderless full screen mode. </p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to set the monitor for.</td></tr>
    <tr><td class="paramname">monitor</td><td>Internal monitor to use.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2011a2e5904d06e83dbf685eb58310d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2011a2e5904d06e83dbf685eb58310d">&#9670;&nbsp;</a></span>SetWindowOpacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetWindowOpacity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets the opacity of the window, including any decorations. </p>
<p>The opacity (or alpha) value is a positive finite number between zero and one, where zero is fully transparent and one is fully opaque.</p>
<p>The initial opacity value for newly created windows is 1.0f.</p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to set opacity for.</td></tr>
    <tr><td class="paramname">opacity</td><td>Opacity ranging from 0.0f-1.0f.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a477697a35069a59c31d19976921da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a477697a35069a59c31d19976921da0">&#9670;&nbsp;</a></span>SetWindowPos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetWindowPos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>xPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>yPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets the position, in screen coordinates, of the upper-left corner of the content area of the specifed windowed mode window. If the window is a full screen window, this function does nothing. </p>
<p>DO NOT USE THIS FUNCTION to move an already visible window unless you have very good reasons for doing so, as it will confuse and annoy the user.</p>
<p>The window manager may put limits on what positions are allowed. The <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> cannot and should not override these limits.</p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to set the position for.</td></tr>
    <tr><td class="paramname">xPos</td><td>X position to be set.</td></tr>
    <tr><td class="paramname">yPos</td><td>Y position to be set.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74ccced281894c7ba9d6cf9f195caf89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ccced281894c7ba9d6cf9f195caf89">&#9670;&nbsp;</a></span>SetWindowPosCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetWindowPosCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a0e3e0a36774707778dc300a55f725d8f">WindowPositionFunc</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets the position callback of the specified window, which is called when the window is moved. The callback is provided with the position, in screen coordinates, of the upper-left corner of the content area of the window. </p>
<p>Errors: Possible errors include Error::Not_Initialized. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to set the callback for.</td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when a position event occurs, or nullptr to remove the currently set callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f4a1994d5b7c8702c8cd0875da86507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f4a1994d5b7c8702c8cd0875da86507">&#9670;&nbsp;</a></span>SetWindowShouldClose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetWindowShouldClose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets the value of the close flag of the specified window. This can be used to override the user's attempt to close the window, or to signal that it should be closed. </p>
<p>Errors: Possible errors include Error::Not_Initialized. Thread safety: This function may be called from any thread. Access is not synchronized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window whose flag to change.</td></tr>
    <tr><td class="paramname">value</td><td>Whether to close the window or not.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3195c57fc4340a1319d0e3b0bd90e88c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3195c57fc4340a1319d0e3b0bd90e88c">&#9670;&nbsp;</a></span>SetWindowSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetWindowSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets the size, in screen coordinates, of the content area of the specified window. </p>
<p>For full screen windows, this function updates the resolution of its desired video mode and switches to the video mdoe closest to it.</p>
<p>If you wish to update the refresh rate of the desired video mode in addition to its resolution, see <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a0f96e4cca3c0803d973323244c40947e" title="This function sets the monitor that the window uses for full screen mode or, if the monitor is nullpt...">WindowingAPI::SetWindowMonitor</a>.</p>
<p>The window manager may put limits on what sizes are allowed. The <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> cannot and should not override these limits.</p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to set the size for.</td></tr>
    <tr><td class="paramname">width</td><td>New width for the internal window.</td></tr>
    <tr><td class="paramname">height</td><td>New height for the internal window.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a792e42065f58e7ae9dd094f5a12cdb01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a792e42065f58e7ae9dd094f5a12cdb01">&#9670;&nbsp;</a></span>SetWindowSizeCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetWindowSizeCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a322ac85a2956a17244a7e0ea923bbad4">WindowSizeFunc</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets the size callback of the specified window, which is called when the window is resized. The callback is provided with the size, in screen coordinates, of the content area of the window. </p>
<p>Errors: Possible errors include Error::Not_Initialized. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to set the callback for.</td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when a size event occurs, or nullptr to remove the currently set callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af26609f5ffd299da72d0855cd1c7ea2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26609f5ffd299da72d0855cd1c7ea2e">&#9670;&nbsp;</a></span>SetWindowSizeLimits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetWindowSizeLimits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>minWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>minHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>maxWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>maxHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the size limits of the specified window. </p>
<p>Wayland: The size limits will not be applied until the window is actually resized, either by the user or by the compositor. This function sets the size limits of the content area of the specified window. If the window is full screen, the size limits only take effect once it is made windowed. If the window is not resizable, this function does nothing.</p>
<p>The size limits are applied immediately to a windowed mode window and may cause it to be resized.</p>
<p>The maximum dimensions must be greater than or equal to the minimum dimensions and all must be greater than zero.</p>
<p>Use -1 to disable to minimum and/or maximum size constraints.</p>
<p>Errors: Possible errors include Error::Not_Initialized, Error::Invalid_Value and Error::Platform_Error. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to set size limits for.</td></tr>
    <tr><td class="paramname">minWidth</td><td>New minimum window width.</td></tr>
    <tr><td class="paramname">minHeight</td><td>New minimum window height.</td></tr>
    <tr><td class="paramname">maxWidth</td><td>New maximum window width.</td></tr>
    <tr><td class="paramname">maxHeight</td><td>New maximum window height.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51b562b134bc6b2e68e645b05e555ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51b562b134bc6b2e68e645b05e555ecd">&#9670;&nbsp;</a></span>SetWindowTitle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetWindowTitle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>title</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets the window title, encoded as UTF-8, of the specified window. </p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window whose title to change.</td></tr>
    <tr><td class="paramname">title</td><td>New UTF-8 encoded title for the window.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe28ac371b241d255fac992d8f616f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe28ac371b241d255fac992d8f616f1b">&#9670;&nbsp;</a></span>SetWindowUserPointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::SetWindowUserPointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pointer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets the user-define dpointer of the specified window. The current value is retained until the window is destroyed. The initial value is nullptr. </p>
<p>Errors: Possible errors include Error::Not_Initialized. Thread safety: This function may be called from any thread. Access is not synchronized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to set the user pointer for.</td></tr>
    <tr><td class="paramname">pointer</td><td>Data to be stored with the window.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a620187132ad11295feed29d8aa2d617e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620187132ad11295feed29d8aa2d617e">&#9670;&nbsp;</a></span>ShowWindow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::ShowWindow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i_1_1_internal_window.html">InternalWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function makes the specified window visible if it was previously hidden. If the window is already visible or is in full screen mode, this function does nothing. </p>
<p>By default, windowed mode window are focused when shown. Set the Hint::FocusOnShow window hint to change this behaviour for all newly created windows, or change the behaviour for and existing window with <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a4ef2e9bd606f13138ed28fd47de7a808" title="This function sets the value of a hint of the specified window.">WindowingAPI::SetWindowHint</a>.</p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Platform_Error. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Internal window to display.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae02cae073fb368da7ad98217d56f61dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae02cae073fb368da7ad98217d56f61dd">&#9670;&nbsp;</a></span>Shutdown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::Shutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function destroys all remaining windows and cursor, and frees any other allocated resources. Once this function is called, you must again call <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#abfe0c61f9e9210e6b2f3532ba9f59eda" title="Initializes the windowing API. Before most WindowingAPI functions can be used, the WindowingAPI must ...">WindowingAPI::Init</a> successfully before you will be able to use most <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> functions. </p>
<p>If the <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> has been successfully initialized, this function should be called before the engine exits. If initialization fails, there is no need to call this function, as it is called by <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#abfe0c61f9e9210e6b2f3532ba9f59eda" title="Initializes the windowing API. Before most WindowingAPI functions can be used, the WindowingAPI must ...">WindowingAPI::Init</a> before it returns failure. This function has no effect if the <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html">WindowingAPI</a> is not initialized.</p>
<p>Possible errors include Error::Platform_Error.</p>
<p>Remarks: This function may be called before <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#abfe0c61f9e9210e6b2f3532ba9f59eda" title="Initializes the windowing API. Before most WindowingAPI functions can be used, the WindowingAPI must ...">WindowingAPI::Init</a>. Reentrancy: This function must not be called from a callback. Thread safety: This function must only be called from the main thread.</p>

</div>
</div>
<a id="a4a62ae75f1affade038ed963c4920282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a62ae75f1affade038ed963c4920282">&#9670;&nbsp;</a></span>VulkanSupported()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool TRAP::INTERNAL::WindowingAPI::VulkanSupported </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns whether the Vulkan loader and any minimally function ICD have been found. </p>
<p>The availability of a Vulkan loader and even an ICD does not by itself guarantee that surface creation or even instance creation is possible. Call GetRequiredInstanceExtensions to check whether the extensions necessary for Vulkan surface creation are available. You still have to check whether a queue family of a physical device supports image presentation.</p>
<p>Errors: Possible errors include Error::Not_Initialized. Thread safety: This function may be called from any thread.</p>
<dl class="section return"><dt>Returns</dt><dd>True if Vulkan API is minimally supported, false otherwise.</dd></dl>

</div>
</div>
<a id="ac70fe8b8aff78b19f5a9513f34ef40d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70fe8b8aff78b19f5a9513f34ef40d3">&#9670;&nbsp;</a></span>WindowHint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TRAP::INTERNAL::WindowingAPI::WindowHint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a9954c68c97c88cc331aaf4f0c411880f">Hint</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets hints for the next call to <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#a2bc5abcc39d624e70235389d10e4ff08" title="This function creates a window. Most of the options controlling how the window should be created are ...">WindowingAPI::CreateWindow</a>. The hints, once set, retain their values until changed by a call to this function or <a class="el" href="class_t_r_a_p_1_1_i_n_t_e_r_n_a_l_1_1_windowing_a_p_i.html#ad07bcde6cdb37ecc49d697114fbdd2f1" title="Resets all window hints to their default values.">WindowingAPI::DefaultWindowHints</a>, or until the engine is terminated. </p>
<p>Some hints are platform specific. These may be set on any platform but they will only affect their specific platform. Other platforms will ignore them. Setting these hints requires no platform specific headers or functions.</p>
<p>Errors: Possible errors include Error::Not_Initialized and Error::Invalid_Enum. Thread safety: This function must only be called from the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>Hint to set.</td></tr>
    <tr><td class="paramname">value</td><td>Value to set for the Hint.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/media/gamestrap/Programming/C++/TRAPVK-Alpha/TRAP/src/Window/<a class="el" href="_windowing_a_p_i_8h_source.html">WindowingAPI.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<div class="footer">
  <div class="footer-copyright">
    &copy; Copyright 2020 Jan "GamesTrap" Schürkamp All Rights Reserved
  </div>
</div>
</body>
</html>
