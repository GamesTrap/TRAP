#ifndef TRAP_RANDOM_H
#define TRAP_RANDOM_H

#include <random>
#include <algorithm>

#include "RandomInternal.h"
#include "Core/Base.h"
#include "TRAP_Assert.h"
#include "Utils/NumericCasts.h"

namespace TRAP::Utils
{
    /// @brief Default seeder for 'Random' classes.
    struct SeederDefault
    {
        /// @brief Use std::seed_seq with additional seed from C++ chrono.
        /// @return Seed sequence.
        std::seed_seq& operator()() noexcept
        {
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return SeedSeq;
        }

    private:
        std::seed_seq SeedSeq
        { {
                NumericCast<std::uintmax_t>(std::random_device{ }()),
                NumericCast<std::uintmax_t>(std::chrono::steady_clock::now().time_since_epoch().count())
        } };
    };

    /// @brief Base template class for random with static API and static internal member storage.
    /// @tparam engine A random engine with interface like in the std::mt19937.
    /// @tparam Seeder A seeder type which return seed for internal engine through operator().
    /// @threadsafety This is NOT thread safe but more efficient than BasicRandomThreadLocal.
    template<typename engine,
             typename Seeder = SeederDefault,
             template<typename> class IntegerDist = std::uniform_int_distribution,
             template<typename> class RealDist = std::uniform_real_distribution,
             typename BoolDist = std::bernoulli_distribution>
    class BasicRandomStatic
	{
    public:
        /// @brief Constructor.
        constexpr BasicRandomStatic() = delete;
    	/// @brief Destructor.
        constexpr ~BasicRandomStatic() = delete;
        /// @brief Copy constructor.
        consteval BasicRandomStatic(const BasicRandomStatic&) = delete;
        /// @brief Copy assignment operator.
        consteval BasicRandomStatic operator=(const BasicRandomStatic&) = delete;
        /// @brief Move constructor.
        consteval BasicRandomStatic(BasicRandomStatic&&) noexcept = delete;
        /// @brief Move assignment operator.
        consteval BasicRandomStatic operator=(BasicRandomStatic&&) noexcept = delete;

        /// @brief Type of used random number engine.
        using EngineType = engine;

        /// @brief Type of used random number seeder.
        using SeederType = Seeder;

        /// @brief Type of used integer distribution.
        /// @tparam T Integer type.
        template<typename T>
        using IntegerDistT = IntegerDist<T>;

        /// @brief Type of used real distribution.
        /// @tparam T Float/Double type.
        template<typename T>
        using RealDistT = RealDist<T>;

        /// @brief Type of used bool distribution.
        using BoolDistT = BoolDist;

        /// @brief Key type for getting common type numbers or objects.
        using Common = INTERNAL::Common;

        /// @brief Retrieve the minimum value potentially generated by the random-number engine.
        /// @return Minimum value.
        [[nodiscard]] static constexpr typename engine::result_type Min()
    	{
            return engine::min();
        }

        /// @brief Retrieve the maximum value potentially generated by the random-number engine.
        /// @return Maximum value.
        [[nodiscard]] static constexpr typename engine::result_type Max()
    	{
            return engine::max();
        }

        /// @brief Advances the internal state by z times.
        /// @param z How many times to advance.
        static void Discard(const u64 z)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            EngineInstance().discard(z);
        }

        /// @brief Reseed by seeder.
        static void Reseed()
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            const Seeder seeder;
            Seed(seeder());
        }

        /// @brief Re-Initializes the internal state of the random-number engine using new seed value.
        /// @param value Seed value to use in the initialization of the internal state.
        static void Seed(const typename engine::result_type value =
            engine::default_seed)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            EngineInstance().seed(value);
        }

        /// @brief Re-Initializes the internal state of the random-number engine using new seed value.
        /// @tparam SSeq Seed sequence.
        /// @param seq Seed sequence to use in the initialization of the internal state
        template<typename SSeq>
        static void Seed(SSeq& seq)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            EngineInstance().seed(seq);
        }

        /// @brief Get a random number from engine in [Min(), Max()] range.
        /// @return Random number.
        [[nodiscard]] static typename engine::result_type Get()
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return EngineInstance()();
        }

        /// @brief Compares internal pseudo-random number engine with 'other' pseudo-random number engine.
        /// Two engines are equal, if their internal states are equivalent, that is, if they would generate
        /// equivalent values for any number of calls of operator().
        /// @param other Engine, with which the internal engine will be compared.
        /// @return True, if other and internal engine are equal.
        [[nodiscard]] static bool IsEqual(const engine& other)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return EngineInstance() == other;
        }

        /// @brief Serializes the internal state of the internal pseudo-random number engine as a sequence
        /// of decimal numbers separated by one or more spaces, and inserts it to the stream ost.
        /// The fill character and the formatting flags of the stream are ignored and unaffected.
        /// @param ost Output stream to insert the data to.
        template<typename CharT, typename Traits>
        static void Serialize(std::basic_ostream<CharT, Traits>& ost)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            ost << EngineInstance();
        }

        /// @brief Restores the internal state of the internal pseudo-random number engine from
        /// the serialized representation, which was created by an earlier call to 'Serialize'
        /// using a stream with the same imbued locale and the same CharT and Traits.
        /// If the input cannot be deserialized, internal engine is left unchanged and fail-Bit is raised on ist.
        /// @param ist Input stream to extract the data from.
        template<typename CharT, typename Traits>
        static void Deserialize(std::basic_istream<CharT, Traits>& ist)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            ist >> EngineInstance();
        }

        /// @brief Generate a random integer number in a [from; to] range by std::uniform_int_distribution.
        /// @param from First limit number of a random range.
        /// @param to Second limit number of a random range.
        /// @return A random integer number in a [from; to] range.
        template<typename T>
        requires INTERNAL::IsUniformInt<T>
        [[nodiscard]] static T Get(T from = std::numeric_limits<T>::min(), T to = std::numeric_limits<T>::max())
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            if (from < to) //Allow range from higher to lower
                return IntegerDist<T>{ from, to }(EngineInstance());

            return IntegerDist<T>{ to, from }(EngineInstance());
        }

        /// @brief Generate a random real number in a [from; to] range by std::uniform_real_distribution.
        /// @param from First limit number of a random range.
        /// @param to Second limit number of a random range.
        /// @return A random real number in a [from; to] range.
        template<typename T>
        requires INTERNAL::IsUniformReal<T>
        [[nodiscard]] static T Get(T from = std::numeric_limits<T>::min(), T to = std::numeric_limits<T>::max())
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            if (from < to) //Allow range from higher to lower
                return RealDist<T>{ from, to }(EngineInstance());

            return RealDist<T>{ to, from }(EngineInstance());
        }

        /// @brief Generate a random byte number in a [from; to] range.
        /// @param from First limit number of a random range.
        /// @param to Second limit number of a random range.
        /// @return A random byte number in a [from; to] range.
        template<typename T>
        requires INTERNAL::IsByte<T>
        [[nodiscard]] static T Get(T from = std::numeric_limits<T>::min(), T to = std::numeric_limits<T>::max())
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            //Choose between i16 and u16 for byte conversion
            using short_t = typename std::conditional<std::is_signed<T>::value,
                                                      i16, u16>::type;

            return static_cast<T>(Get<short_t>(from, to));
        }

        /// @brief Generate a random common_type number in a [from; to] range.
        /// @tparam Key Key type for this version of 'Get' method Type should be '(THIS_TYPE)::Common' struct.
        /// @param from First limit number of a random range.
        /// @param to Second limit number of a random range.
        /// @return A random common_type number in a [from; to] range.
        template<typename Key,
                 typename A,
                 typename B,
                 typename C = typename std::common_type<A, B>::type>
        requires (std::same_as<Key, Common> && INTERNAL::IsSupportedNumber<A> &&
                  INTERNAL::IsSupportedNumber<B> && std::is_signed_v<A> != std::is_unsigned_v<B>)
        [[nodiscard]] static C Get(A from = std::numeric_limits<A>::min(), B to = std::numeric_limits<B>::max())
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return Get(static_cast<C>(from), static_cast<C>(to));
        }

        /// @brief Generate a random character in a [from; to] range by std::uniform_int_distribution.
        /// @param from First limit number of a random range.
        /// @param to Second limit number of a random range.
        /// @return A random character in a [from; to] range.
        template<typename T>
        requires INTERNAL::IsSupportedCharacter<T>
        [[nodiscard]] static T Get(T from = std::numeric_limits<T>::min(), T to = std::numeric_limits<T>::max())
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            if (from < to) //Allow range from higher to lower
                return static_cast<T>(IntegerDist<i64>{ static_cast<i64>(from),
                                                                 static_cast<i64>(to) }(EngineInstance()));

            return static_cast<T>(IntegerDist<i64>{ static_cast<i64>(to),
                                                             static_cast<i64>(from) }(EngineInstance()));
        }

        /// @brief Generate a bool value with specific probability by std::bernoulli_distribution.
        /// @param probability Probability of generating true in [0; 1] range 0 means always false, 1 means always true.
        /// @return 'true' with 'probability' probability ('false' otherwise).
        template<typename T>
        requires std::same_as<T, bool>
        [[nodiscard]] static bool Get(const f64 probability = 0.5)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            TRAP_ASSERT(0 <= probability && 1 >= probability, "BasicRandomStatic::Get(): Out of range!"); //Out of [0; 1] range
            return BoolDist{ probability }(EngineInstance());
        }

        /// @brief Get random value from initializer_list.
        /// Should be 1 or more elements in initializer_list.
        /// @param init_list Initializer_list with values.
        /// @return Random value from initializer_list.
        /// @note Elements in initializer_list can't be moved!
        template<typename T>
        [[nodiscard]] static T Get(std::initializer_list<T> init_list)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            TRAP_ASSERT(0u != init_list.size(), "BasicRandomStatic::Get(): Empty initializer_list!"); //Empty initializer_list
            return *Get(init_list.begin(), init_list.end());
        }

        /// @brief Get random iterator from iterator range.
        /// @param first Range of elements.
        /// @param last Range of elements.
        /// @return Random iterator from [first, last) range.
        template<typename InputIt>
        requires INTERNAL::IsIterator<InputIt>::value
        [[nodiscard]] static InputIt Get(InputIt first, InputIt last)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            const auto size = std::distance(first, last);
            if (0 == size)
                return last;
            using diff_t = typename std::iterator_traits<InputIt>::difference_type;
            return std::next(first, Get<diff_t>(0, size - 1));
        }

        /// @brief Get random iterator from container.
        /// @param container Container with elements.
        /// @return Random iterator from container.
        template<typename Container>
        requires requires (Container& container) {INTERNAL::IsIterator<decltype(std::begin(container))>::value; }
        [[nodiscard]] static decltype(Container::iterator) Get(Container& container)
        {
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return Get(std::begin(container), std::end(container));
        }

        /// @brief Get random pointer from built-in array.
        /// @param array Built-in array with elements.
        /// @return Pointer to random element in array.
        template<typename T, usize N>
        [[nodiscard]] static T* Get(T(&array)[N])
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return std::addressof(array[Get<usize>(0, N - 1)]);
        }

        /// @brief Get value from custom dist distribution seeded by internal random engine.
        /// @tparam Dist Type of custom distribution with next concept.
        /// @tparam Args Arguments which will be forwarded to dist constructor.
        /// @return Value from custom distribution.
        template<typename Dist, typename... Args>
        [[nodiscard]] static typename Dist::result_type Get(Args&&... args)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return Dist{ std::forward<Args>(args)... }(EngineInstance());
        }

        /// @brief Get value from custom 'dist' distribution seeded by internal random engine.
        /// @param dist Custom distribution with next concept
        /// @return Value from custom 'dist' distribution
        template<typename Dist>
        [[nodiscard]] static typename Dist::result_type Get(Dist& dist)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return dist(EngineInstance());
        }

        /// @brief Reorders the elements in the given range [first, last) such that each possible permutation
        /// of those elements has equal probability of appearance.
        /// @param first Range of elements to shuffle randomly.
        /// @param last Range of elements to shuffle randomly.
        template<typename RandomIt>
        static void Shuffle(RandomIt first, RandomIt last)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            std::shuffle(first, last, EngineInstance());
        }

        /// @brief Reorders the elements in the given container such that each possible permutation of those elements
        /// has equal probability of appearance.
        /// @param container Container with elements to shuffle randomly.
        template<typename Container>
        static void Shuffle(Container& container)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            Shuffle(std::begin(container), std::end(container));
        }

        /// @brief Get internal engine by copy.
        /// @return Internal engine.
        [[nodiscard]] static engine GetEngine()
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return EngineInstance();
        }

        /// @brief Get internal engine by reference,
        /// @return Internal engine.
        [[nodiscard]] static engine& Engine()
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return EngineInstance();
        }

    protected:
        /// @brief Get reference to the static engine instance.
        /// @return Static engine instance.
        [[nodiscard]] static engine& EngineInstance()
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            static engine Engine{ Seeder{ }() };
            return Engine;
        }
    };

    /// @brief Base template class for random with thread_local API and thread_local internal member storage.
    /// @tparam engine A random engine with interface like in the std::mt19937.
    /// @tparam Seeder A seeder type which return seed for internal engine through operator().
    /// @threadsafety This IS thread safe but less efficient than BasicRandomStatic.
    template<typename engine,
             typename Seeder = SeederDefault,
             template<typename> class IntegerDist = std::uniform_int_distribution,
             template<typename> class RealDist = std::uniform_real_distribution,
             typename BoolDist = std::bernoulli_distribution>
    class BasicRandomThreadLocal
	{
    public:
        /// @brief Constructor.
        constexpr BasicRandomThreadLocal() = delete;
        /// @brief Destructor.
        constexpr ~BasicRandomThreadLocal() = delete;
        /// @brief Copy constructor.
        consteval BasicRandomThreadLocal(const BasicRandomThreadLocal&) = delete;
        /// @brief Copy assignment operator.
        consteval BasicRandomThreadLocal operator=(const BasicRandomThreadLocal&) = delete;
        /// @brief Move constructor.
        consteval BasicRandomThreadLocal(BasicRandomThreadLocal&&) noexcept = delete;
        /// @brief Move assignment operator.
        consteval BasicRandomThreadLocal operator=(BasicRandomThreadLocal&&) noexcept = delete;

        /// @brief Type of used random number engine.
        using EngineType = engine;

        /// @brief Type of used random number seeder.
        using SeederType = Seeder;

        /// @brief Type of used integer distribution
        template<typename T>
        using IntegerDistT = IntegerDist<T>;

        /// @brief Type of used real distribution
        template<typename T>
        using RealDistT = RealDist<T>;

        /// @brief Type of used bool distribution.
        using BoolDistT = BoolDist;

        /// @brief Key type for getting common type numbers or objects.
        using Common = INTERNAL::Common;

        /// @brief Retrieve the minimum value potentially generated by the random-number engine.
        /// @return Minimum value.
        [[nodiscard]] static constexpr typename engine::result_type Min()
        {
            return engine::min();
        }

        /// @brief Retrieve the maximum value potentially generated by the random-number engine.
        /// @return Maximum value.
        [[nodiscard]] static constexpr typename engine::result_type Max()
    	{
            return engine::max();
        }

        /// @brief Advances the internal state by z times.
        /// @param z How many times to advance.
        static void Discard(const u64 z)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            EngineInstance().discard(z);
        }

        /// @brief Reseed by seeder.
        static void Reseed()
        {
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            const Seeder seeder;
            Seed(seeder());
        }

        /// @brief Re-Initializes the internal state of the random-number engine using new seed value.
        /// @param value Seed value to use in the initialization of the internal state.
        static void Seed(const typename engine::result_type value = engine::default_seed)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            EngineInstance().seed(value);
        }

        /// @brief Re-Initializes the internal state of the random-number engine using new seed value.
        /// @param seq Seed sequence to use in the initialization of the internal state.
        template<typename SSeq>
        static void Seed(SSeq& seq)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            EngineInstance().seed(seq);
        }

        /// @brief Retrieve a random number from engine in [min(), max()] range.
        /// @return Random number.
        [[nodiscard]] static typename engine::result_type Get()
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return EngineInstance()();
        }

        /// @brief Compares internal pseudo-random number engine with 'other' pseudo-random number engine.
        /// Two engines are equal, if their internal states are equivalent, that is, if they would generate
        /// equivalent values for any number of calls of operator().
        /// @param other Engine, with which the internal engine will be compared.
        /// @return True if other and internal engine are equal, false otherwise
        [[nodiscard]] static bool IsEqual(const engine& other)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return EngineInstance() == other;
        }

        /// @brief Serializes the internal state of the internal pseudo-random number engine as a sequence
        /// of decimal numbers separated by one or more spaces, and inserts it to the stream ost.
        /// The fill character and the formatting flags of the stream are ignored and unaffected.
        /// @param ost Output stream to insert the data to.
        template<typename CharT, typename Traits>
        static void Serialize(std::basic_ostream<CharT, Traits>& ost)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            ost << EngineInstance();
        }

        /// @brief Restores the internal state of the internal pseudo-random number engine from
        /// the serialized representation, which was created by an earlier call to 'Serialize'
        /// using a stream with the same imbued locale and the same CharT and Traits.
        /// If the input cannot be deserialized, internal engine is left unchanged and fail-Bit is raised on ist.
        /// @param ist Input stream to extract the data from.
        template<typename CharT, typename Traits>
        static void Deserialize(std::basic_istream<CharT, Traits>& ist)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            ist >> EngineInstance();
        }

        /// @brief Generate a random integer number in a [from; to] range by std::uniform_int_distribution.
        /// @param from First limit number of a random range.
        /// @param to Second limit number of a random range.
        /// @return Random integer number in a [from; to] range.
        template<typename T>
        requires INTERNAL::IsUniformInt<T>
        [[nodiscard]] static T Get(T from = std::numeric_limits<T>::min(), T to = std::numeric_limits<T>::max())
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            if (from < to) //Allow range from higher to lower
                return IntegerDist<T>{ from, to }(EngineInstance());

            return IntegerDist<T>{ to, from }(EngineInstance());
        }

        /// @brief Generate a random real number in a [from; to] range by std::uniform_real_distribution.
        /// @param from First limit number of a random range
        /// @param to Second limit number of a random range.
        /// @return Random real number in a [from; to] range.
        template<typename T>
        requires INTERNAL::IsUniformReal<T>
        [[nodiscard]] static T Get(T from = std::numeric_limits<T>::min(), T to = std::numeric_limits<T>::max())
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            if (from < to) //Allow range from higher to lower
                return RealDist<T>{ from, to }(EngineInstance());

            return RealDist<T>{ to, from }(EngineInstance());
        }

        /// @brief Generate a random byte number in a [from; to] range.
        /// @param from First limit number of a random range.
        /// @param to Second limit number of a random range.
        /// @return Random byte number in a [from; to] range.
        template<typename T>
        requires INTERNAL::IsByte<T>
        [[nodiscard]] static T Get(T from = std::numeric_limits<T>::min(), T to = std::numeric_limits<T>::max())
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            //Choose between i16 and u16 for byte conversion
            using short_t = typename std::conditional<std::is_signed<T>::value,
                i16, u16>::type;

            return static_cast<T>(Get<short_t>(from, to));
        }

        /// @brief Generate a random common_type number in a [from; to] range.
        /// @tparam Key The Key type for this version of 'get' method Type should be '(THIS_TYPE)::Common' struct.
        /// @param from First limit number of a random range.
        /// @param to Second limit number of a random range.
        /// @return Random common_type number in a [from; to] range.
        template<typename Key,
                 typename A,
                 typename B,
                 typename C = typename std::common_type<A, B>::type>
        requires (std::same_as<Key, Common> && INTERNAL::IsSupportedNumber<A> &&
                  INTERNAL::IsSupportedNumber<B> && std::is_signed_v<A> != std::is_unsigned_v<B>)
        [[nodiscard]] static C Get(A from = std::numeric_limits<A>::min(), B to = std::numeric_limits<B>::max())
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return Get(static_cast<C>(from), static_cast<C>(to));
        }

        /// @brief Generate a random character in a [from; to] range by std::uniform_int_distribution.
        /// @param from First limit number of a random range.
        /// @param to Second limit number of a random range.
        /// @return Random character in a [from; to] range.
        template<typename T>
        requires INTERNAL::IsSupportedCharacter<T>
        [[nodiscard]] static T Get(T from = std::numeric_limits<T>::min(), T to = std::numeric_limits<T>::max())
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            if (from < to) //Allow range from higher to lower
                return static_cast<T>(IntegerDist<i64>{ static_cast<i64>(from),
                                                                 static_cast<i64>(to) }(EngineInstance()));

            return static_cast<T>(IntegerDist<i64>{ static_cast<i64>(to),
                                                             static_cast<i64>(from) }(EngineInstance()));
        }

        /// @brief Generate a bool value with specific probability by std::bernoulli_distribution.
        /// @param probability Probability of generating true in [0; 1] range 0 means always false, 1 means always true.
        /// @return 'True' with 'probability' probability ('False' otherwise).
        template<typename T>
        requires std::same_as<T, bool>
        [[nodiscard]] static bool Get(const f64 probability = 0.5)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            TRAP_ASSERT(0 <= probability && 1 >= probability, "BasicRandomThreadLocal::Get(): Out of range!"); //Out of [0; 1] range
            return BoolDist{ probability }(EngineInstance());
        }

        /// @brief Retrieve a random value from initializer_list.
        /// @param init_list initializer_list with values.
        /// @return Random value from initializer_list.
        template<typename T>
        [[nodiscard]] static T Get(std::initializer_list<T> init_list)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            TRAP_ASSERT(0u != init_list.size(), "BasicRandomThreadLocal::Get(): Empty initializer_list!"); //Empty initializer_list
            return *Get(init_list.begin(), init_list.end());
        }

        /// @brief Retrieve a random iterator from iterator range.
        /// @param first Range of elements.
        /// @param last Range of elements.
        /// @return Random iterator from [first, last) range.
        template<typename InputIt>
        requires INTERNAL::IsIterator<InputIt>::value
        [[nodiscard]] static InputIt Get(InputIt first, InputIt last)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            const auto size = std::distance(first, last);
            if (0 == size)
                return last;
            using diff_t = typename std::iterator_traits<InputIt>::difference_type;
            return std::next(first, Get<diff_t>(0, size - 1));
        }

        /// @brief Retrieve a random iterator from container.
        /// @param container Container with elements.
        /// @return Random iterator from container.
        template<typename Container>
        requires requires (Container& container) {INTERNAL::IsIterator<decltype(std::begin(container))>::value;}
        [[nodiscard]] static Container::iterator Get(Container& container)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return Get(std::begin(container), std::end(container));
        }

        /// @brief Retrieve a random pointer from built-in array.
        /// @param array Built-in array with elements
        /// @return Pointer to random element in array.
        template<typename T, usize N>
        [[nodiscard]] static T* Get(T(&array)[N])
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return std::addressof(array[Get<usize>(0, N - 1)]);
        }

        /// @brief Retrieve a value from custom Dist distribution seeded by internal random engine.
        /// @tparam Dist Type of custom distribution with next concept.
        /// @tparam Args Arguments which will be forwarded to Dist constructor.
        /// @return Value from custom distribution.
        template<typename Dist, typename... Args>
        [[nodiscard]] static typename Dist::result_type Get(Args&&... args)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return Dist{ std::forward<Args>(args)... }(EngineInstance());
        }

        /// @brief Retrieve a value from custom 'dist' distribution seeded by internal random engine.
        /// @tparam Dist Custom distribution with next concept.
        /// @param dist Custom distribution with next concept.
        /// @return Value from custom 'dist' distribution.
        template<typename Dist>
        [[nodiscard]] static typename Dist::result_type Get(Dist& dist)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return dist(EngineInstance());
        }

        /// @brief Reorders the elements in the given range [first, last) such that each possible permutation of
        /// those elements has equal probability of appearance.
        /// @param first Range of elements to shuffle randomly.
        /// @param last Range of elements to shuffle randomly.
        template<typename RandomIt>
        static void Shuffle(RandomIt first, RandomIt last)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            std::shuffle(first, last, EngineInstance());
        }

        /// @brief Reorders the elements in the given container such that each possible permutation of those elements
        /// has equal probability of appearance.
        /// @tparam Container Container with elements to shuffle randomly.
        /// @param container Container with elements to shuffle randomly.
        template<typename Container>
        static void Shuffle(Container& container)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            Shuffle(std::begin(container), std::end(container));
        }

        /// @brief Retrieve internal engine by copy.
        /// @return Internal engine.
        [[nodiscard]] static engine GetEngine()
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return EngineInstance();
        }

        /// @brief Retrieve internal engine by ref.
        /// @return Internal engine.
        [[nodiscard]] static engine& Engine()
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return EngineInstance();
        }
    protected:
        /// @brief Get reference to the thread local engine instance.
        /// @return Thread local engine reference.
        [[nodiscard]] static engine& EngineInstance()
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            thread_local engine Engine{ Seeder{ }() };
            return Engine;
        }
    };

    /// @brief Base template class for random with local API and local internal member storage.
    /// It IS thread safe but less efficient then BasicRandomStatic.
    /// @tparam engine Random engine with interface like in the std::mt19937.
    /// @tparam Seeder Seeder type which return seed for internal engine through operator().
    template<typename engine,
             typename Seeder = SeederDefault,
             template<typename> class IntegerDist = std::uniform_int_distribution,
             template<typename> class RealDist = std::uniform_real_distribution,
             typename BoolDist = std::bernoulli_distribution>
    class BasicRandomLocal
	{
    public:
        /// @brief Type of used random number engine.
        using EngineType = engine;

        /// @brief Type of used random number seeder.
        using SeederType = Seeder;

        /// @brief Type of used integer distribution.
        template<typename T>
        using IntegerDistT = IntegerDist<T>;

        /// @brief Type of used real distribution.
        template<typename T>
        using RealDistT = RealDist<T>;

        /// @brief Type of used bool distribution.
        using BoolDistT = BoolDist;

        /// @brief Key type for getting common type numbers or objects.
        using Common = INTERNAL::Common;

        /// @brief Retrieve the minimum value potentially generated by the random-number engine.
        /// @return Minimum random number.
        [[nodiscard]] static constexpr typename engine::result_type Min()
    	{
            return engine::min();
        }

        /// @brief Retrieve the maximum value potentially generated by the random-number engine.
        /// @return Maximum random number.
        [[nodiscard]] static constexpr typename engine::result_type Max()
    	{
            return engine::max();
        }

        /// @brief Advances the internal state by z times
        /// @param z How many times to advance.
        void Discard(const u64 z)
        {
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            m_engine.discard(z);
        }

        /// @brief Reseed by seeder.
        void Reseed()
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            const Seeder seeder;
            Seed(seeder());
        }

        /// @brief Re-Initializes the internal state of the random-number engine using new seed value.
        /// @param value Seed value to use in the initialization of the internal state
        void Seed(const typename engine::result_type value = engine::default_seed)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            m_engine.seed(value);
        }

        /// @brief Re-Initializes the internal state of the random-number engine using new seed value.
        /// @param seq Seed sequence to use in the initialization of the internal state.
        template<typename SSeq>
        void Seed(SSeq& seq)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            m_engine.seed(seq);
        }

        /// @brief Retrieve a random number from engine in [Min(), Max()] range.
        /// @return Random number.
        [[nodiscard]] typename engine::result_type Get()
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return m_engine();
        }

        /// @brief Compares internal pseudo-random number engine with 'other' pseudo-random number engine.
        /// Two engines are equal, if their internal states are equivalent, that is, if they would generate
        /// equivalent values for any number of calls of operator().
        /// @param other Engine, with which the internal engine will be compared.
        /// @return True if other and internal engine are equal, false otherwise.
        [[nodiscard]] bool IsEqual(const engine& other) noexcept
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return m_engine == other;
        }

        /// @brief Serializes the internal state of the internal pseudo-random number engine as a sequence
        /// of decimal numbers separated by one or more spaces, and inserts it to the stream ost.
        /// The fill character and the formatting flags of the stream are ignored and unaffected.
        /// @param ost Output stream to insert the data to
        template<typename CharT, typename Traits>
        void Serialize(std::basic_ostream<CharT, Traits>& ost)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            ost << m_engine;
        }

        /// @brief Restores the internal state of the internal pseudo-random number engine from
        /// the serialized representation, which was created by an earlier call to 'Serialize'
        /// using a stream with the same imbued locale and the same CharT and Traits.
        /// If the input cannot be deserialized, internal engine is left unchanged and fail-Bit is raised on ist.
        /// @param ist Input stream to extract the data from.
        template<typename CharT, typename Traits>
        void Deserialize(std::basic_istream<CharT, Traits>& ist)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            ist >> m_engine;
        }

        /// @brief Generate a random integer number in a [from; to] range by std::uniform_int_distribution.
        /// @param from First limit number of a random range.
        /// @param to Second limit number of a random range.
        /// @return Random integer number in a [from; to] range.
        template<typename T>
        requires INTERNAL::IsUniformInt<T>
        [[nodiscard]] T Get(T from = std::numeric_limits<T>::min(), T to = std::numeric_limits<T>::max())
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            if (from < to) //Allow range from higher to lower
                return IntegerDist<T>{ from, to }(m_engine);

            return IntegerDist<T>{ to, from }(m_engine);
        }

        /// @brief Generate a random real number in a [from; to] range by std::uniform_real_distribution.
        /// @param from First limit number of a random range.
        /// @param to Second limit number of a random range.
        /// @return Random real number in a [from; to] range.
        template<typename T>
        requires INTERNAL::IsUniformReal<T>
        [[nodiscard]] T Get(T from = std::numeric_limits<T>::min(), T to = std::numeric_limits<T>::max())
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            if (from < to) //Allow range from higher to lower
                return RealDist<T>{ from, to }(m_engine);

            return RealDist<T>{ to, from }(m_engine);
        }

        /// @brief Generate a random byte number in a [from; to] range.
        /// @param from First limit number of a random range.
        /// @param to Second limit number of a random range.
        /// @return Random byte number in a [from; to] range.
        template<typename T>
        requires INTERNAL::IsByte<T>
        [[nodiscard]] T Get(T from = std::numeric_limits<T>::min(), T to = std::numeric_limits<T>::max())
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            //Choose between i16 and u16 for byte conversion
            using short_t = typename std::conditional<std::is_signed<T>::value,
                i16, u16>::type;

            return static_cast<T>(Get<short_t>(from, to));
        }

        /// @brief Generate a random common_type number in a [from; to] range.
        /// @tparam Key Key type for this version of 'Get' method Type should be '(THIS_TYPE)::Common' struct.
        /// @param from First limit number of a random range.
        /// @param to Second limit number of a random range.
        /// @return Random common_type number in a [from; to] range.
        template<typename Key,
                 typename A,
                 typename B,
                 typename C = typename std::common_type<A, B>::type>
        requires (std::same_as<Key, Common> && INTERNAL::IsSupportedNumber<A> &&
                  INTERNAL::IsSupportedNumber<B> && std::is_signed_v<A> != std::is_unsigned_v<B>)
        [[nodiscard]] C Get(A from = std::numeric_limits<A>::min(), B to = std::numeric_limits<B>::max())
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return Get(static_cast<C>(from), static_cast<C>(to));
        }

        /// @brief Generate a random character in a [from; to] range by std::uniform_int_distribution.
        /// @param from First limit number of a random range.
        /// @param to Second limit number of a random range.
        /// @return Random character in a [from; to] range.
        template<typename T>
        requires INTERNAL::IsSupportedCharacter<T>
        [[nodiscard]] T Get(T from = std::numeric_limits<T>::min(), T to = std::numeric_limits<T>::max())
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            //Allow range from higher to lower
            if (from < to)
                return static_cast<T>(IntegerDist<i64>{ static_cast<i64>(from),
                                                                 static_cast<i64>(to) }(m_engine));

            return static_cast<T>(IntegerDist<i64>{ static_cast<i64>(to),
                                                             static_cast<i64>(from) }(m_engine));
        }

        /// @brief Generate a bool value with specific probability by std::bernoulli_distribution.
        /// @param probability Probability of generating true in [0; 1] range 0 means always false, 1 means always true.
        /// @return 'true' with 'probability' probability ('false' otherwise).
        template<typename T>
        requires std::same_as<T, bool>
        [[nodiscard]] bool Get(const f64 probability = 0.5)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            TRAP_ASSERT(0 <= probability && 1 >= probability, "BasicRandomLocal::Get(): Out of range!"); //Out of [0; 1] range
            return BoolDist{ probability }(m_engine);
        }

        /// @brief Retrieve random value from initializer_list.
        /// @param init_list initializer_list with values.
        /// @return Random value from initializer_list.
        template<typename T>
        [[nodiscard]] T Get(std::initializer_list<T> init_list)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            TRAP_ASSERT(0u != init_list.size(), "BasicRandomLocal::Get(): Empty initializer_list!"); //Empty initializer_list
            return *Get(init_list.begin(), init_list.end());
        }

        /// @brief Retrieve random iterator from iterator range.
        /// @param first Range of elements.
        /// @param last Range of elements.
        /// @return Random iterator from [first, last) range.
        template<typename InputIt>
        requires INTERNAL::IsIterator<InputIt>::value
        [[nodiscard]] InputIt Get(InputIt first, InputIt last)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            const auto size = std::distance(first, last);
            if (0 == size)
                return last;
            using diff_t = typename std::iterator_traits<InputIt>::difference_type;
            return std::next(first, Get<diff_t>(0, size - 1));
        }

        /// @brief Retrieve random iterator from container.
        /// @tparam Container Container with elements.
        /// @param container Container with elements.
        /// @return Random iterator from container.
        template<typename Container>
        requires requires (Container& container) {INTERNAL::IsIterator<decltype(std::begin(container))>::value;}
        [[nodiscard]] Container::iterator Get(Container& container)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return Get(std::begin(container), std::end(container));
        }

        /// @brief Retrieve random pointer from built-in array.
        /// @param array Built-in array with elements.
        /// @return Pointer to random element in array.
        template<typename T, usize N>
        [[nodiscard]] T* Get(T(&array)[N])
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return std::addressof(array[Get<usize>(0, N - 1)]);
        }

        /// @brief Retrieve value from custom Dist distribution seeded by internal random engine.
        /// @tparam Dist Type of custom distribution with next concept.
        /// @tparam Args Arguments which will be forwarded to dist constructor.
        /// @return Value from custom distribution.
        template<typename Dist, typename... Args>
        [[nodiscard]] typename Dist::result_type Get(Args&&... args)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return Dist{ std::forward<Args>(args)... }(m_engine);
        }

        /// @brief Retrieve value from custom 'dist' distribution seeded by internal random engine.
        /// @tparam Dist Custom distribution with next concept.
        /// @param dist Custom distribution with next concept.
        /// @return Value from custom 'dist' distribution.
        template<typename Dist>
        [[nodiscard]] typename Dist::result_type Get(Dist& dist)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return dist(m_engine);
        }

        /// @brief Reorders the elements in the given range [first, last) such that each possible permutation of
        /// those elements has equal probability of appearance.
        /// @param first Range of elements to shuffle randomly.
        /// @param last Range of elements to shuffle randomly.
        template<typename RandomIt>
        void Shuffle(RandomIt first, RandomIt last)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            std::shuffle(first, last, m_engine);
        }

        /// @brief Reorders the elements in the given container such that each possible permutation of those elements
        /// has equal probability of appearance.
        /// @tparam Container Container with elements to shuffle randomly.
        /// @param container Container with elements to shuffle randomly.
        template<typename Container>
        void Shuffle(Container& container)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            Shuffle(std::begin(container), std::end(container));
        }

        /// @brief Retrieve internal engine by copy.
        /// @return Internal engine.
        [[nodiscard]] engine GetEngine() const noexcept
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return m_engine;
        }

        /// @brief Retrieve internal engine by ref.
        /// @return Internal engine-
        [[nodiscard]] engine& Engine() noexcept
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return m_engine;
        }

    protected:
        /// @brief Retrieve engine seeded by seeder
        /// @return Seeded engine.
        [[nodiscard]] static engine MakeSeededEngine()
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            //Make seeder instance for seed return by reference like std::seed_seq
            return engine{ Seeder{ }() };
        }

        /// @brief Random number engine
        engine m_engine{ MakeSeededEngine() };
    };
}

//-------------------------------------------------------------------------------------------------------------------//

namespace TRAP::Utils
{
	/// @brief The basic static random alias based on a std::mt19937_64.
	/// It uses static methods API and data with static storage.
    /// @threadsafety Not thread safe but more performant.
	using Random = BasicRandomStatic<std::mt19937_64>;

	/// @brief The basic static random alias based on a std::mt19937_64.
	/// It uses static methods API and data with thread_local storage.
    /// @threadsafety Thread safe but less performant.
	using RandomThreadLocal = BasicRandomThreadLocal<std::mt19937_64>;

    /// @brief The basic static random alias based on a std::mt19937_64.
    /// It uses non static methods API and data with auto storage.
    /// @threadsafety Not thread safe. Should construct on the stack at local scope.
    using RandomLocal = BasicRandomLocal<std::mt19937_64>;
}

#endif /*TRAP_RANDOM_H*/