#ifndef TRAP_RANDOM_H
#define TRAP_RANDOM_H

#include <random>
#include <algorithm>

#include "RandomInternal.h"
#include "Core/Base.h"
#include "TRAP_Assert.h"
#include "Utils/NumericCasts.h"

namespace TRAP::Utils
{
    /// @brief Default seeder for 'Random' classes.
    class SeederDefault final
    {
    public:
        /// @brief Use std::seed_seq with additional seed from C++ chrono.
        /// @return Seed sequence.
        [[nodiscard]] std::seed_seq& operator()() noexcept
        {
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            return SeedSeq;
        }

        SeederDefault() = default;
        constexpr ~SeederDefault() = default;

        constexpr SeederDefault(const SeederDefault&) = delete;
        constexpr SeederDefault(SeederDefault&&) = delete;

        constexpr SeederDefault& operator=(const SeederDefault&) = delete;
        constexpr SeederDefault& operator=(SeederDefault&&) = delete;

    private:
        std::seed_seq SeedSeq
        { {
                NumericCast<std::uintmax_t>(std::random_device{ }()),
                NumericCast<std::uintmax_t>(std::chrono::steady_clock::now().time_since_epoch().count())
        } };
    };

    /// @brief Base template class for random with static API and static internal member storage.
    /// @tparam engine A random engine with interface like in the std::mt19937.
    /// @tparam Seeder A seeder type which return seed for internal engine through operator().
    /// @threadsafety This is thread safe but less efficient than BasicRandomLocal.
    template<typename engine,
             typename Seeder = SeederDefault,
             template<typename> class IntegerDist = std::uniform_int_distribution,
             template<typename> class RealDist = std::uniform_real_distribution,
             typename BoolDist = std::bernoulli_distribution>
    class BasicRandomStatic final
	{
    public:
        /// @brief Constructor.
        constexpr BasicRandomStatic() = delete;
    	/// @brief Destructor.
        constexpr ~BasicRandomStatic() = delete;
        /// @brief Copy constructor.
        consteval BasicRandomStatic(const BasicRandomStatic&) = delete;
        /// @brief Copy assignment operator.
        consteval BasicRandomStatic operator=(const BasicRandomStatic&) = delete;
        /// @brief Move constructor.
        consteval BasicRandomStatic(BasicRandomStatic&&) noexcept = delete;
        /// @brief Move assignment operator.
        consteval BasicRandomStatic operator=(BasicRandomStatic&&) noexcept = delete;

        /// @brief Type of used random number engine.
        using EngineType = engine;

        /// @brief Type of used random number seeder.
        using SeederType = Seeder;

        /// @brief Type of used integer distribution.
        /// @tparam T Integer type.
        template<typename T>
        using IntegerDistT = IntegerDist<T>;

        /// @brief Type of used real distribution.
        /// @tparam T Float/Double type.
        template<typename T>
        using RealDistT = RealDist<T>;

        /// @brief Type of used bool distribution.
        using BoolDistT = BoolDist;

        /// @brief Retrieve the minimum value potentially generated by the random-number engine.
        /// @return Minimum value.
        [[nodiscard]] static constexpr typename engine::result_type Min()
    	{
            return engine::min();
        }

        /// @brief Retrieve the maximum value potentially generated by the random-number engine.
        /// @return Maximum value.
        [[nodiscard]] static constexpr typename engine::result_type Max()
    	{
            return engine::max();
        }

        /// @brief Advances the internal state by z times.
        /// @param z How many times to advance.
        static void Discard(const u64 z)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            auto Engine = EngineInstance().WriteLock();
            Engine->discard(z);
        }

        /// @brief Reseed by seeder.
        static void Reseed()
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            Seeder seeder{};
            Seed(seeder());
        }

        /// @brief Re-Initializes the internal state of the random-number engine using new seed value.
        /// @param value Seed value to use in the initialization of the internal state.
        static void Seed(const typename engine::result_type value = engine::default_seed)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            auto Engine = EngineInstance().WriteLock();
            Engine->seed(value);
        }

        /// @brief Re-Initializes the internal state of the random-number engine using new seed value.
        /// @tparam SSeq Seed sequence.
        /// @param seq Seed sequence to use in the initialization of the internal state
        template<typename SSeq>
        static void Seed(SSeq& seq)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            auto Engine = EngineInstance().WriteLock();
            Engine->seed(seq);
        }

        /// @brief Get a random number from engine in [Min(), Max()] range.
        /// @return Random number.
        [[nodiscard]] static typename engine::result_type Get()
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            auto Engine = EngineInstance().WriteLock();

            return (*Engine)();
        }

        /// @brief Serializes the internal state of the internal pseudo-random number engine as a sequence
        /// of decimal numbers separated by one or more spaces, and returns it as a string.
        /// The fill character and the formatting flags of the stream are ignored and unaffected.
        /// @return Internal state of the internal pseudo-random number engine represented as a string.
        [[nodiscard]] static std::string Serialize()
        {
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            const auto Engine = EngineInstance().ReadLock();

            std::stringstream sstream{};
            sstream << *Engine;

            return sstream.str();
        }

        /// @brief Restores the internal state of the internal pseudo-random number engine from
        /// the serialized representation, which was created by an earlier call to 'Serialize'.
        /// If the input cannot be deserialized, internal engine is left unchanged and false will be returned.
        /// @param in Serialized internal state of the internal pseudo-random number engine represented as a string.
        [[nodiscard]] static bool Deserialize(const std::string& in)
        {
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            if(in.empty())
                return false;

            std::stringstream sstream{};
            sstream << in;

            auto Engine = EngineInstance().WriteLock();

            sstream >> (*Engine);

            return !sstream.fail();
        }

        /// @brief Generate a random integer number in a [from; to] range by std::uniform_int_distribution.
        /// @param from First limit number of a random range.
        /// @param to Second limit number of a random range.
        /// @return A random integer number in a [from; to] range.
        template<typename T>
        [[nodiscard]] static T Get(T from, T to)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            if (from < to) //Allow range from higher to lower
                std::swap(from, to);

            if constexpr(INTERNAL::IsUniformInt<T>)
            {
                auto Engine = EngineInstance().WriteLock();
                return IntegerDist<T>{ to, from }(*Engine);
            }
            else if constexpr(INTERNAL::IsUniformReal<T>)
            {
                auto Engine = EngineInstance().WriteLock();
                return RealDist<T>{ to, from }(*Engine);
            }
            else if constexpr(INTERNAL::IsByte<T>)
            {
                //Choose between i16 and u16 for byte conversion.
                //This is done because std::uniform_int_distribution does not support i8/u8.
                using short_t = typename std::conditional_t<std::is_signed_v<T>, i16, u16>;

                return static_cast<T>(Get<short_t>(from, to));
            }
            else if constexpr(INTERNAL::IsSupportedCharacter<T>)
            {
                auto Engine = EngineInstance().WriteLock();
                return static_cast<T>(IntegerDist<i64>{ static_cast<i64>(to),
                                                        static_cast<i64>(from) }(*Engine));
            }
        }

        /// @brief Generate a bool value with specific probability by std::bernoulli_distribution.
        /// @param probability Probability of generating true in [0; 1] range 0 means always false, 1 means always true.
        /// @return 'true' with 'probability' probability ('false' otherwise).
        [[nodiscard]] static bool Get(const f64 probability)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            auto Engine = EngineInstance().WriteLock();

            TRAP_ASSERT(0.0 <= probability && 1.0 >= probability, "BasicRandomStatic::Get(): Out of range!"); //Out of [0; 1] range
            return BoolDist{ probability }(*Engine);
        }

        /// @brief Get random value from initializer_list.
        /// Should be 1 or more elements in initializer_list.
        /// @param init_list Initializer_list with values.
        /// @return Random value from initializer_list.
        /// @note Elements in initializer_list can't be moved!
        template<typename T>
        [[nodiscard]] static T Get(std::initializer_list<T> init_list)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            if(init_list.size() == 0u)
            {
                TRAP_ASSERT(false, "BasicRandomStatic::Get(): Empty initializer_list!"); //Empty initializer_list
                return T{};
            }

            return *Get(init_list.begin(), init_list.end());
        }

        /// @brief Get random iterator from iterator range.
        /// @param first Range of elements.
        /// @param last Range of elements.
        /// @return Random iterator from [first, last) range.
        template<typename InputIt>
        requires INTERNAL::IsIterator<InputIt>
        [[nodiscard]] static InputIt Get(InputIt first, InputIt last)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            const auto size = std::distance(first, last);
            if (size == 0)
                return last;
            using diff_t = typename std::iterator_traits<InputIt>::difference_type;
            return std::next(first, Get<diff_t>(0, size - 1));
        }

        /// @brief Get random iterator from container.
        /// @param container Container with elements.
        /// @return Random iterator from container.
        template<typename Container>
        requires requires (Container& container) { requires INTERNAL::IsIterator<decltype(std::begin(container))>; }
        [[nodiscard]] static Container::iterator Get(Container& container)
        {
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            return Get(std::begin(container), std::end(container));
        }

        /// @brief Get random iterator from container.
        /// @param container Container with elements.
        /// @return Random iterator from container.
        template<typename Container>
        requires requires (Container& container) { requires INTERNAL::IsIterator<decltype(std::cbegin(container))>; }
        [[nodiscard]] static Container::const_iterator Get(const Container& container)
        {
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            return Get(std::cbegin(container), std::cend(container));
        }

        /// @brief Get random pointer from built-in array.
        /// @param array Built-in array with elements.
        /// @return Pointer to random element in array.
        template<typename T, usize N>
        [[nodiscard]] static T* Get(T(&array)[N])
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            return std::addressof(array[Get<usize>(0, N - 1)]);
        }

        /// @brief Reorders the elements in the given range [first, last) such that each possible permutation
        /// of those elements has equal probability of appearance.
        /// @param first Range of elements to shuffle randomly.
        /// @param last Range of elements to shuffle randomly.
        template<typename RandomIt>
        static void Shuffle(RandomIt first, RandomIt last)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            auto Engine = EngineInstance().WriteLock();

            std::shuffle(first, last, *Engine);
        }

        /// @brief Reorders the elements in the given container such that each possible permutation of those elements
        /// has equal probability of appearance.
        /// @param container Container with elements to shuffle randomly.
        template<typename Container>
        static void Shuffle(Container& container)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            Shuffle(std::begin(container), std::end(container));
        }

    protected:
        /// @brief Get reference to the static engine instance.
        /// @return Static engine instance.
        [[nodiscard]] static TRAP::Utils::Safe<engine>& EngineInstance()
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            static TRAP::Utils::Safe<engine> Engine{TRAP::Utils::DefaultConstructMutexTag, Seeder{}()};

            return Engine;
        }
    };

    /// @brief Base template class for random with local API and local internal member storage.
    /// @tparam engine Random engine with interface like in the std::mt19937.
    /// @tparam Seeder Seeder type which return seed for internal engine through operator().
    /// @threadsafety It is not thread safe but more efficient then BasicRandomStatic.
    template<typename engine,
             typename Seeder = SeederDefault,
             template<typename> class IntegerDist = std::uniform_int_distribution,
             template<typename> class RealDist = std::uniform_real_distribution,
             typename BoolDist = std::bernoulli_distribution>
    class BasicRandomLocal final
	{
    public:
        /// @brief Type of used random number engine.
        using EngineType = engine;

        /// @brief Type of used random number seeder.
        using SeederType = Seeder;

        /// @brief Type of used integer distribution.
        template<typename T>
        using IntegerDistT = IntegerDist<T>;

        /// @brief Type of used real distribution.
        template<typename T>
        using RealDistT = RealDist<T>;

        /// @brief Type of used bool distribution.
        using BoolDistT = BoolDist;

        /// @brief Constructor.
        BasicRandomLocal() = default;
        /// @brief Destructor.
        ~BasicRandomLocal() = default;

        /// @brief Copy constructor.
        BasicRandomLocal(const BasicRandomLocal&) = default;
        /// @brief Move constructor.
        BasicRandomLocal(BasicRandomLocal&&) noexcept = default;

        /// @brief Copy assignment operator.
        /// @return *this.
        BasicRandomLocal& operator=(const BasicRandomLocal&) = default;
        /// @brief Move assignment operator.
        /// @return *this.
        BasicRandomLocal& operator=(BasicRandomLocal&&) noexcept = default;

        /// @brief Retrieve the minimum value potentially generated by the random-number engine.
        /// @return Minimum random number.
        [[nodiscard]] static constexpr typename engine::result_type Min()
    	{
            return engine::min();
        }

        /// @brief Retrieve the maximum value potentially generated by the random-number engine.
        /// @return Maximum random number.
        [[nodiscard]] static constexpr typename engine::result_type Max()
    	{
            return engine::max();
        }

        /// @brief Advances the internal state by z times
        /// @param z How many times to advance.
        /// @note This function can use "fast jump" algorithm which advance the state by many steps (order of millions)
        ///       without calculating intermediate state transitions can be used instead of naive loops
        ///       that calls Get() z times and discarding the result.
        void Discard(const u64 z)
        {
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            m_engine.discard(z);
        }

        /// @brief Reseed by seeder.
        void Reseed()
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            Seeder seeder{};
            Seed(seeder());
        }

        /// @brief Re-Initializes the internal state of the random-number engine using new seed value.
        /// @param value Seed value to use in the initialization of the internal state
        void Seed(const typename engine::result_type value = engine::default_seed)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            m_engine.seed(value);
        }

        /// @brief Re-Initializes the internal state of the random-number engine using new seed value.
        /// @param seq Seed sequence to use in the initialization of the internal state.
        template<typename SSeq>
        void Seed(SSeq& seq)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            m_engine.seed(seq);
        }

        /// @brief Retrieve a random number from engine in [Min(), Max()] range.
        /// @return Random number.
        [[nodiscard]] typename engine::result_type Get()
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            return m_engine();
        }

        /// @brief Compares internal pseudo-random number engine with 'other' pseudo-random number engine.
        /// Two engines are equal, if their internal states are equivalent, that is, if they would generate
        /// equivalent values for any number of calls of operator().
        /// @param other Random instance, with which to compare.
        /// @return True if both random instance have the same internal state, false otherwise.
        [[nodiscard]] bool operator==(const BasicRandomLocal<engine>& other) const noexcept
        {
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            return m_engine == other.m_engine;
        }

        /// @brief Serializes the internal state of the internal pseudo-random number engine as a sequence
        /// of decimal numbers separated by one or more spaces, and returns it as a string.
        /// The fill character and the formatting flags of the stream are ignored and unaffected.
        /// @return Internal state of the internal pseudo-random number engine represented as a string.
        [[nodiscard]] std::string Serialize() const
        {
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            std::stringstream sstream{};
            sstream << m_engine;

            return sstream.str();
        }

        /// @brief Restores the internal state of the internal pseudo-random number engine from
        /// the serialized representation, which was created by an earlier call to 'Serialize'.
        /// If the input cannot be deserialized, internal engine is left unchanged and false will be returned.
        /// @param in Serialized internal state of the internal pseudo-random number engine represented as a string.
        [[nodiscard]] bool Deserialize(const std::string& in)
        {
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            if(in.empty())
                return false;

            std::stringstream sstream{};
            sstream << in;

            sstream >> m_engine;

            return !sstream.fail();
        }

        /// @brief Generate a random value in a [from; to] range.
        /// @param from First limit value of a random range.
        /// @param to Second limit value of a random range.
        /// @return Random value in a [from; to] range.
        template<typename T>
        [[nodiscard]] T Get(T from, T to)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            if (from < to) //Allow range from higher to lower
                std::swap(from, to);

            if constexpr(INTERNAL::IsUniformInt<T>)
            {
                return IntegerDist<T>{ to, from }(m_engine);
            }
            else if constexpr(INTERNAL::IsUniformReal<T>)
            {
                return RealDist<T>{ to, from }(m_engine);
            }
            else if constexpr(INTERNAL::IsByte<T>)
            {
                //Choose between i16 and u16 for byte conversion.
                //This is done because std::uniform_int_distribution does not support i8/u8.
                using short_t = typename std::conditional_t<std::is_signed_v<T>, i16, u16>;

                return static_cast<T>(Get<short_t>(from, to));
            }
            else if constexpr(INTERNAL::IsSupportedCharacter<T>)
            {
                return static_cast<T>(IntegerDist<i64>{ static_cast<i64>(to),
                                                        static_cast<i64>(from) }(m_engine));
            }
        }

        /// @brief Generate a bool value with specific probability by std::bernoulli_distribution.
        /// @param probability Probability of generating true in [0; 1] range 0 means always false, 1 means always true.
        /// @return 'true' with 'probability' probability ('false' otherwise).
        [[nodiscard]] bool Get(const f64 probability)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            TRAP_ASSERT(0.0 <= probability && 1.0 >= probability, "BasicRandomLocal::Get(): Out of range!"); //Out of [0; 1] range
            return BoolDist{ probability }(m_engine);
        }

        /// @brief Retrieve random value from initializer_list.
        /// @param init_list initializer_list with values.
        /// @return Random value from initializer_list.
        template<typename T>
        [[nodiscard]] T Get(std::initializer_list<T> init_list)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            if(init_list.size() == 0u)
            {
                TRAP_ASSERT(false, "BasicRandomLocal::Get(): Empty std::initializer_list provided!");
                return T{};
            }

            return *Get(init_list.begin(), init_list.end());
        }

        /// @brief Retrieve random iterator from iterator range.
        /// @param first Range of elements.
        /// @param last Range of elements.
        /// @return Random iterator from [first, last) range.
        template<typename InputIt>
        requires INTERNAL::IsIterator<InputIt>
        [[nodiscard]] InputIt Get(InputIt first, InputIt last)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            const auto size = std::distance(first, last);
            if (size == 0)
                return last;
            using diff_t = typename std::iterator_traits<InputIt>::difference_type;
            return std::next(first, Get<diff_t>(0, size - 1));
        }

        /// @brief Retrieve random iterator from container.
        /// @tparam Container Container with elements.
        /// @param container Container with elements.
        /// @return Random iterator from container.
        template<typename Container>
        requires requires (Container& container) {requires INTERNAL::IsIterator<decltype(std::begin(container))>;}
        [[nodiscard]] Container::iterator Get(Container& container)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            return Get(std::begin(container), std::end(container));
        }

        /// @brief Retrieve random iterator from container.
        /// @tparam Container Container with elements.
        /// @param container Container with elements.
        /// @return Random iterator from container.
        template<typename Container>
        requires requires (Container& container) {requires INTERNAL::IsIterator<decltype(std::cbegin(container))>;}
        [[nodiscard]] Container::const_iterator Get(const Container& container)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            return Get(std::cbegin(container), std::cend(container));
        }

        /// @brief Retrieve random pointer from built-in array.
        /// @param array Built-in array with elements.
        /// @return Pointer to random element in array.
        template<typename T, usize N>
        [[nodiscard]] T* Get(T(&array)[N])
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            return std::addressof(array[Get<usize>(0, N - 1)]);
        }

        /// @brief Reorders the elements in the given range [first, last) such that each possible permutation of
        /// those elements has equal probability of appearance.
        /// @param first Range of elements to shuffle randomly.
        /// @param last Range of elements to shuffle randomly.
        template<typename RandomIt>
        void Shuffle(RandomIt first, RandomIt last)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            std::shuffle(first, last, m_engine);
        }

        /// @brief Reorders the elements in the given container such that each possible permutation of those elements
        /// has equal probability of appearance.
        /// @tparam Container Container with elements to shuffle randomly.
        /// @param container Container with elements to shuffle randomly.
        template<typename Container>
        void Shuffle(Container& container)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            Shuffle(std::begin(container), std::end(container));
        }

    private:
        /// @brief Retrieve engine seeded by seeder
        /// @return Seeded engine.
        [[nodiscard]] static engine MakeSeededEngine()
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, (GetTRAPProfileSystems() & ProfileSystems::Utils) != ProfileSystems::None);

            //Make seeder instance for seed return by reference like std::seed_seq
            return engine{ Seeder{ }() };
        }

        /// @brief Random number engine
        engine m_engine{ MakeSeededEngine() };
    };
}

//-------------------------------------------------------------------------------------------------------------------//

namespace TRAP::Utils
{
	/// @brief The basic static random alias based on a std::mt19937_64.
	/// It uses static methods API and data with static storage.
    /// @threadsafety Thread safe but less performant than a local instance.
	using Random = BasicRandomStatic<std::mt19937_64>;

    /// @brief The basic static random alias based on a std::mt19937_64.
    /// It uses non static methods API and data with auto storage.
    /// @threadsafety Not thread safe. Should construct on the stack at local scope.
    using RandomLocal = BasicRandomLocal<std::mt19937_64>;
}

#endif /*TRAP_RANDOM_H*/
