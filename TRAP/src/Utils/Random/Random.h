#ifndef TRAP_RANDOM_H
#define TRAP_RANDOM_H

#include <random>
#include <algorithm>

#include "RandomInternal.h"
#include "Core/Base.h"
#include "TRAP_Assert.h"

namespace TRAP::Utils
{
    /// <summary>
    /// Default seeder for 'Random' classes.
    /// </summary>
    struct SeederDefault
    {
        /// <summary>
        /// Use std::seed_seq with additional seed from C++ chrono.
        /// </summary>
        /// <returns>Seed sequence.</returns>
        std::seed_seq& operator()() noexcept
        {
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return SeedSeq;
        }

    private:
        std::seed_seq SeedSeq
        { {
                NumericCast<std::uintmax_t>(std::random_device{ }()),
                NumericCast<std::uintmax_t>(std::chrono::steady_clock::now().time_since_epoch().count())
        } };
    };

    /// <summary>
    /// Base template class for random with static API and static internal member storage.
    ///
    /// Note: It is NOT thread safe but more efficient then basic_random_thread_local.
    /// </summary>
    /// <typeparam name="engine">A random engine with interface like in the std::mt19937.</typeparam>
    /// <typeparam name="Seeder">A seeder type which return seed for internal engine through operator().</typeparam>
    template<typename engine,
             typename Seeder = SeederDefault,
             template<typename> class IntegerDist = std::uniform_int_distribution,
             template<typename> class RealDist = std::uniform_real_distribution,
             typename BoolDist = std::bernoulli_distribution>
    class BasicRandomStatic
	{
    public:
        /// <summary>
        /// Constructor.
        /// </summary>
        constexpr BasicRandomStatic() = delete;
    	/// <summary>
    	/// Destructor.
    	/// </summary>
        constexpr ~BasicRandomStatic() = delete;
        /// <summary>
        /// Copy constructor.
        /// </summary>
        constexpr BasicRandomStatic(const BasicRandomStatic&) = delete;
        /// <summary>
        /// Copy assignment operator.
        /// </summary>
        constexpr BasicRandomStatic operator=(const BasicRandomStatic&) = delete;
        /// <summary>
        /// Move constructor.
        /// </summary>
        constexpr BasicRandomStatic(BasicRandomStatic&&) = delete;
        /// <summary>
        /// Move assignment operator.
        /// </summary>
        constexpr BasicRandomStatic operator=(BasicRandomStatic&&) = delete;

        /// <summary>
        /// Type of used random number engine.
        /// </summary>
        using EngineType = engine;

        /// <summary>
        /// Type of used random number seeder.
        /// </summary>
        using SeederType = Seeder;

        /// <summary>
        /// Type of used integer distribution.
        /// </summary>
        /// <typeparam name="T">Integer type.</typeparam>
        template<typename T>
        using IntegerDistT = IntegerDist<T>;

        /// <summary>
        /// Type of used real distribution.
        /// </summary>
        /// <typeparam name="T">Float/Double type.</typeparam>
        template<typename T>
        using RealDistT = RealDist<T>;

        /// <summary>
        /// Type of used bool distribution.
        /// </summary>
        using BoolDistT = BoolDist;

        /// <summary>
        /// Key type for getting common type numbers or objects.
        /// </summary>
        using Common = INTERNAL::Common;

        /// <summary>
        /// Retrieve the minimum value potentially generated by the random-number engine.
        /// </summary>
        /// <returns>Minimum value.</returns>
        [[nodiscard]] static constexpr typename engine::result_type Min()
    	{
            return engine::min();
        }

        /// <summary>
        /// Retrieve the maximum value potentially generated by the random-number engine.
        /// </summary>
        /// <returns>Maximum value.</returns>
        [[nodiscard]] static constexpr typename engine::result_type Max()
    	{
            return engine::max();
        }

        /// <summary>
        /// Advances the internal state by z times.
        /// </summary>
        /// <param name="z">How many times to advance.</param>
        static void Discard(const uint64_t z)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            EngineInstance().discard(z);
        }

        /// <summary>
        /// Reseed by seeder.
        /// </summary>
        static void Reseed()
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            const Seeder seeder;
            Seed(seeder());
        }

        /// <summary>
        /// Re-Initializes the internal state of the random-number engine using new seed value.
        /// </summary>
        /// <param name="value">Seed value to use in the initialization of the internal state.</param>
        static void Seed(const typename engine::result_type value =
            engine::default_seed)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            EngineInstance().seed(value);
        }

        /// <summary>
        /// Re-Initializes the internal state of the random-number engine using new seed value.
        /// </summary>
        /// <typeparam name="SSeq">Seed sequence.</typeparam>
        /// <param name="seq">Seed sequence to use in the initialization of the internal state</param>
        template<typename SSeq>
        static void Seed(SSeq& seq)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            EngineInstance().seed(seq);
        }

        /// <summary>
        /// Get a random number from engine in [Min(), Max()] range.
        /// </summary>
        /// <returns>Random number.</returns>
        [[nodiscard]] static typename engine::result_type Get()
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return EngineInstance()();
        }

        /// <summary>
        /// Compares internal pseudo-random number engine with 'other' pseudo-random number engine.
        /// Two engines are equal, if their internal states are equivalent, that is, if they would generate
        /// equivalent values for any number of calls of operator().
        /// </summary>
        /// <param name="other">Engine, with which the internal engine will be compared.</param>
        /// <returns>True, if other and internal engine are equal.</returns>
        [[nodiscard]] static bool IsEqual(const engine& other)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return EngineInstance() == other;
        }

        /// <summary>
        /// Serializes the internal state of the internal pseudo-random number engine as a sequence
        /// of decimal numbers separated by one or more spaces, and inserts it to the stream ost.
        /// The fill character and the formatting flags of the stream are ignored and unaffected.
        /// </summary>
        /// <param name="ost">Output stream to insert the data to.</param>
        template<typename CharT, typename Traits>
        static void Serialize(std::basic_ostream<CharT, Traits>& ost)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            ost << EngineInstance();
        }

        /// <summary>
        /// Restores the internal state of the internal pseudo-random number engine from
        /// the serialized representation, which was created by an earlier call to 'Serialize'
        /// using a stream with the same imbued locale and the same CharT and Traits.
        /// If the input cannot be deserialized, internal engine is left unchanged and fail-Bit is raised on ist.
        /// </summary>
        /// <param name="ist">Input stream to extract the data from.</param>
        template<typename CharT, typename Traits>
        static void Deserialize(std::basic_istream<CharT, Traits>& ist)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            ist >> EngineInstance();
        }

        /// <summary>
        /// Generate a random integer number in a [from; to] range by std::uniform_int_distribution.
        /// </summary>
        /// <param name="from">First limit number of a random range.</param>
        /// <param name="to">Second limit number of a random range.</param>
        /// <returns>A random integer number in a [from; to] range.</returns>
        template<typename T>
        [[nodiscard]] static typename std::enable_if<INTERNAL::IsUniformInt<T>::value, T>::type
    	Get(T from = std::numeric_limits<T>::min(), T to = std::numeric_limits<T>::max())
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            if (from < to) //Allow range from higher to lower
                return IntegerDist<T>{ from, to }(EngineInstance());

            return IntegerDist<T>{ to, from }(EngineInstance());
        }

        /// <summary>
        /// Generate a random real number in a [from; to] range by std::uniform_real_distribution.
        /// </summary>
        /// <param name="from">First limit number of a random range.</param>
        /// <param name="to">Second limit number of a random range.</param>
        /// <returns>A random real number in a [from; to] range.</returns>
        template<typename T>
        [[nodiscard]] static typename std::enable_if<INTERNAL::IsUniformReal<T>::value, T>::type
    	Get(T from = std::numeric_limits<T>::min(), T to = std::numeric_limits<T>::max())
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            if (from < to) //Allow range from higher to lower
                return RealDist<T>{ from, to }(EngineInstance());

            return RealDist<T>{ to, from }(EngineInstance());
        }

        /// <summary>
        /// Generate a random byte number in a [from; to] range.
        /// </summary>
        /// <param name="from">First limit number of a random range.</param>
        /// <param name="to">Second limit number of a random range.</param>
        /// <returns>A random byte number in a [from; to] range.</returns>
        template<typename T>
        [[nodiscard]] static typename std::enable_if<INTERNAL::IsByte<T>::value, T>::type
    	Get(T from = std::numeric_limits<T>::min(), T to = std::numeric_limits<T>::max())
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            //Choose between short and unsigned short for byte conversion
            using short_t = typename std::conditional<std::is_signed<T>::value,
                                                      int16_t, uint16_t>::type;

            return static_cast<T>(Get<short_t>(from, to));
        }

        /// <summary>
        /// Generate a random common_type number in a [from; to] range.
        /// </summary>
        /// <typeparam name="Key">
        /// Key type for this version of 'Get' method Type should be '(THIS_TYPE)::Common' struct.
        /// </typeparam>
        /// <param name="from">First limit number of a random range.</param>
        /// <param name="to">Second limit number of a random range.</param>
        /// <returns>A random common_type number in a [from; to] range.</returns>
        template<typename Key,
                 typename A,
                 typename B,
                 typename C = typename std::common_type<A, B>::type>
        [[nodiscard]] static typename std::enable_if<std::is_same<Key, Common>::value &&
                                                     INTERNAL::IsSupportedNumber<A>::value &&
                                                     INTERNAL::IsSupportedNumber<B>::value &&
                                                     //Prevent implicit type conversion from singed to unsigned types
                                                     std::is_signed<A>::value != std::is_unsigned<B>::value, C>::type
    	Get(A from = std::numeric_limits<A>::min(),
            B to = std::numeric_limits<B>::max())
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return Get(static_cast<C>(from), static_cast<C>(to));
        }

        /// <summary>
        /// Generate a random character in a [from; to] range by std::uniform_int_distribution.
        /// </summary>
        /// <param name="from">First limit number of a random range.</param>
        /// <param name="to">Second limit number of a random range.</param>
        /// <returns>A random character in a [from; to] range.</returns>
        template<typename T>
        [[nodiscard]] static typename std::enable_if<INTERNAL::IsSupportedCharacter<T>::value, T>::type
    	Get(T from = std::numeric_limits<T>::min(), T to = std::numeric_limits<T>::max())
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            if (from < to) //Allow range from higher to lower
                return static_cast<T>(IntegerDist<std::int64_t>{ static_cast<std::int64_t>(from),
                                                                 static_cast<std::int64_t>(to) }(EngineInstance()));

            return static_cast<T>(IntegerDist<std::int64_t>{ static_cast<std::int64_t>(to),
                                                             static_cast<std::int64_t>(from) }(EngineInstance()));
        }

        /// <summary>
        /// Generate a bool value with specific probability by std::bernoulli_distribution.
        /// </summary>
        /// <param name="probability">
        /// Probability of generating true in [0; 1] range 0 means always false, 1 means always true.
        /// </param>
        /// <returns>'true' with 'probability' probability ('false' otherwise).</returns>
        template<typename T>
        [[nodiscard]] static typename std::enable_if<std::is_same<T, bool>::value, bool>::type
    	Get(const double probability = 0.5)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            TRAP_ASSERT(0 <= probability && 1 >= probability, "BasicRandomStatic::Get(): Out of range!"); //Out of [0; 1] range
            return BoolDist{ probability }(EngineInstance());
        }

        /// <summary>
        /// Get random value from initializer_list.
        /// Should be 1 or more elements in initializer_list.
        /// Note: Elements in initializer_list can't be moved!
        /// </summary>
        /// <param name="init_list">Initializer_list with values.</param>
        /// <returns>Random value from initializer_list.</returns>
        template<typename T>
        [[nodiscard]] static T Get(std::initializer_list<T> init_list)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            TRAP_ASSERT(0u != init_list.size(), "BasicRandomStatic::Get(): Empty initializer_list!"); //Empty initializer_list
            return *Get(init_list.begin(), init_list.end());
        }

        /// <summary>
        /// Get random iterator from iterator range.
        /// </summary>
        /// <param name="first">Range of elements.</param>
        /// <param name="last">Range of elements.</param>
        /// <returns>Random iterator from [first, last) range.</returns>
        template<typename InputIt>
        [[nodiscard]] static typename std::enable_if<INTERNAL::IsIterator<InputIt>::value, InputIt>::type
    	Get(InputIt first, InputIt last)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            const auto size = std::distance(first, last);
            if (0 == size)
                return last;
            using diff_t = typename std::iterator_traits<InputIt>::difference_type;
            return std::next(first, Get<diff_t>(0, size - 1));
        }

        /// <summary>
        /// Get random iterator from container.
        /// </summary>
        /// <param name="container">Container with elements.</param>
        /// <returns>Random iterator from container.</returns>
        template<typename Container>
        [[nodiscard]] static auto Get(Container& container) ->
            typename std::enable_if<INTERNAL::IsIterator<
            decltype(std::begin(container))>::value,
    		decltype(std::begin(container))>::type
        {
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return Get(std::begin(container), std::end(container));
        }

        /// <summary>
        /// Get random pointer from built-in array.
        /// </summary>
        /// <param name="array">Built-in array with elements.</param>
        /// <returns>Pointer to random element in array.</returns>
        template<typename T, std::size_t N>
        [[nodiscard]] static T* Get(T(&array)[N])
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return std::addressof(array[Get<std::size_t>(0, N - 1)]);
        }

        /// <summary>
        /// Get value from custom dist distribution seeded by internal random engine.
        /// </summary>
        /// <typeparam name="Dist">Type of custom distribution with next concept.</typeparam>
        /// <typeparam name="...Args">Arguments which will be forwarded to dist constructor.</typeparam>
        /// <returns>Value from custom distribution.</returns>
        template<typename Dist, typename... Args>
        [[nodiscard]] static typename Dist::result_type Get(Args&&... args)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return Dist{ std::forward<Args>(args)... }(EngineInstance());
        }

        /// <summary>
        /// Get value from custom 'dist' distribution seeded by internal random engine.
        /// </summary>
        /// <param name="dist">Custom distribution with next concept</param>
        /// <returns>Value from custom 'dist' distribution</returns>
        template<typename Dist>
        [[nodiscard]] static typename Dist::result_type Get(Dist& dist)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return dist(EngineInstance());
        }

        /// <summary>
        /// Reorders the elements in the given range [first, last) such that each possible permutation
        /// of those elements has equal probability of appearance.
        /// </summary>
        /// <param name="first">Range of elements to shuffle randomly.</param>
        /// <param name="last">Range of elements to shuffle randomly.</param>
        template<typename RandomIt>
        static void Shuffle(RandomIt first, RandomIt last)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            std::shuffle(first, last, EngineInstance());
        }

        /// <summary>
        /// Reorders the elements in the given container such that each possible permutation of those elements
        /// has equal probability of appearance.
        /// </summary>
        /// <param name="container">Container with elements to shuffle randomly.</param>
        template<typename Container>
        static void Shuffle(Container& container)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            Shuffle(std::begin(container), std::end(container));
        }

        /// <summary>
        /// Get internal engine by copy.
        /// </summary>
        /// <returns>Internal engine.</returns>
        [[nodiscard]] static engine GetEngine()
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return EngineInstance();
        }

        /// <summary>
        /// Get internal engine by reference,
        /// </summary>
        /// <returns>Internal engine.</returns>
        [[nodiscard]] static engine& Engine()
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return EngineInstance();
        }

    protected:
        /// <summary>
        /// Get reference to the static engine instance.
        /// </summary>
        /// <returns>Static engine instance.</returns>
        [[nodiscard]] static engine& EngineInstance()
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            static engine Engine{ Seeder{ }() };
            return Engine;
        }
    };

    /// <summary>
    /// Base template class for random with thread_local API and thread_local internal member storage.
    ///
    /// Note: It IS thread safe but less efficient then BasicRandomStatic.
    /// </summary>
    /// <typeparam name="engine">A random engine with interface like in the std::mt19937.</typeparam>
    /// <typeparam name="Seeder">A seeder type which return seed for internal engine through operator().</typeparam>
    template<typename engine,
             typename Seeder = SeederDefault,
             template<typename> class IntegerDist = std::uniform_int_distribution,
             template<typename> class RealDist = std::uniform_real_distribution,
             typename BoolDist = std::bernoulli_distribution>
    class BasicRandomThreadLocal
	{
    public:
        /// <summary>
        /// Constructor.
        /// </summary>
        constexpr BasicRandomThreadLocal() = delete;
        /// <summary>
        /// Destructor.
        /// </summary>
        constexpr ~BasicRandomThreadLocal() = delete;
        /// <summary>
        /// Copy constructor.
        /// </summary>
        constexpr BasicRandomThreadLocal(const BasicRandomThreadLocal&) = delete;
        /// <summary>
        /// Copy assignment operator.
        /// </summary>
        constexpr BasicRandomThreadLocal operator=(const BasicRandomThreadLocal&) = delete;
        /// <summary>
        /// Move constructor.
        /// </summary>
        constexpr BasicRandomThreadLocal(BasicRandomThreadLocal&&) = delete;
        /// <summary>
        /// Move assignment operator.
        /// </summary>
        constexpr BasicRandomThreadLocal operator=(BasicRandomThreadLocal&&) = delete;

        /// <summary>
        /// Type of used random number engine.
        /// </summary>
        using EngineType = engine;

        /// <summary>
        /// Type of used random number seeder.
        /// </summary>
        using SeederType = Seeder;

        /// <summary>
        /// Type of used integer distribution
        /// </summary>
        template<typename T>
        using IntegerDistT = IntegerDist<T>;

        /// <summary>
        /// Type of used real distribution
        /// </summary>
        template<typename T>
        using RealDistT = RealDist<T>;

        /// <summary>
        /// Type of used bool distribution.
        /// </summary>
        using BoolDistT = BoolDist;

        /// <summary>
        /// Key type for getting common type numbers or objects.
        /// </summary>
        using Common = INTERNAL::Common;

        /// <summary>
        /// Retrieve the minimum value potentially generated by the random-number engine.
        /// </summary>
        /// <returns>Minimum value.</returns>
        [[nodiscard]] static constexpr typename engine::result_type Min()
        {
            return engine::min();
        }

        /// <summary>
        /// Retrieve the maximum value potentially generated by the random-number engine.
        /// </summary>
        /// <returns>Maximum value.</returns>
        [[nodiscard]] static constexpr typename engine::result_type Max()
    	{
            return engine::max();
        }

        /// <summary>
        /// Advances the internal state by z times.
        /// </summary>
        /// <param name="z">How many times to advance.</param>
        static void Discard(const uint64_t z)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            EngineInstance().discard(z);
        }

        /// <summary>
        /// Reseed by seeder.
        /// </summary>
        static void Reseed()
        {
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            const Seeder seeder;
            Seed(seeder());
        }

        /// <summary>
        /// Re-Initializes the internal state of the random-number engine using new seed value.
        /// </summary>
        /// <param name="value">Seed value to use in the initialization of the internal state.</param>
        static void Seed(const typename engine::result_type value = engine::default_seed)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            EngineInstance().seed(value);
        }

        /// <summary>
        /// Re-Initializes the internal state of the random-number engine using new seed value.
        /// </summary>
        /// <param name="seq">Seed sequence to use in the initialization of the internal state.</param>
        template<typename SSeq>
        static void Seed(SSeq& seq)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            EngineInstance().seed(seq);
        }

        /// <summary>
        /// Retrieve a random number from engine in [min(), max()] range.
        /// </summary>
        /// <returns>Random number.</returns>
        [[nodiscard]] static typename engine::result_type Get()
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return EngineInstance()();
        }

        /// <summary>
        /// Compares internal pseudo-random number engine with 'other' pseudo-random number engine.
        /// Two engines are equal, if their internal states are equivalent, that is, if they would generate
        /// equivalent values for any number of calls of operator().
        /// </summary>
        /// <param name="other">Engine, with which the internal engine will be compared.</param>
        /// <returns>True if other and internal engine are equal, false otherwise</returns>
        [[nodiscard]] static bool IsEqual(const engine& other)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return EngineInstance() == other;
        }

        /// <summary>
        /// Serializes the internal state of the internal pseudo-random number engine as a sequence
        /// of decimal numbers separated by one or more spaces, and inserts it to the stream ost.
        /// The fill character and the formatting flags of the stream are ignored and unaffected.
        /// </summary>
        /// <param name="ost">Output stream to insert the data to.</param>
        template<typename CharT, typename Traits>
        static void Serialize(std::basic_ostream<CharT, Traits>& ost)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            ost << EngineInstance();
        }

        /// <summary>
        /// Restores the internal state of the internal pseudo-random number engine from
        /// the serialized representation, which was created by an earlier call to 'Serialize'
        /// using a stream with the same imbued locale and the same CharT and Traits.
        /// If the input cannot be deserialized, internal engine is left unchanged and fail-Bit is raised on ist.
        /// </summary>
        /// <param name="ist">Input stream to extract the data from.</param>
        template<typename CharT, typename Traits>
        static void Deserialize(std::basic_istream<CharT, Traits>& ist)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            ist >> EngineInstance();
        }

        /// <summary>
        /// Generate a random integer number in a [from; to] range by std::uniform_int_distribution.
        /// </summary>
        /// <param name="from">First limit number of a random range.</param>
        /// <param name="to">Second limit number of a random range.</param>
        /// <returns>Random integer number in a [from; to] range.</returns>
        template<typename T>
        [[nodiscard]] static typename std::enable_if<INTERNAL::IsUniformInt<T>::value, T>::type
    	Get(T from = std::numeric_limits<T>::min(), T to = std::numeric_limits<T>::max())
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            if (from < to) //Allow range from higher to lower
                return IntegerDist<T>{ from, to }(EngineInstance());

            return IntegerDist<T>{ to, from }(EngineInstance());
        }

        /// <summary>
        /// Generate a random real number in a [from; to] range by std::uniform_real_distribution.
        /// </summary>
        /// <param name="from">First limit number of a random range</param>
        /// <param name="to">Second limit number of a random range.</param>
        /// <returns>Random real number in a [from; to] range.</returns>
        template<typename T>
        [[nodiscard]] static typename std::enable_if<INTERNAL::IsUniformReal<T>::value, T>::type
    	Get(T from = std::numeric_limits<T>::min(), T to = std::numeric_limits<T>::max())
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            if (from < to) //Allow range from higher to lower
                return RealDist<T>{ from, to }(EngineInstance());

            return RealDist<T>{ to, from }(EngineInstance());
        }

        /// <summary>
        /// Generate a random byte number in a [from; to] range.
        /// </summary>
        /// <param name="from">First limit number of a random range.</param>
        /// <param name="to">Second limit number of a random range.</param>
        /// <returns>Random byte number in a [from; to] range.</returns>
        template<typename T>
        [[nodiscard]] static typename std::enable_if<INTERNAL::IsByte<T>::value, T>::type
    	Get(T from = std::numeric_limits<T>::min(), T to = std::numeric_limits<T>::max())
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            //Choose between short and unsigned short for byte conversion
            using short_t = typename std::conditional<std::is_signed<T>::value,
                int16_t, uint16_t>::type;

            return static_cast<T>(Get<short_t>(from, to));
        }

        /// <summary>
        /// Generate a random common_type number in a [from; to] range.
        /// </summary>
        /// <typeparam name="Key">
        /// The Key type for this version of 'get' method Type should be '(THIS_TYPE)::Common' struct.
        /// </typeparam>
        /// <param name="from">First limit number of a random range.</param>
        /// <param name="to">Second limit number of a random range.</param>
        /// <returns>Random common_type number in a [from; to] range.</returns>
        template<typename Key,
                 typename A,
                 typename B,
                 typename C = typename std::common_type<A, B>::type>
        [[nodiscard]] static typename std::enable_if<std::is_same<Key, Common>::value &&
                                       INTERNAL::IsSupportedNumber<A>::value &&
                                       INTERNAL::IsSupportedNumber<B>::value &&
			                           //Prevent implicit type conversion from singed to unsigned types
			                           std::is_signed<A>::value != std::is_unsigned<B>::value, C>::type
    	Get(A from = std::numeric_limits<A>::min(), B to = std::numeric_limits<B>::max())
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return Get(static_cast<C>(from), static_cast<C>(to));
        }

        /// <summary>
        /// Generate a random character in a [from; to] range by std::uniform_int_distribution.
        /// </summary>
        /// <param name="from">First limit number of a random range.</param>
        /// <param name="to">Second limit number of a random range.</param>
        /// <returns>Random character in a [from; to] range.</returns>
        template<typename T>
        [[nodiscard]] static typename std::enable_if<INTERNAL::IsSupportedCharacter<T>::value, T>::type
    	Get(T from = std::numeric_limits<T>::min(), T to = std::numeric_limits<T>::max())
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            if (from < to) //Allow range from higher to lower
                return static_cast<T>(IntegerDist<std::int64_t>{ static_cast<std::int64_t>(from),
                                                                 static_cast<std::int64_t>(to) }(EngineInstance()));

            return static_cast<T>(IntegerDist<std::int64_t>{ static_cast<std::int64_t>(to),
                                                             static_cast<std::int64_t>(from) }(EngineInstance()));
        }

        /// <summary>
        /// Generate a bool value with specific probability by std::bernoulli_distribution.
        /// </summary>
        /// <param name="probability">
        /// Probability of generating true in [0; 1] range 0 means always false, 1 means always true.
        /// </param>
        /// <returns>'True' with 'probability' probability ('False' otherwise).</returns>
        template<typename T>
        [[nodiscard]] static typename std::enable_if<std::is_same<T, bool>::value, bool>::type
    	Get(const double probability = 0.5)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            TRAP_ASSERT(0 <= probability && 1 >= probability, "BasicRandomThreadLocal::Get(): Out of range!"); //Out of [0; 1] range
            return BoolDist{ probability }(EngineInstance());
        }

        /// <summary>
        /// Retrieve a random value from initializer_list.
        /// </summary>
        /// <param name="init_list">initializer_list with values.</param>
        /// <returns>Random value from initializer_list.</returns>
        template<typename T>
        [[nodiscard]] static T Get(std::initializer_list<T> init_list)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            TRAP_ASSERT(0u != init_list.size(), "BasicRandomThreadLocal::Get(): Empty initializer_list!"); //Empty initializer_list
            return *Get(init_list.begin(), init_list.end());
        }

        /// <summary>
        /// Retrieve a random iterator from iterator range.
        /// </summary>
        /// <param name="first">Range of elements.</param>
        /// <param name="last">Range of elements.</param>
        /// <returns>Random iterator from [first, last) range.</returns>
        template<typename InputIt>
        [[nodiscard]] static typename std::enable_if<INTERNAL::IsIterator<InputIt>::value, InputIt>::type
    	Get(InputIt first, InputIt last)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            const auto size = std::distance(first, last);
            if (0 == size)
                return last;
            using diff_t = typename std::iterator_traits<InputIt>::difference_type;
            return std::next(first, Get<diff_t>(0, size - 1));
        }

        /// <summary>
        /// Retrieve a random iterator from container.
        /// </summary>
        /// <param name="container">Container with elements.</param>
        /// <returns>Random iterator from container.</returns>
        template<typename Container>
        [[nodiscard]] static auto Get(Container& container) ->
            typename std::enable_if<INTERNAL::IsIterator<decltype(std::begin(container))>::value,
    		decltype(std::begin(container))>::type
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return Get(std::begin(container), std::end(container));
        }

        /// <summary>
        /// Retrieve a random pointer from built-in array.
        /// </summary>
        /// <param name="array">Built-in array with elements</param>
        /// <returns>Pointer to random element in array.</returns>
        template<typename T, std::size_t N>
        [[nodiscard]] static T* Get(T(&array)[N])
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return std::addressof(array[Get<std::size_t>(0, N - 1)]);
        }

        /// <summary>
        /// Retrieve a value from custom Dist distribution seeded by internal random engine.
        /// </summary>
        /// <typeparam name="Dist">Type of custom distribution with next concept.</typeparam>
        /// <typeparam name="...Args">Arguments which will be forwarded to Dist constructor.</typeparam>
        /// <returns>Value from custom distribution.</returns>
        template<typename Dist, typename... Args>
        [[nodiscard]] static typename Dist::result_type Get(Args&&... args)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return Dist{ std::forward<Args>(args)... }(EngineInstance());
        }

        /// <summary>
        /// Retrieve a value from custom 'dist' distribution seeded by internal random engine.
        /// </summary>
        /// <typeparam name="Dist">Custom distribution with next concept.</typeparam>
        /// <param name="dist">Custom distribution with next concept.</param>
        /// <returns>Value from custom 'dist' distribution.</returns>
        template<typename Dist>
        [[nodiscard]] static typename Dist::result_type Get(Dist& dist)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return dist(EngineInstance());
        }

        /// <summary>
        /// Reorders the elements in the given range [first, last) such that each possible permutation of
        /// those elements has equal probability of appearance.
        /// </summary>
        /// <param name="first">Range of elements to shuffle randomly.</param>
        /// <param name="last">Range of elements to shuffle randomly.</param>
        template<typename RandomIt>
        static void Shuffle(RandomIt first, RandomIt last)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            std::shuffle(first, last, EngineInstance());
        }

        /// <summary>
        /// Reorders the elements in the given container such that each possible permutation of those elements
        /// has equal probability of appearance.
        /// </summary>
        /// <typeparam name="Container">Container with elements to shuffle randomly.</typeparam>
        /// <param name="container">Container with elements to shuffle randomly.</param>
        template<typename Container>
        static void Shuffle(Container& container)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            Shuffle(std::begin(container), std::end(container));
        }

        /// <summary>
        /// Retrieve internal engine by copy.
        /// </summary>
        /// <returns>Internal engine.</returns>
        [[nodiscard]] static engine GetEngine()
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return EngineInstance();
        }

        /// <summary>
        /// Retrieve internal engine by ref.
        /// </summary>
        /// <returns>Internal engine.</returns>
        [[nodiscard]] static engine& Engine()
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return EngineInstance();
        }
    protected:
        /// <summary>
        /// Get reference to the thread local engine instance.
        /// </summary>
        /// <returns>Thread local engine reference.</returns>
        [[nodiscard]] static engine& EngineInstance()
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            thread_local engine Engine{ Seeder{ }() };
            return Engine;
        }
    };

    /// <summary>
    /// Base template class for random with local API and local internal member storage.
    /// It IS thread safe but less efficient then BasicRandomStatic.
    /// </summary>
    /// <typeparam name="engine">Random engine with interface like in the std::mt19937.</typeparam>
    /// <typeparam name="Seeder">Seeder type which return seed for internal engine through operator().</typeparam>
    template<typename engine,
             typename Seeder = SeederDefault,
             template<typename> class IntegerDist = std::uniform_int_distribution,
             template<typename> class RealDist = std::uniform_real_distribution,
             typename BoolDist = std::bernoulli_distribution>
    class BasicRandomLocal
	{
    public:
        /// <summary>
        /// Type of used random number engine.
        /// </summary>
        using EngineType = engine;

        /// <summary>
        /// Type of used random number seeder.
        /// </summary>
        using SeederType = Seeder;

        /// <summary>
        /// Type of used integer distribution.
        /// </summary>
        template<typename T>
        using IntegerDistT = IntegerDist<T>;

        /// <summary>
        /// Type of used real distribution.
        /// </summary>
        template<typename T>
        using RealDistT = RealDist<T>;

        /// <summary>
        /// Type of used bool distribution.
        /// </summary>
        using BoolDistT = BoolDist;

        /// <summary>
        /// Key type for getting common type numbers or objects.
        /// </summary>
        using Common = INTERNAL::Common;

        /// <summary>
        /// Retrieve the minimum value potentially generated by the random-number engine.
        /// </summary>
        /// <returns>Minimum random number.</returns>
        [[nodiscard]] static constexpr typename engine::result_type Min()
    	{
            return engine::min();
        }

        /// <summary>
        /// Retrieve the maximum value potentially generated by the random-number engine.
        /// </summary>
        /// <returns>Maximum random number.</returns>
        [[nodiscard]] static constexpr typename engine::result_type Max()
    	{
            return engine::max();
        }

        /// <summary>
        /// Advances the internal state by z times
        /// </summary>
        /// <param name="z">How many times to advance.</param>
        void Discard(const uint64_t z)
        {
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            m_engine.discard(z);
        }

        /// <summary>
        /// Reseed by seeder.
        /// </summary>
        void Reseed()
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            const Seeder seeder;
            Seed(seeder());
        }

        /// <summary>
        /// Re-Initializes the internal state of the random-number engine using new seed value.
        /// </summary>
        /// <param name="value">Seed value to use in the initialization of the internal state</param>
        void Seed(const typename engine::result_type value = engine::default_seed)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            m_engine.seed(value);
        }

        /// <summary>
        /// Re-Initializes the internal state of the random-number engine using new seed value.
        /// </summary>
        /// <param name="seq">Seed sequence to use in the initialization of the internal state.</param>
        template<typename SSeq>
        void Seed(SSeq& seq)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            m_engine.seed(seq);
        }

        /// <summary>
        /// Retrieve a random number from engine in [Min(), Max()] range.
        /// </summary>
        /// <returns>Random number.</returns>
        [[nodiscard]] typename engine::result_type Get()
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return m_engine();
        }

        /// <summary>
        /// Compares internal pseudo-random number engine with 'other' pseudo-random number engine.
        /// Two engines are equal, if their internal states are equivalent, that is, if they would generate
        /// equivalent values for any number of calls of operator().
        /// </summary>
        /// <param name="other">Engine, with which the internal engine will be compared.</param>
        /// <returns>True if other and internal engine are equal, false otherwise.</returns>
        [[nodiscard]] bool IsEqual(const engine& other) noexcept
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return m_engine == other;
        }

        /// <summary>
        /// Serializes the internal state of the internal pseudo-random number engine as a sequence
        /// of decimal numbers separated by one or more spaces, and inserts it to the stream ost.
        /// The fill character and the formatting flags of the stream are ignored and unaffected.
        /// </summary>
        /// <param name="ost">Output stream to insert the data to</param>
        template<typename CharT, typename Traits>
        void Serialize(std::basic_ostream<CharT, Traits>& ost)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            ost << m_engine;
        }

        /// <summary>
        /// Restores the internal state of the internal pseudo-random number engine from
        /// the serialized representation, which was created by an earlier call to 'Serialize'
        /// using a stream with the same imbued locale and the same CharT and Traits.
        /// If the input cannot be deserialized, internal engine is left unchanged and fail-Bit is raised on ist.
        /// </summary>
        /// <param name="ist">Input stream to extract the data from.</param>
        template<typename CharT, typename Traits>
        void Deserialize(std::basic_istream<CharT, Traits>& ist)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            ist >> m_engine;
        }

        /// <summary>
        /// Generate a random integer number in a [from; to] range by std::uniform_int_distribution.
        /// </summary>
        /// <param name="from">First limit number of a random range.</param>
        /// <param name="to">Second limit number of a random range.</param>
        /// <returns>Random integer number in a [from; to] range.</returns>
        template<typename T>
        [[nodiscard]] typename std::enable_if<INTERNAL::IsUniformInt<T>::value, T>::type
    	Get(T from = std::numeric_limits<T>::min(), T to = std::numeric_limits<T>::max())
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            if (from < to) //Allow range from higher to lower
                return IntegerDist<T>{ from, to }(m_engine);

            return IntegerDist<T>{ to, from }(m_engine);
        }

        /// <summary>
        /// Generate a random real number in a [from; to] range by std::uniform_real_distribution.
        /// </summary>
        /// <param name="from">First limit number of a random range.</param>
        /// <param name="to">Second limit number of a random range.</param>
        /// <returns>Random real number in a [from; to] range.</returns>
        template<typename T>
        [[nodiscard]] typename std::enable_if<INTERNAL::IsUniformReal<T>::value, T>::type
    	Get(T from = std::numeric_limits<T>::min(), T to = std::numeric_limits<T>::max())
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            if (from < to) //Allow range from higher to lower
                return RealDist<T>{ from, to }(m_engine);

            return RealDist<T>{ to, from }(m_engine);
        }

        /// <summary>
        /// Generate a random byte number in a [from; to] range.
        /// </summary>
        /// <param name="from">First limit number of a random range.</param>
        /// <param name="to">Second limit number of a random range.</param>
        /// <returns>Random byte number in a [from; to] range.</returns>
        template<typename T>
        [[nodiscard]] typename std::enable_if<INTERNAL::IsByte<T>::value, T>::type
    	Get(T from = std::numeric_limits<T>::min(), T to = std::numeric_limits<T>::max())
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            //Choose between short and unsigned short for byte conversion
            using short_t = typename std::conditional<std::is_signed<T>::value,
                int16_t, uint16_t>::type;

            return static_cast<T>(Get<short_t>(from, to));
        }

        /// <summary>
        /// Generate a random common_type number in a [from; to] range.
        /// </summary>
        /// <typeparam name="Key">
        /// Key type for this version of 'Get' method Type should be '(THIS_TYPE)::Common' struct.
        /// </typeparam>
        /// <param name="from">First limit number of a random range.</param>
        /// <param name="to">Second limit number of a random range.</param>
        /// <returns>Random common_type number in a [from; to] range.</returns>
        template<typename Key,
                 typename A,
                 typename B,
                 typename C = typename std::common_type<A, B>::type>
        [[nodiscard]] typename std::enable_if<std::is_same<Key, Common>::value &&
                                INTERNAL::IsSupportedNumber<A>::value &&
                                INTERNAL::IsSupportedNumber<B>::value &&
			                    //Prevent implicit type conversion from singed to unsigned types
			                    std::is_signed<A>::value != std::is_unsigned<B>::value, C>::type
    	Get(A from = std::numeric_limits<A>::min(), B to = std::numeric_limits<B>::max())
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return Get(static_cast<C>(from), static_cast<C>(to));
        }

        /// <summary>
        /// Generate a random character in a [from; to] range by std::uniform_int_distribution.
        /// </summary>
        /// <param name="from">First limit number of a random range.</param>
        /// <param name="to">Second limit number of a random range.</param>
        /// <returns>Random character in a [from; to] range.</returns>
        template<typename T>
        [[nodiscard]] typename std::enable_if<INTERNAL::IsSupportedCharacter<T>::value, T>::type
    	Get(T from = std::numeric_limits<T>::min(), T to = std::numeric_limits<T>::max())
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            //Allow range from higher to lower
            if (from < to)
                return static_cast<T>(IntegerDist<std::int64_t>{ static_cast<std::int64_t>(from),
                                                                 static_cast<std::int64_t>(to) }(m_engine));

            return static_cast<T>(IntegerDist<std::int64_t>{ static_cast<std::int64_t>(to),
                                                             static_cast<std::int64_t>(from) }(m_engine));
        }

        /// <summary>
        /// Generate a bool value with specific probability by std::bernoulli_distribution.
        /// </summary>
        /// <param name="probability">
        /// Probability of generating true in [0; 1] range 0 means always false, 1 means always true.
        /// </param>
        /// <returns>'true' with 'probability' probability ('false' otherwise).</returns>
        template<typename T>
        [[nodiscard]] typename std::enable_if<std::is_same<T, bool>::value, bool>::type
    	Get(const double probability = 0.5)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            TRAP_ASSERT(0 <= probability && 1 >= probability, "BasicRandomLocal::Get(): Out of range!"); //Out of [0; 1] range
            return BoolDist{ probability }(m_engine);
        }

        /// <summary>
        /// Retrieve random value from initializer_list.
        /// </summary>
        /// <param name="init_list">initializer_list with values.</param>
        /// <returns>Random value from initializer_list.</returns>
        template<typename T>
        [[nodiscard]] T Get(std::initializer_list<T> init_list)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            TRAP_ASSERT(0u != init_list.size(), "BasicRandomLocal::Get(): Empty initializer_list!"); //Empty initializer_list
            return *Get(init_list.begin(), init_list.end());
        }

        /// <summary>
        /// Retrieve random iterator from iterator range.
        /// </summary>
        /// <param name="first">Range of elements.</param>
        /// <param name="last">Range of elements.</param>
        /// <returns>Random iterator from [first, last) range.</returns>
        template<typename InputIt>
        [[nodiscard]] typename std::enable_if<INTERNAL::IsIterator<InputIt>::value, InputIt>::type
    	Get(InputIt first, InputIt last)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            const auto size = std::distance(first, last);
            if (0 == size)
                return last;
            using diff_t = typename std::iterator_traits<InputIt>::difference_type;
            return std::next(first, Get<diff_t>(0, size - 1));
        }

        /// <summary>
        /// Retrieve random iterator from container.
        /// </summary>
        /// <typeparam name="Container">Container with elements.</typeparam>
        /// <param name="container">Container with elements.</param>
        /// <returns>Random iterator from container.</returns>
        template<typename Container>
        [[nodiscard]] auto Get(Container& container) ->
            typename std::enable_if<INTERNAL::IsIterator<decltype(std::begin(container))>::value,
    		decltype(std::begin(container))>::type
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return Get(std::begin(container), std::end(container));
        }

        /// <summary>
        /// Retrieve random pointer from built-in array.
        /// </summary>
        /// <param name="array">Built-in array with elements.</param>
        /// <returns>Pointer to random element in array.</returns>
        template<typename T, std::size_t N>
        [[nodiscard]] T* Get(T(&array)[N])
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return std::addressof(array[Get<std::size_t>(0, N - 1)]);
        }

        /// <summary>
        /// Retrieve value from custom Dist distribution seeded by internal random engine.
        /// </summary>
        /// <typeparam name="Dist">Type of custom distribution with next concept.</typeparam>
        /// <typeparam name="...Args">Arguments which will be forwarded to dist constructor.</typeparam>
        /// <returns>Value from custom distribution.</returns>
        template<typename Dist, typename... Args>
        [[nodiscard]] typename Dist::result_type Get(Args&&... args)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return Dist{ std::forward<Args>(args)... }(m_engine);
        }

        /// <summary>
        /// Retrieve value from custom 'dist' distribution seeded by internal random engine.
        /// </summary>
        /// <typeparam name="Dist">Custom distribution with next concept.</typeparam>
        /// <param name="dist">Custom distribution with next concept.</param>
        /// <returns>Value from custom 'dist' distribution.</returns>
        template<typename Dist>
        [[nodiscard]] typename Dist::result_type Get(Dist& dist)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return dist(m_engine);
        }

        /// <summary>
        /// Reorders the elements in the given range [first, last) such that each possible permutation of
        /// those elements has equal probability of appearance.
        /// </summary>
        /// <param name="first">Range of elements to shuffle randomly.</param>
        /// <param name="last">Range of elements to shuffle randomly.</param>
        template<typename RandomIt>
        void Shuffle(RandomIt first, RandomIt last)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            std::shuffle(first, last, m_engine);
        }

        /// <summary>
        /// Reorders the elements in the given container such that each possible permutation of those elements
        /// has equal probability of appearance.
        /// </summary>
        /// <typeparam name="Container">Container with elements to shuffle randomly.</typeparam>
        /// <param name="container">Container with elements to shuffle randomly.</param>
        template<typename Container>
        void Shuffle(Container& container)
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            Shuffle(std::begin(container), std::end(container));
        }

        /// <summary>
        /// Retrieve internal engine by copy.
        /// </summary>
        /// <returns>Internal engine.</returns>
        [[nodiscard]] engine GetEngine() const noexcept
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return m_engine;
        }

        /// <summary>
        /// Retrieve internal engine by ref.
        /// </summary>
        /// <returns>Internal engine-</returns>
        [[nodiscard]] engine& Engine() noexcept
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            return m_engine;
        }

    protected:
        /// <summary>
        /// Retrieve engine seeded by seeder
        /// </summary>
        /// <returns>Seeded engine.</returns>
        [[nodiscard]] static engine MakeSeededEngine()
    	{
	        ZoneNamedC(__tracy, tracy::Color::Violet, TRAP_PROFILE_SYSTEMS() & ProfileSystems::Utils);

            //Make seeder instance for seed return by reference like std::seed_seq
            return engine{ Seeder{ }() };
        }

        /// <summary>
        /// Random number engine
        /// </summary>
        engine m_engine{ MakeSeededEngine() };
    };
}

//-------------------------------------------------------------------------------------------------------------------//

namespace TRAP::Utils
{
	/// <summary>
	/// The basic static random alias based on a std::mt19937_64.
	/// It uses static methods API and data with static storage.
	/// Note: Not thread safe but more performance.
	/// </summary>
	using Random = BasicRandomStatic<std::mt19937_64>;

	/// <summary>
	/// The basic static random alias based on a std::mt19937_64.
	/// It uses static methods API and data with thread_local storage.
	/// Note: Thread safe but less performance.
	/// </summary>
	using RandomThreadLocal = BasicRandomThreadLocal<std::mt19937_64>;

    /// <summary>
    /// The basic static random alias based on a std::mt19937_64.
    /// It uses non static methods API and data with auto storage.
    /// Note: Not thread safe. Should construct on the stack at local scope.
    /// </summary>
    using RandomLocal = BasicRandomLocal<std::mt19937_64>;
}

#endif /*TRAP_RANDOM_H*/