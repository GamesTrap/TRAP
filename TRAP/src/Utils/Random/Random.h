#ifndef _TRAP_RANDOM_H_
#define _TRAP_RANDOM_H_

#include "TRAPPCH.h"

namespace TRAP::Utils
{
    namespace INTERNAL {
        //Key type for getting common type numbers or objects
        struct Common { };

        //True if type T is applicable by a std::uniform_int_distribution
        template<typename T>
        struct IsUniformInt
    	{
            static constexpr bool value =
                std::is_same<T, short>::value
                || std::is_same<T, int>::value
                || std::is_same<T, long>::value
                || std::is_same<T, long long>::value
                || std::is_same<T, unsigned short>::value
                || std::is_same<T, unsigned int>::value
                || std::is_same<T, unsigned long>::value
                || std::is_same<T, unsigned long long>::value;
        };

        //True if type T is applicable by a std::uniform_real_distribution
        template<typename T>
        struct IsUniformReal
    	{
            static constexpr bool value =
                std::is_same<T, float>::value
                || std::is_same<T, double>::value
                || std::is_same<T, long double>::value;
        };

        //True if type T is plain byte
        template<typename T>
        struct IsByte
    	{
            static constexpr bool value =
                std::is_same<T, signed char>::value
                || std::is_same<T, unsigned char>::value;
        };

        //True if type T is plain number type
        template<typename T>
        struct IsSupportedNumber
    	{
            static constexpr bool value =
                IsByte        <T>::value
                || IsUniformReal<T>::value
                || IsUniformInt <T>::value;
        };

        //True if type T is character type
        template<typename T>
        struct IsSupportedCharacter
    	{
            static constexpr bool value =
                std::is_same<T, char>::value
                || std::is_same<T, wchar_t>::value
                || std::is_same<T, char16_t>::value
                || std::is_same<T, char32_t>::value;
        };

        //True if type T is iterator
        template<typename T>
        struct IsIterator
    	{
        private:
            static char Test(...);

            template <typename U,
                typename = typename std::iterator_traits<U>::difference_type,
                typename = typename std::iterator_traits<U>::pointer,
                typename = typename std::iterator_traits<U>::reference,
                typename = typename std::iterator_traits<U>::value_type,
                typename = typename std::iterator_traits<U>::iterator_category
            > static long Test(U&&);
        public:
            static constexpr bool value = std::is_same<
                decltype(Test(std::declval<T>())), long>::value;
        };

    }

    //Default seeder for 'random' classes
    struct SeederDefault
	{
        //Return seed sequence
        std::seed_seq& operator() ()
    	{
            //Use std::seed_seq with additional seed from C++ chrono
            return SeedSeq;
        }
    private:
        std::seed_seq SeedSeq
    	{ {
                static_cast<std::uintmax_t>(std::random_device{ }()),
                static_cast<std::uintmax_t>(std::chrono::steady_clock::now()
                                             .time_since_epoch().count()),
        } };
    };

    //Base template class for random with static API and static internal member storage
    //It is NOT thread safe but more efficient then basic_random_thread_local
    //Engine: A random engine with interface like in the std::mt19937
    //Seeder: A seeder type which return seed for internal engine through operator()
    template
	<
        typename engine,
        typename Seeder = SeederDefault,
        template<typename> class IntegerDist = std::uniform_int_distribution,
        template<typename> class RealDist = std::uniform_real_distribution,
        typename BoolDist = std::bernoulli_distribution
    >
    class BasicRandomStatic {
    public:
        BasicRandomStatic() = delete;

        //Type of used random number engine
        using EngineType = engine;

        //Type of used random number seeder
        using SeederType = Seeder;

        //Type of used integer distribution
        template<typename T>
        using IntegerDistT = IntegerDist<T>;

        //Type of used real distribution
        template<typename T>
        using RealDistT = RealDist<T>;

        //Type of used bool distribution
        using BoolDistT = BoolDist;

        //Key type for getting common type numbers or objects
        using Common = INTERNAL::Common;

        //Return: The minimum value potentially generated by the random-number engine
        static constexpr typename engine::result_type Min()
    	{
            return engine::min();
        }

        //Return: The maximum value potentially generated by the random-number engine
        static constexpr typename engine::result_type Max()
    	{
            return engine::max();
        }

        //Advances the internal state by z times
        static void Discard(const unsigned long long z)
    	{
            EngineInstance().discard(z);
        }

        //Reseed by Seeder
        static void Reseed()
    	{
            Seeder seeder;
            Seed(seeder());
        }

        //Reinitializes the internal state of the random-number engine using new seed value
        //Value: The seed value to use in the initialization of the internal state
        static void Seed(const typename engine::result_type value =
            engine::default_seed)
    	{
            EngineInstance().seed(value);
        }

        //Reinitializes the internal state of the random-number engine using new seed value
        //Seq: The seed sequence to use in the initialization of the internal state
        template<typename SSeq>
        static void Seed(SSeq& seq)
    	{
            EngineInstance().seed(seq);
        }

        //Return random number from engine in [Min(), Max()] range
        static typename engine::result_type Get()
    	{
            return EngineInstance()();
        }

        //Compares internal pseudo-random number engine with 'other' pseudo-random number engine.
        //Two engines are equal, if their internal states are equivalent, that is, if they would generate
        //equivalent values for any number of calls of operator()
        //Other: The engine, with which the internal engine will be compared
        //Return: true, if other and internal engine are equal
        static bool IsEqual(const engine& other)
    	{
            return EngineInstance() == other;
        }

        //Serializes the internal state of the internal pseudo-random number engine as a sequence
        //of decimal numbers separated by one or more spaces, and inserts it to the stream ost. The fill character
        //and the formatting flags of the stream are ignored and unaffected.
        //Ost: The output stream to insert the data to
        template<typename CharT, typename Traits>
        static void Serialize(std::basic_ostream<CharT, Traits>& ost)
    	{
            ost << EngineInstance();
        }

        //Restores the internal state of the internal pseudo-random number engine from
        //the serialized representation, which was created by an earlier call to 'Serialize'
        //using a stream with the same imbued locale and the same CharT and Traits.
        //If the input cannot be deserialized, internal engine is left unchanged and failbit is raised on ist
        //Ist: The input stream to extract the data from
        template<typename CharT, typename Traits>
        static void Deserialize(std::basic_istream<CharT, Traits>& ist)
    	{
            ist >> EngineInstance();
        }

        //Generate a random integer number in a [from; to] range by std::uniform_int_distribution
        //From: The first limit number of a random range
        //To: The second limit number of a random range
        //Return: A random integer number in a [from; to] range
        //Allow both: 'from' <= 'to' and 'from' >= 'to'
        //Prevent implicit type conversion
        template<typename T>
        static typename std::enable_if<INTERNAL::IsUniformInt<T>::value
            , T>::type Get(T from = std::numeric_limits<T>::min(),
                T to = std::numeric_limits<T>::max())
    	{
            if (from < to) //Allow range from higher to lower
                return IntegerDist<T>{ from, to }(EngineInstance());
        	
            return IntegerDist<T>{ to, from }(EngineInstance());
        }

        //Generate a random real number in a [from; to] range by std::uniform_real_distribution
        //From: The first limit number of a random range
        //To: The second limit number of a random range
        //Return: A random real number in a [from; to] range
        //Allow both: 'from' <= 'to' and 'from' >= 'to'
        //Prevent implicit type conversion
        template<typename T>
        static typename std::enable_if<INTERNAL::IsUniformReal<T>::value
            , T>::type Get(T from = std::numeric_limits<T>::min(),
                T to = std::numeric_limits<T>::max())
    	{
            if (from < to) //Allow range from higher to lower
                return RealDist<T>{ from, to }(EngineInstance());
        	
            return RealDist<T>{ to, from }(EngineInstance());
        }

        //Generate a random byte number in a [from; to] range
    	//From: The first limit number of a random range
        //To: The second limit number of a random range
        //Return: A random byte number in a [from; to] range
        //Allow both: 'from' <= 'to' and 'from' >= 'to'
        //Prevent implicit type conversion
        template<typename T>
        static typename std::enable_if<INTERNAL::IsByte<T>::value
            , T>::type Get(T from = std::numeric_limits<T>::min(),
                T to = std::numeric_limits<T>::max())
    	{
            //Choose between short and unsigned short for byte conversion
            using short_t = typename std::conditional<std::is_signed<T>::value,
                short, unsigned short>::type;

            return static_cast<T>(Get<short_t>(from, to));
        }

        //Generate a random common_type number in a [from; to] range
        //Key: The Key type for this version of 'Get' method Type should be '(THIS_TYPE)::Common' struct
        //From: The first limit number of a random range
        //To: The second limit number of a random range
        //Return: A random common_type number in a [from; to] range
        //Allow both: 'from' <= 'to' and 'from' >= 'to'
        //Allow implicit type conversion
        //Prevent implicit type conversion from singed to unsigned types Why?
        //std::common_type<Unsigned, Signed> chooses unsigned value, then Signed value will be converted to Unsigned value
        //which gives us a wrong range for random values.
        template
    	<
            typename Key,
            typename A,
            typename B,
            typename C = typename std::common_type<A, B>::type
        >
            static typename std::enable_if<
            std::is_same<Key, Common>::value
            && INTERNAL::IsSupportedNumber<A>::value
            && INTERNAL::IsSupportedNumber<B>::value
            //Prevent implicit type conversion from singed to unsigned types
            && std::is_signed<A>::value != std::is_unsigned<B>::value
            , C>::type Get(A from = std::numeric_limits<A>::min(),
                B to = std::numeric_limits<B>::max())
    	{
            return Get(static_cast<C>(from), static_cast<C>(to));
        }

        //Generate a random character in a [from; to] range by std::uniform_int_distribution
        //From: The first limit number of a random range
        //To: The second limit number of a random range
        //Rreturn: A random character in a [from; to] range
        //Allow both: 'from' <= 'to' and 'from' >= 'to'
        //Prevent implicit type conversion
        template<typename T>
        static typename std::enable_if<INTERNAL::IsSupportedCharacter<T>::value
            , T>::type Get(T from = std::numeric_limits<T>::min(),
                T to = std::numeric_limits<T>::max())
    	{
            if (from < to) //Allow range from higher to lower
                return static_cast<T>(IntegerDist<std::int64_t>{ static_cast<std::int64_t>(from), static_cast<std::int64_t>(to) }(EngineInstance()));
        	
            return static_cast<T>(IntegerDist<std::int64_t>{ static_cast<std::int64_t>(to), static_cast<std::int64_t>(from) }(EngineInstance()));
        }

        //Generate a bool value with specific probability by std::bernoulli_distribution
        //Probability: The probability of generating true in [0; 1] range 0 means always false, 1 means always true
        //Return: 'true' with 'probability' probability ('false' otherwise)
        template<typename T>
        static typename std::enable_if<std::is_same<T, bool>::value
            , bool>::type Get(const double probability = 0.5)
    	{
            assert(0 <= probability && 1 >= probability); //Out of [0; 1] range
            return BoolDist{ probability }(EngineInstance());
        }

        //Return random value from initilizer_list
    	//init_list: initializer_list with values
        //Return: Random value from initializer_list
        //Should be 1 or more elements in initializer_list
        //Warning! Elements in initializer_list can't be moved
        template<typename T>
        static T Get(std::initializer_list<T> init_list)
    	{
            assert(0u != init_list.size());
            return *Get(init_list.begin(), init_list.end());
        }

        //Return random iterator from iterator range
    	//First, Last: the range of elements
        //Return Random iterator from [first, last) range
        //If first == last, return last
        template<typename InputIt>
        static typename std::enable_if<INTERNAL::IsIterator<InputIt>::value
            , InputIt>::type Get(InputIt first, InputIt last)
    	{
            const auto size = std::distance(first, last);
            if (0 == size) return last;
            using diff_t = typename std::iterator_traits<InputIt>::difference_type;
            return std::next(first, Get<diff_t>(0, size - 1));
        }

        //Return random iterator from Container
        //Container: The container with elements
        //Return: Random iterator from container
        //If container is empty return std::end( container ) iterator
        template<typename Container>
        static auto Get(Container& container) ->
            typename std::enable_if<INTERNAL::IsIterator<
            decltype(std::begin(container))>::value
            , decltype(std::begin(container))
            >::type
    	{
            return Get(std::begin(container), std::end(container));
        }

        //Return random pointer from built-in array
        //Array: The built-in array with elements
        //Return: Pointer to random element in array
        template<typename T, std::size_t N>
        static T* Get(T(&array)[N])
    	{
            return std::addressof(array[Get<std::size_t>(0, N - 1)]);
        }

        //Return value from custom Dist distribution seeded by internal random engine
        //Dist: The type of custom distribution with next concept
        //Args: The arguments which will be forwarded to Dist constructor
        //Return: Value from custom distribution
        template<typename Dist, typename... Args>
        static typename Dist::result_type Get(Args&&... args)
    	{
            return Dist{ std::forward<Args>(args)... }(EngineInstance());
        }

        //Return value from custom 'dist' distribution seeded by internal random engine
        //Dist: The custom distribution with next concept
        //Args: The arguments which will be forwarded to Dist constructor
        //Return: Value from custom 'dist' distribution
        template<typename Dist>
        static typename Dist::result_type Get(Dist& dist)
    	{
            return dist(EngineInstance());
        }

        //Reorders the elements in the given range [first, last) such that each possible permutation of those elements
        //has equal probability of appearance.
        //First, Last: the range of elements to shuffle randomly
        template<typename RandomIt>
        static void Shuffle(RandomIt first, RandomIt last)
    	{
            std::shuffle(first, last, EngineInstance());
        }

        //Reorders the elements in the given container such that each possible permutation of those elements
        //has equal probability of appearance.
        //Container: the container with elements to shuffle randomly
        template<typename Container>
        static void Shuffle(Container& container)
    	{
            Shuffle(std::begin(container), std::end(container));
        }

        //Return internal engine by copy
        static engine GetEngine()
    	{
            return EngineInstance();
        }

        //Return internal engine by ref
        static engine& Engine()
    	{
            return EngineInstance();
        }
    protected:
        //Get reference to the static engine instance
        static engine& EngineInstance() {
            static engine Engine{ Seeder{ }() };
            return Engine;
        }
    };

    //Base template class for random with thread_local API and thread_local internal member storage
    //It IS thread safe but less efficient then BasicRandomStatic
    //Engine: A random engine with interface like in the std::mt19937
    //Seeder: A seeder type which return seed for internal engine through operator()
    template
	<
        typename engine,
        typename Seeder = SeederDefault,
        template<typename> class IntegerDist = std::uniform_int_distribution,
        template<typename> class RealDist = std::uniform_real_distribution,
        typename BoolDist = std::bernoulli_distribution
    >
    class BasicRandomThreadLocal {
    public:
        BasicRandomThreadLocal() = delete;

        //Type of used random number engine
        using EngineType = engine;

        //Type of used random number seeder
        using SeederType = Seeder;

        //Type of used integer distribution
        template<typename T>
        using IntegerDistT = IntegerDist<T>;

        //Type of used real distribution
        template<typename T>
        using RealDistT = RealDist<T>;

        //Type of used bool distribution
        using BoolDistT = BoolDist;

        //Key type for getting common type numbers or objects
        using Common = INTERNAL::Common;

        //Return: The minimum value potentially generated by the random-number engine
        static constexpr typename engine::result_type Min()
    	{
            return engine::min();
        }

        //Return: The maximum value potentially generated by the random-number engine
        static constexpr typename engine::result_type Max()
    	{
            return engine::max();
        }

        //Advances the internal state by z times
        static void Discard(const unsigned long long z)
    	{
            EngineInstance().discard(z);
        }

        //Reseed by Seeder
        static void Reseed() {
            Seeder seeder;
            Seed(seeder());
        }

        //Reinitializes the internal state of the random-number engine using new seed value
        //Value: The seed value to use in the initialization of the internal state
        static void Seed(const typename engine::result_type value =
            engine::default_seed)
    	{
            EngineInstance().seed(value);
        }

        //Reinitializes the internal state of the random-number engine using new seed value
        //Seq: The seed sequence to use in the initialization of the internal state
        template<typename SSeq>
        static void Seed(SSeq& seq)
    	{
            EngineInstance().seed(seq);
        }

        //Return random number from engine in [min(), max()] range
        static typename engine::result_type Get()
    	{
            return EngineInstance()();
        }

        //Compares internal pseudo-random number engine with 'other' pseudo-random number engine.
        //Two engines are equal, if their internal states are equivalent, that is, if they would generate
        //equivalent values for any number of calls of operator()
        //Other: The engine, with which the internal engine will be compared
        //Return: true, if other and internal engine are equal
        static bool IsEqual(const engine& other)
    	{
            return EngineInstance() == other;
        }

        //Serializes the internal state of the internal pseudo-random number engine as a sequence
        //of decimal numbers separated by one or more spaces, and inserts it to the stream ost. The fill character
        //and the formatting flags of the stream are ignored and unaffected.
        //Ost: The output stream to insert the data to
        template<typename CharT, typename Traits>
        static void Serialize(std::basic_ostream<CharT, Traits>& ost)
    	{
            ost << EngineInstance();
        }

        //Restores the internal state of the internal pseudo-random number engine from
        //the serialized representation, which was created by an earlier call to 'Serialize'
        //using a stream with the same imbued locale and the same CharT and Traits.
        //If the input cannot be deserialized, internal engine is left unchanged and failbit is raised on ist
        //Ist: The input stream to extract the data from
        template<typename CharT, typename Traits>
        static void Deserialize(std::basic_istream<CharT, Traits>& ist)
    	{
            ist >> EngineInstance();
        }

        //Generate a random integer number in a [from; to] range by std::uniform_int_distribution
        //From: The first limit number of a random range
        //To: The second limit number of a random range
        //Return: A random integer number in a [from; to] range
        //Allow both: 'from' <= 'to' and 'from' >= 'to'
        //Prevent implicit type conversion
        template<typename T>
        static typename std::enable_if<INTERNAL::IsUniformInt<T>::value
            , T>::type Get(T from = std::numeric_limits<T>::min(),
                T to = std::numeric_limits<T>::max())
    	{
            if (from < to) //Allow range from higher to lower
                return IntegerDist<T>{ from, to }(EngineInstance());
        	
            return IntegerDist<T>{ to, from }(EngineInstance());
        }

        //Generate a random real number in a [from; to] range by std::uniform_real_distribution
        //From: The first limit number of a random range
        //To: The second limit number of a random range
        //Return: A random real number in a [from; to] range
        //Allow both: 'from' <= 'to' and 'from' >= 'to'
        //Prevent implicit type conversion
        template<typename T>
        static typename std::enable_if<INTERNAL::IsUniformReal<T>::value
            , T>::type Get(T from = std::numeric_limits<T>::min(),
                T to = std::numeric_limits<T>::max())
    	{
            if (from < to) //Allow range from higher to lower
                return RealDist<T>{ from, to }(EngineInstance());
        	
            return RealDist<T>{ to, from }(EngineInstance());
        }

        //Generate a random byte number in a [from; to] range
    	//From: The first limit number of a random range
        //To: The second limit number of a random range
        //Return: A random byte number in a [from; to] range
        //Allow both: 'from' <= 'to' and 'from' >= 'to'
        //Prevent implicit type conversion
        template<typename T>
        static typename std::enable_if<INTERNAL::IsByte<T>::value
            , T>::type Get(T from = std::numeric_limits<T>::min(),
                T to = std::numeric_limits<T>::max())
    	{
            //Choose between short and unsigned short for byte conversion
            using short_t = typename std::conditional<std::is_signed<T>::value,
                short, unsigned short>::type;

            return static_cast<T>(Get<short_t>(from, to));
        }

        //Generate a random common_type number in a [from; to] range
        //Key: The Key type for this version of 'get' method Type should be '(THIS_TYPE)::Common' struct
        //From: The first limit number of a random range
        //To: The second limit number of a random range
        //Return: A random common_type number in a [from; to] range
        //Allow both: 'from' <= 'to' and 'from' >= 'to'
        //Allow implicit type conversion
        //Prevent implicit type conversion from singed to unsigned types Why?
        //std::common_type<Unsigned, Signed> chooses unsigned value, then Signed value will be converted to Unsigned value
        //which gives us a wrong range for random values.
        template
    	<
            typename Key,
            typename A,
            typename B,
            typename C = typename std::common_type<A, B>::type
        >
            static typename std::enable_if<
            std::is_same<Key, Common>::value
            && INTERNAL::IsSupportedNumber<A>::value
            && INTERNAL::IsSupportedNumber<B>::value
            //Prevent implicit type conversion from singed to unsigned types
            && std::is_signed<A>::value != std::is_unsigned<B>::value
            , C>::type Get(A from = std::numeric_limits<A>::min(),
                B to = std::numeric_limits<B>::max())
    	{
            return Get(static_cast<C>(from), static_cast<C>(to));
        }

        //Generate a random character in a [from; to] range by std::uniform_int_distribution
        //From: The first limit number of a random range
        //To: The second limit number of a random range
        //Return: A random character in a [from; to] range
        //Allow both: 'from' <= 'to' and 'from' >= 'to'
        //Prevent implicit type conversion
        template<typename T>
        static typename std::enable_if<INTERNAL::IsSupportedCharacter<T>::value
            , T>::type Get(T from = std::numeric_limits<T>::min(),
                T to = std::numeric_limits<T>::max())
    	{
            if (from < to) //Allow range from higher to lower
                return static_cast<T>(IntegerDist<std::int64_t>{ static_cast<std::int64_t>(from), static_cast<std::int64_t>(to) }(EngineInstance()));
        	
            return static_cast<T>(IntegerDist<std::int64_t>{ static_cast<std::int64_t>(to), static_cast<std::int64_t>(from) }(EngineInstance()));
        }

        //Generate a bool value with specific probability by std::bernoulli_distribution
        //Probability: The probability of generating true in [0; 1] range 0 means always false, 1 means always true
        //Return: 'true' with 'probability' probability ('false' otherwise)
        template<typename T>
        static typename std::enable_if<std::is_same<T, bool>::value
            , bool>::type Get(const double probability = 0.5)
    	{
            assert(0 <= probability && 1 >= probability); //Out of [0; 1] range
            return BoolDist{ probability }(EngineInstance());
        }

        //Return random value from initializer_list
    	//init_list: initializer_list with values
        //Rreturn: Random value from initializer_list
        //Should be 1 or more elements in initializer_list
        //Warning! Elements in initializer_list can't be moved:
        template<typename T>
        static T Get(std::initializer_list<T> init_list)
    	{
            assert(0u != init_list.size());
            return *Get(init_list.begin(), init_list.end());
        }

        //Return random iterator from iterator range
    	//First, Last: the range of elements
        //Return: Random iterator from [first, last) range
        //If first == last, return last
        template<typename InputIt>
        static typename std::enable_if<INTERNAL::IsIterator<InputIt>::value
            , InputIt>::type Get(InputIt first, InputIt last)
    	{
            const auto size = std::distance(first, last);
            if (0 == size) return last;
            using diff_t = typename std::iterator_traits<InputIt>::difference_type;
            return std::next(first, Get<diff_t>(0, size - 1));
        }

        //Return random iterator from Container
    	//Container: The container with elements
        //Return: Random iterator from container
        //If container is empty return std::end( container ) iterator
        template<typename Container>
        static auto Get(Container& container) ->
            typename std::enable_if<INTERNAL::IsIterator<
            decltype(std::begin(container))>::value
            , decltype(std::begin(container))
            >::type
    	{
            return Get(std::begin(container), std::end(container));
        }

        //Return random pointer from built-in array
        //Array: The built-in array with elements
        //Return: Pointer to random element in array
        template<typename T, std::size_t N>
        static T* Get(T(&array)[N])
    	{
            return std::addressof(array[Get<std::size_t>(0, N - 1)]);
        }

        //Return value from custom Dist distribution seeded by internal random engine
        //Dist: The type of custom distribution with next concept
        //Args: The arguments which will be forwarded to Dist constructor
        //Return: Value from custom distribution
        template<typename Dist, typename... Args>
        static typename Dist::result_type Get(Args&&... args)
    	{
            return Dist{ std::forward<Args>(args)... }(EngineInstance());
        }

        //Return value from custom 'dist' distribution seeded by internal random engine
        //Dist: The custom distribution with next concept
        //Args: The arguments which will be forwarded to Dist constructor
        //Return: Value from custom 'dist' distribution
        template<typename Dist>
        static typename Dist::result_type Get(Dist& dist)
    	{
            return dist(EngineInstance());
        }

        //Reorders the elements in the given range [first, last) such that each possible permutation of those elements
        //has equal probability of appearance.
        //First, Last: the range of elements to shuffle randomly
        template<typename RandomIt>
        static void Shuffle(RandomIt first, RandomIt last)
    	{
            std::shuffle(first, last, EngineInstance());
        }

        //Reorders the elements in the given container such that each possible permutation of those elements
        //has equal probability of appearance.
        //Container: the container with elements to shuffle randomly
        template<typename Container>
        static void Shuffle(Container& container)
    	{
            Shuffle(std::begin(container), std::end(container));
        }

        //Return internal engine by copy
        static engine GetEngine() {
            return EngineInstance();
        }

        //Return internal engine by ref
        static engine& Engine() {
            return EngineInstance();
        }
    protected:
        //Get reference to the thread local engine instance
        static engine& EngineInstance() {
            thread_local engine Engine{ Seeder{ }() };
            return Engine;
        }
    };

    //Base template class for random with local API and local internal member storage
    //It IS thread safe but less efficient then BasicRandomStatic
    //Engine: A random engine with interface like in the std::mt19937
    //Seeder: A seeder type which return seed for internal engine through operator()
    template
	<
        typename engine,
        typename Seeder = SeederDefault,
        template<typename> class IntegerDist = std::uniform_int_distribution,
        template<typename> class RealDist = std::uniform_real_distribution,
        typename BoolDist = std::bernoulli_distribution
    >
    class BasicRandomLocal {
    public:
        //Type of used random number engine
        using EngineType = engine;

        //Type of used random number seeder
        using SeederType = Seeder;

        //Type of used integer distribution
        template<typename T>
        using IntegerDistT = IntegerDist<T>;

        //Type of used real distribution
        template<typename T>
        using RealDistT = RealDist<T>;

        //Type of used bool distribution
        using BoolDistT = BoolDist;

        //Key type for getting common type numbers or objects
        using Common = INTERNAL::Common;

        //Return: The minimum value potentially generated by the random-number engine
        static constexpr typename engine::result_type Min()
    	{
            return engine::min();
        }

        //Return The maximum value potentially generated by the random-number engine
        static constexpr typename engine::result_type Max()
    	{
            return engine::max();
        }

        //Advances the internal state by z times
        void Discard(const unsigned long long z)
    	{
            m_engine.discard(z);
        }

        //Reseed by Seeder
        void Reseed()
    	{
            Seeder seeder;
            Seed(seeder());
        }

        //Reinitializes the internal state of the random-number engine using new seed value
        //Value: The seed value to use in the initialization of the internal state
        void Seed(const typename engine::result_type value =
            engine::default_seed)
    	{
            m_engine.seed(value);
        }

        //Reinitializes the internal state of the random-number engine using new seed value
        //Seq: The seed sequence to use in the initialization of the internal state
        template<typename SSeq>
        void Seed(SSeq& seq)
    	{
            m_engine.seed(seq);
        }

        //Return random number from engine in [Min(), Max()] range
        typename engine::result_type Get()
    	{
            return m_engine();
        }

        //Compares internal pseudo-random number engine with 'other' pseudo-random number engine.
        //Two engines are equal, if their internal states are equivalent, that is, if they would generate
        //equivalent values for any number of calls of operator()
        //Other: The engine, with which the internal engine will be compared
        //Return: true, if other and internal engine are equal
        bool IsEqual(const engine& other)
    	{
            return m_engine == other;
        }

        //Serializes the internal state of the internal pseudo-random number engine as a sequence
        //of decimal numbers separated by one or more spaces, and inserts it to the stream ost. The fill character
        //and the formatting flags of the stream are ignored and unaffected.
        //Ost: The output stream to insert the data to
        template<typename CharT, typename Traits>
        void Serialize(std::basic_ostream<CharT, Traits>& ost)
    	{
            ost << m_engine;
        }

        //Restores the internal state of the internal pseudo-random number engine from
        //the serialized representation, which was created by an earlier call to 'Serialize'
        //using a stream with the same imbued locale and the same CharT and Traits.
        //If the input cannot be deserialized, internal engine is left unchanged and failbit is raised on ist
        //Ist: The input stream to extract the data from
        template<typename CharT, typename Traits>
        void Deserialize(std::basic_istream<CharT, Traits>& ist)
    	{
            ist >> m_engine;
        }

        //Generate a random integer number in a [from; to] range by std::uniform_int_distribution
        //From: The first limit number of a random range
        //To: The second limit number of a random range
        //Return: A random integer number in a [from; to] range
        //Allow both: 'from' <= 'to' and 'from' >= 'to'
        //Prevent implicit type conversion
        template<typename T>
        typename std::enable_if<INTERNAL::IsUniformInt<T>::value
            , T>::type Get(T from = std::numeric_limits<T>::min(),
                T to = std::numeric_limits<T>::max())
    	{
            if (from < to) //Allow range from higher to lower
                return IntegerDist<T>{ from, to }(m_engine);
        	
            return IntegerDist<T>{ to, from }(m_engine);
        }

        //Generate a random real number in a [from; to] range by std::uniform_real_distribution
        //From: The first limit number of a random range
        //To: The second limit number of a random range
        //Return: A random real number in a [from; to] range
        //Allow both: 'from' <= 'to' and 'from' >= 'to'
        //Prevent implicit type conversion
        template<typename T>
        typename std::enable_if<INTERNAL::IsUniformReal<T>::value
            , T>::type Get(T from = std::numeric_limits<T>::min(),
                T to = std::numeric_limits<T>::max())
    	{
            if (from < to) //Allow range from higher to lower
                return RealDist<T>{ from, to }(m_engine);
        	
            return RealDist<T>{ to, from }(m_engine);
        }

        //Generate a random byte number in a [from; to] range
    	//From: The first limit number of a random range
        //To: The second limit number of a random range
        //Return: A random byte number in a [from; to] range
        //Allow both: 'from' <= 'to' and 'from' >= 'to'
        //Prevent implicit type conversion
        template<typename T>
        typename std::enable_if<INTERNAL::IsByte<T>::value
            , T>::type Get(T from = std::numeric_limits<T>::min(),
                T to = std::numeric_limits<T>::max())
    	{
            //Choose between short and unsigned short for byte conversion
            using short_t = typename std::conditional<std::is_signed<T>::value,
                short, unsigned short>::type;

            return static_cast<T>(Get<short_t>(from, to));
        }

        //Generate a random common_type number in a [from; to] range
        //Key: The Key type for this version of 'Get' method Type should be '(THIS_TYPE)::Common' struct
        //From: The first limit number of a random range
        //To: The second limit number of a random range
        //Return: A random common_type number in a [from; to] range
        //Allow both: 'from' <= 'to' and 'from' >= 'to'
        //Allow implicit type conversion
        //Prevent implicit type conversion from singed to unsigned types Why?
        //std::common_type<Unsigned, Signed> chooses unsigned value, then Signed value will be converted to Unsigned value
        //which gives us a wrong range for random values.
        template
    	<
            typename Key,
            typename A,
            typename B,
            typename C = typename std::common_type<A, B>::type
        >
            typename std::enable_if<
            std::is_same<Key, Common>::value
            && INTERNAL::IsSupportedNumber<A>::value
            && INTERNAL::IsSupportedNumber<B>::value
            //Prevent implicit type conversion from singed to unsigned types
            && std::is_signed<A>::value != std::is_unsigned<B>::value
            , C>::type Get(A from = std::numeric_limits<A>::min(),
                B to = std::numeric_limits<B>::max())
    	{
            return Get(static_cast<C>(from), static_cast<C>(to));
        }

        //Generate a random character in a [from; to] range by std::uniform_int_distribution
        //From: The first limit number of a random range
        //To: The second limit number of a random range
        //Return: A random character in a [from; to] range
        //Allow both: 'from' <= 'to' and 'from' >= 'to'
        //Prevent implicit type conversion
        template<typename T>
        typename std::enable_if<INTERNAL::IsSupportedCharacter<T>::value
            , T>::type Get(T from = std::numeric_limits<T>::min(),
                T to = std::numeric_limits<T>::max())
    	{
            if (from < to) //Allow range from higher to lower
                return static_cast<T>(IntegerDist<std::int64_t>{ static_cast<std::int64_t>(from), static_cast<std::int64_t>(to) }(m_engine));

        	return static_cast<T>(IntegerDist<std::int64_t>{ static_cast<std::int64_t>(to), static_cast<std::int64_t>(from) }(m_engine));
        }

        //Generate a bool value with specific probability by std::bernoulli_distribution
        //Probability: The probability of generating true in [0; 1] range 0 means always false, 1 means always true
        //Return: 'true' with 'probability' probability ('false' otherwise)
        template<typename T>
        typename std::enable_if<std::is_same<T, bool>::value
            , bool>::type Get(const double probability = 0.5)
    	{
            assert(0 <= probability && 1 >= probability); //Out of [0; 1] range
            return BoolDist{ probability }(m_engine);
        }

        //Return random value from initializer_list
    	//init_list: initializer_list with values
        //Return: Random value from initializer_list
        //Should be 1 or more elements in initializer_list
        //Warning! Elements in initializer_list can't be moved
        template<typename T>
        T Get(std::initializer_list<T> init_list)
    	{
            assert(0u != init_list.size());
            return *Get(init_list.begin(), init_list.end());
        }

        //Return random iterator from iterator range
        //First, Last: the range of elements
        //Return Random iterator from [first, last) range
        //If first == last, return last
        template<typename InputIt>
        typename std::enable_if<INTERNAL::IsIterator<InputIt>::value
            , InputIt>::type Get(InputIt first, InputIt last)
    	{
            const auto size = std::distance(first, last);
            if (0 == size) return last;
            using diff_t = typename std::iterator_traits<InputIt>::difference_type;
            return std::next(first, Get<diff_t>(0, size - 1));
        }

        //Return random iterator from Container
        //Container: The container with elements
        //Return: Random iterator from container
        //If container is empty return std::end( container ) iterator
        template<typename Container>
        auto Get(Container& container) ->
            typename std::enable_if<INTERNAL::IsIterator<
            decltype(std::begin(container))>::value
            , decltype(std::begin(container))
            >::type
    	{
            return Get(std::begin(container), std::end(container));
        }

        //Return random pointer from built-in array
        //Array: The built-in array with elements
        //Return: Pointer to random element in array
        template<typename T, std::size_t N>
        T* Get(T(&array)[N])
    	{
            return std::addressof(array[Get<std::size_t>(0, N - 1)]);
        }

        //Return value from custom Dist distribution seeded by internal random engine
        //Dist: The type of custom distribution with next concept
        //Args: The arguments which will be forwarded to Dist constructor
        //Return: Value from custom distribution
        template<typename Dist, typename... Args>
        typename Dist::result_type Get(Args&&... args)
    	{
            return Dist{ std::forward<Args>(args)... }(m_engine);
        }

        //Return value from custom 'dist' distribution seeded by internal random engine
        //Dist: The custom distribution with next concept
        //Args: The arguments which will be forwarded to Dist constructor
        //Return: Value from custom 'dist' distribution
        template<typename Dist>
        typename Dist::result_type Get(Dist& dist)
    	{
            return dist(m_engine);
        }

        //Reorders the elements in the given range [first, last) such that each possible permutation of those elements
        //has equal probability of appearance.
        //First, Last: the range of elements to shuffle randomly
        template<typename RandomIt>
        void Shuffle(RandomIt first, RandomIt last)
    	{
            std::shuffle(first, last, m_engine);
        }

        //Reorders the elements in the given container such that each possible permutation of those elements
        //has equal probability of appearance.
        //Container: the container with elements to shuffle randomly
        template<typename Container>
        void Shuffle(Container& container)
    	{
            Shuffle(std::begin(container), std::end(container));
        }

        //Return internal engine by copy
        engine GetEngine() const
    	{
            return m_engine;
        }

        //Return internal engine by ref
        engine& Engine()
    	{
            return m_engine;
        }
    	
    protected:
        //Return engine seeded by Seeder
        static engine MakeSeededEngine() {
            //Make seeder instance for seed return by reference like std::seed_seq
            return engine{ Seeder{ }() };
        }

        //The random number engine
        engine m_engine{ MakeSeededEngine() };
    };
}

//-------------------------------------------------------------------------------------------------------------------//

namespace TRAP::Utils
{
	//The basic static random alias based on a std::mt19937_64
	//It uses static methods API and data with static storage
	//Not thread safe but more performance
	using Random = BasicRandomStatic<std::mt19937_64>;

	//The basic static random alias based on a std::mt19937_64
	//It uses static methods API and data with thread_local storage
	//Thread safe but less performance
	using RandomThreadLocal = BasicRandomThreadLocal<std::mt19937_64>;

    //The basic static random alias based on a std::mt19937
    //It uses non static methods API and data with auto storage
    //Not thread safe. Should construct on the stack at local scope
    using RandomLocal = BasicRandomLocal<std::mt19937>;
}

#endif /*_TRAP_RANDOM_H_*/